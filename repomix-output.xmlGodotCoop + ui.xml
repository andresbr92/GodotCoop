This file is a merged representation of a subset of the codebase, containing specifically included files, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: godot-coop/addons/inventory-system-demos/interaction_system/inventory_interactor.gd, godot-coop/addons/inventory-system-demos/interaction_system/interact_action.gd, godot-coop/addons/inventory-system-demos/fps/box_inventory.gd, godot-coop/addons/inventory-system-demos/fps/campfire.gd, godot-coop/addons/inventory-system-demos/fps/constraints/category_grid_inventory_constraint.gd, godot-coop/addons/inventory-system-demos/fps/constraints/stack_size_constraint.gd, godot-coop/addons/inventory-system-demos/fps/dropper.gd, godot-coop/addons/inventory-system-demos/fps/fps_demo.gd, godot-coop/addons/inventory-system-demos/fps/loot_box_inventory.gd, godot-coop/addons/inventory-system-demos/fps/modding_demo.gd, godot-coop/addons/inventory-system-demos/fps/player.gd, godot-coop/addons/inventory-system-demos/fps/props/shelf.gd, godot-coop/addons/inventory-system-demos/fps/props/visual_inventory_3d.gd, godot-coop/addons/inventory-system-demos/fps/props/visual_slot_3d.gd, godot-coop/addons/inventory-system-demos/fps/tool_hand_item_3d.gd, godot-coop/addons/inventory-system-demos/fps/use_items_example.gd, godot-coop/addons/inventory-system-demos/fps/workbench.gd, godot-coop/addons/inventory-system-demos/mp/sync_grid_inventory.gd, godot-coop/addons/inventory-system-demos/mp/sync_hotbar.gd, godot-coop/addons/inventory-system-demos/mp/sync_craft_station.gd, godot-coop/addons/inventory-system-demos/mp/placeable_item_spawner.gd, godot-coop/addons/inventory-system-demos/mp/networked_workbench.gd, godot-coop/addons/inventory-system-demos/mp/networked_use_items_example_3d.gd, godot-coop/addons/inventory-system-demos/mp/networked_shelf.gd, godot-coop/addons/inventory-system-demos/mp/networked_object_placer.gd, godot-coop/addons/inventory-system-demos/mp/networked_dropper.gd, godot-coop/addons/inventory-system-demos/mp/networked_character_inventory_system.gd, godot-coop/addons/inventory-system-demos/mp/networked_campfire.gd, godot-coop/addons/inventory-system-demos/mp/networked_box_inventory.gd, godot-coop/addons/inventory-system-demos/mp/mp_player.gd, godot-coop/addons/inventory-system-demos/mp/mp_demo.gd, godot-coop/addons/inventory-system-demos/mp/lag_test.gd, godot-coop/addons/inventory-system-demos/mp/dropped_item_spawner.gd, godot-coop/characters/character_base.gd, godot-coop/characters/npcs/human_dummy/human_npc.gd, godot-coop/characters/player/components/attribute_set.gd, godot-coop/characters/player/components/camera_follow.gd, godot-coop/characters/player/components/camera_spring_arm.gd, godot-coop/characters/player/components/coop_character_inventory_system.gd, godot-coop/characters/player/components/coop_character_inventory_system_ui.gd, godot-coop/characters/player/components/item_thrower.gd, godot-coop/characters/player/player.gd, godot-coop/items/definitions/throwable_data.gd, godot-coop/items/projectile_base.gd, godot-coop/items/world_models/potions/fire_potion_projectile.gd, godot-coop/levels/maps/main.gd, godot-coop/systems/multiplayer_spawner.gd, godot-coop/systems/network_manager.gd, godot-coop/systems/projectile_spawner.gd, godot-coop/addons/inventory-system-demos/ui/inventory_system_ui.gd, godot-coop/addons/inventory-system-demos/ui/drop_area.gd, godot-coop/addons/inventory-system-demos/ui/craft/recipe_ui.gd, godot-coop/addons/inventory-system-demos/ui/craft/ingredient_ui.gd, godot-coop/addons/inventory-system-demos/ui/craft/craftings_ui.gd, godot-coop/addons/inventory-system-demos/ui/craft/crafting_ui.gd, godot-coop/addons/inventory-system-demos/ui/craft/craft_station_ui.gd, godot-coop/addons/inventory-system-demos/ui/interactor/interactor_ui.gd, godot-coop/addons/inventory-system-demos/ui/interactor/input_icons.gd, godot-coop/addons/inventory-system-demos/ui/interactor/input_helper.gd, godot-coop/addons/inventory-system-demos/ui/interactor/action_message_ui.gd, godot-coop/addons/inventory-system-demos/ui/hotbar/hotbar_ui.gd, godot-coop/addons/inventory-system-demos/ui/hotbar/hotbar_slot_ui.gd, godot-coop/addons/inventory-system-demos/ui/grid/grid_slot_ui.gd, godot-coop/addons/inventory-system-demos/ui/grid/grid_selection_panel.gd, godot-coop/addons/inventory-system-demos/ui/grid/grid_item_stack_ui.gd, godot-coop/addons/inventory-system-demos/ui/grid/grid_inventory_ui.gd, godot-coop/addons/inventory-system-demos/ui/grid/grid_inventory_panel.gd, godot-coop/addons/inventory-system-demos/ui/grid/grid_drop_zone_ui.gd, godot-coop/addons/inventory-system-demos/ui/grid/grid_draggable_element_ui.gd
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
godot-coop/addons/inventory-system-demos/fps/box_inventory.gd
godot-coop/addons/inventory-system-demos/fps/campfire.gd
godot-coop/addons/inventory-system-demos/fps/constraints/category_grid_inventory_constraint.gd
godot-coop/addons/inventory-system-demos/fps/constraints/stack_size_constraint.gd
godot-coop/addons/inventory-system-demos/fps/dropper.gd
godot-coop/addons/inventory-system-demos/fps/fps_demo.gd
godot-coop/addons/inventory-system-demos/fps/loot_box_inventory.gd
godot-coop/addons/inventory-system-demos/fps/modding_demo.gd
godot-coop/addons/inventory-system-demos/fps/player.gd
godot-coop/addons/inventory-system-demos/fps/props/shelf.gd
godot-coop/addons/inventory-system-demos/fps/props/visual_inventory_3d.gd
godot-coop/addons/inventory-system-demos/fps/props/visual_slot_3d.gd
godot-coop/addons/inventory-system-demos/fps/tool_hand_item_3d.gd
godot-coop/addons/inventory-system-demos/fps/use_items_example.gd
godot-coop/addons/inventory-system-demos/fps/workbench.gd
godot-coop/addons/inventory-system-demos/interaction_system/interact_action.gd
godot-coop/addons/inventory-system-demos/interaction_system/inventory_interactor.gd
godot-coop/addons/inventory-system-demos/mp/dropped_item_spawner.gd
godot-coop/addons/inventory-system-demos/mp/lag_test.gd
godot-coop/addons/inventory-system-demos/mp/mp_demo.gd
godot-coop/addons/inventory-system-demos/mp/mp_player.gd
godot-coop/addons/inventory-system-demos/mp/networked_box_inventory.gd
godot-coop/addons/inventory-system-demos/mp/networked_campfire.gd
godot-coop/addons/inventory-system-demos/mp/networked_character_inventory_system.gd
godot-coop/addons/inventory-system-demos/mp/networked_dropper.gd
godot-coop/addons/inventory-system-demos/mp/networked_object_placer.gd
godot-coop/addons/inventory-system-demos/mp/networked_shelf.gd
godot-coop/addons/inventory-system-demos/mp/networked_use_items_example_3d.gd
godot-coop/addons/inventory-system-demos/mp/networked_workbench.gd
godot-coop/addons/inventory-system-demos/mp/placeable_item_spawner.gd
godot-coop/addons/inventory-system-demos/mp/sync_craft_station.gd
godot-coop/addons/inventory-system-demos/mp/sync_grid_inventory.gd
godot-coop/addons/inventory-system-demos/mp/sync_hotbar.gd
godot-coop/addons/inventory-system-demos/ui/craft/craft_station_ui.gd
godot-coop/addons/inventory-system-demos/ui/craft/crafting_ui.gd
godot-coop/addons/inventory-system-demos/ui/craft/craftings_ui.gd
godot-coop/addons/inventory-system-demos/ui/craft/ingredient_ui.gd
godot-coop/addons/inventory-system-demos/ui/craft/recipe_ui.gd
godot-coop/addons/inventory-system-demos/ui/drop_area.gd
godot-coop/addons/inventory-system-demos/ui/grid/grid_draggable_element_ui.gd
godot-coop/addons/inventory-system-demos/ui/grid/grid_drop_zone_ui.gd
godot-coop/addons/inventory-system-demos/ui/grid/grid_inventory_panel.gd
godot-coop/addons/inventory-system-demos/ui/grid/grid_inventory_ui.gd
godot-coop/addons/inventory-system-demos/ui/grid/grid_item_stack_ui.gd
godot-coop/addons/inventory-system-demos/ui/grid/grid_selection_panel.gd
godot-coop/addons/inventory-system-demos/ui/grid/grid_slot_ui.gd
godot-coop/addons/inventory-system-demos/ui/hotbar/hotbar_slot_ui.gd
godot-coop/addons/inventory-system-demos/ui/hotbar/hotbar_ui.gd
godot-coop/addons/inventory-system-demos/ui/interactor/action_message_ui.gd
godot-coop/addons/inventory-system-demos/ui/interactor/input_helper.gd
godot-coop/addons/inventory-system-demos/ui/interactor/input_icons.gd
godot-coop/addons/inventory-system-demos/ui/interactor/interactor_ui.gd
godot-coop/addons/inventory-system-demos/ui/inventory_system_ui.gd
godot-coop/characters/character_base.gd
godot-coop/characters/npcs/human_dummy/human_npc.gd
godot-coop/characters/player/components/attribute_set.gd
godot-coop/characters/player/components/camera_follow.gd
godot-coop/characters/player/components/camera_spring_arm.gd
godot-coop/characters/player/components/coop_character_inventory_system_ui.gd
godot-coop/characters/player/components/coop_character_inventory_system.gd
godot-coop/characters/player/components/item_thrower.gd
godot-coop/characters/player/player.gd
godot-coop/items/definitions/throwable_data.gd
godot-coop/items/projectile_base.gd
godot-coop/items/world_models/potions/fire_potion_projectile.gd
godot-coop/levels/maps/main.gd
godot-coop/systems/multiplayer_spawner.gd
godot-coop/systems/network_manager.gd
godot-coop/systems/projectile_spawner.gd
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="godot-coop/addons/inventory-system-demos/fps/box_inventory.gd">
class_name BoxInventory
extends Node3D

const Interactor = preload("../interaction_system/inventory_interactor.gd")

@onready var inventory : Inventory = $Inventory
@export var actions : Array
@onready var openable : Openable = $Openable
@export var constraints : Array[GridInventoryConstraint]

func _ready():
	openable.closed.connect(_on_openable_closed)
	openable.opened.connect(_on_openable_opened)
	inventory.grid_constraints = constraints

func get_inventory() -> Inventory:
	return $Inventory


func _on_inventory_opened():
	_on_open()


func _on_open():
	$box.visible = false
	$boxOpen.visible = true
	$Open.play()


func _on_close():
	$box.visible = true
	$boxOpen.visible = false
	$Close.play()


func get_interaction_position(_interaction_point : Vector3) -> Vector3:
	return position


func get_interact_actions(_interactor : Interactor) -> Array:
	if openable.is_open:
		return []
	return actions


func interact(character : Node, _action_index : int = 0):
	if !openable.is_open:
		character.character_inventory_system.open_inventory(inventory)
		open(character)


func open(character : Node):
	openable.open(character)


func close(character : Node):
	openable.close(character)


func _on_openable_opened(_character: Node) -> void:
	_on_open()


func _on_openable_closed(_character: Node) -> void:
	_on_close()
</file>

<file path="godot-coop/addons/inventory-system-demos/fps/campfire.gd">
class_name Campfire
extends Workbench

signal changed_burning_state(is_burning : bool)

@export var burnable_category : String = "burnables"
@onready var gpu_particles_3d = $Node/GPUParticles3D
@onready var audio_stream_player_3d = $Node/AudioStreamPlayer3D
@onready var craft_audio = $Node/CraftAudio
@export var toggle_fire_action : InteractAction

@export var decrease_fuel_multiplier = 1

var active_fire : bool = true:
	set(value):
		active_fire = value
		if value:
			is_burning = fuel > 0.0
		else:
			is_burning = false


var fuel := 0.0:
	set(new_value):
		fuel = new_value
		is_burning = fuel > 0.0

var max_seconds := 120.0

var is_burning := false:
	set(new_value):
		if is_burning != new_value:
			is_burning = new_value
			check()
			changed_burning_state.emit(is_burning)
			_update_is_burning()


func _ready():
	_update_is_burning()
	craft_station.on_crafted.connect(_on_crafted)
	input_inventory.contents_changed.connect(_on_input_inventory_contents_changed)


func _update_is_burning():
	$Node.visible = is_burning
	craft_station.auto_craft = is_burning
	craft_station.can_processing_craftings = is_burning
	audio_stream_player_3d.playing = is_burning


func _on_input_inventory_contents_changed():
	check()


func _on_crafted(_recipe_index: int):
	craft_audio.play(1.0)


func check() -> bool:
	if not active_fire:
		return false
	if is_burning:
		return false
	var category = input_inventory.database.get_category_from_id(burnable_category)
	if not input_inventory.contains_category(category):
		return false
	var index = input_inventory.get_stack_index_with_an_item_of_category(category)
	if index == -1:
		return false
	var item_id = input_inventory.stacks[index].item_id
	var definition = input_inventory.database.get_item(item_id)
	if not definition.properties.has("fuel"):
		return false
	fuel += definition.properties["fuel"]
	input_inventory.remove(item_id)
	return true


func _process(delta):
	if not active_fire:
		return
	if fuel > 0.0:
		fuel -= delta * decrease_fuel_multiplier


func get_interaction_position(_interaction_point : Vector3) -> Vector3:
	return position


func get_interact_actions(_interactor : Interactor) -> Array:
	if openable.is_open:
		return []
	var current_actions : Array = self.actions.duplicate()
	if fuel > 0.0:
		if active_fire:
			toggle_fire_action.description = "Disable Fire"
		else:
			toggle_fire_action.description = "Enable Fire"
		current_actions.append(toggle_fire_action)
	return current_actions


func interact(_character : Node, action_index : int = 0):
	if action_index == 0 and !openable.is_open:
		_character.character_inventory_system.open_inventory(craft_station.get_input_inventory())
		#craft_station.load_valid_recipes()
		openable.open(_character)
	else:
		active_fire = !active_fire
</file>

<file path="godot-coop/addons/inventory-system-demos/fps/constraints/category_grid_inventory_constraint.gd">
extends GridInventoryConstraint
class_name CategoryGridInventoryConstraint

@export var category_position: Dictionary
@export var is_only_one_category_for_slots: bool
@export var one_category_for_slots: String

func _can_add_on_position(inventory: Node, position: Vector2i, item_id: String, _amount: int, _properties: Dictionary, _is_rotated: bool):
	var def: ItemDefinition = inventory.database.get_item(item_id)
	if def == null:
		return false

	var size: Vector2i
	if _is_rotated:
		size = Vector2i(def.size.y, def.size.x)
	else:
		size = def.size

	for x in range(position.x,position.x + size.x):
		for y in range(position.y,position.y + size.y):
			var pos = Vector2i(x, y)
			var category: String = get_category(pos)
			if not contains_category(def, category):
				return false
	return true


func contains_category(def: ItemDefinition, category: String):
	if category != "":
		for c in def.categories:
			if c.id == category:
				return true
		return false
	else:
		return true

func get_category(position: Vector2i) -> String:
	if is_only_one_category_for_slots:
		return one_category_for_slots
	else:
		if category_position.has(position):
			var category : String = category_position[position]
			return category
		return ""
</file>

<file path="godot-coop/addons/inventory-system-demos/fps/constraints/stack_size_constraint.gd">
extends InventoryConstraint
class_name StackSizeConstraint

@export var max_size_stack: int = 2

func _can_add_new_stack_on_inventory(inventory: Node, _item_id: String, _amount: int, _properties: Dictionary) -> bool:
	if inventory.stacks.size() >= max_size_stack:
		return false
	return true

func _get_max_stack(_inventory: Node, item_id: String, _amount: int, _properties: Dictionary, max_stack: int) -> int:
	if item_id == "wood":
		return 32
	return max_stack
</file>

<file path="godot-coop/addons/inventory-system-demos/fps/dropper.gd">
extends Node3D
class_name Dropper

signal dropped(node : Node)

@export var inventories: Array[Inventory]
@export var database: InventoryDatabase
@export var dropped_item_property_name: String = "dropped_item"


func _ready() -> void:
	for inventory in inventories:
		inventory.request_drop_item.connect(drop)


func drop(item: String, amount:int = 1, properties: Dictionary = {}):
	var def = database.get_item(item)
	if def == null:
		return
	if not def.properties.has(dropped_item_property_name):
		return
	var obj = def.properties[dropped_item_property_name]
	if obj == null:
		return
	_on_request_drop_obj(obj, item, amount, properties)


func _on_request_drop_obj(dropped_item : String, item_id: String, amount: int, properties: Dictionary):
	var _database: InventoryDatabase = inventories[0].database
	var packed_scene : PackedScene = load(dropped_item)
	var node = packed_scene.instantiate()
	get_parent().get_parent().add_child(node)
	node.set("item_id", item_id)
	node.set("amount", amount)
	node.position = global_position
	node.set("rotation", global_rotation)
	node.set("item_properties", properties)
	dropped.emit(node)
</file>

<file path="godot-coop/addons/inventory-system-demos/fps/fps_demo.gd">
class_name FPSDemo
extends Node

@export var database : InventoryDatabase

var main_inventory : Inventory

func _ready():
	$"UI/Inventory System UI".setup($"Player/CharacterInventorySystem")
	main_inventory = $"Player/CharacterInventorySystem".main_inventory
	main_inventory.add("workbench", 1)
	main_inventory.add("helmet_labor", 1)
	main_inventory.add("wood", 16)
	main_inventory.add("stone", 8)

#
func _process(_delta):
	pass
	if Input.is_action_just_released("add_item_a"):
		main_inventory.add("wood", 1)
	if Input.is_action_just_released("remove_item_a"):
		main_inventory.remove("wood", 1)

	if Input.is_action_just_released("add_item_b"):
		main_inventory.add("stone", 1)
	if Input.is_action_just_released("remove_item_b"):
		main_inventory.remove("stone", 1)
#
	if Input.is_action_just_released("add_item_c"):
		main_inventory.add("grass", 1)
	if Input.is_action_just_released("remove_item_c"):
		main_inventory.remove("grass", 1)
</file>

<file path="godot-coop/addons/inventory-system-demos/fps/modding_demo.gd">
extends Node

@export var database : InventoryDatabase
@export var modding_file_path : String

func _ready() -> void:
	database.import_json_file(modding_file_path)
</file>

<file path="godot-coop/addons/inventory-system-demos/fps/player.gd">
class_name Player
extends CharacterBody3D

const SPEED = 5.0
const JUMP_VELOCITY = 4.5

# Get the gravity from the project settings to be synced with RigidBody nodes.
var gravity = ProjectSettings.get_setting("physics/3d/default_gravity")

@export var mouse_sensitivity := 0.002
@export var vertical_angle_limit := 90.0
var rot := Vector3()
@onready var character_inventory_system : CharacterInventorySystem = $CharacterInventorySystem
@onready var raycast : RayCast3D = $Camera3D/RayCast3D
@onready var camera_3d : Camera3D = $Camera3D

@export_group("ðŸ”Š Audios")
@export_node_path("AudioStreamPlayer3D") var picked_audio_path := NodePath("PickupAudio")
@onready var picked_audio : AudioStreamPlayer3D = get_node(picked_audio_path)
@export_node_path("AudioStreamPlayer3D") var drop_audio_path := NodePath("DropAudio")
@onready var drop_audio : AudioStreamPlayer3D = get_node(drop_audio_path)
@export_node_path("AudioStreamPlayer3D") var hotbar_change_audio_path := NodePath("HotbarChangeAudio")
@onready var hotbar_change_audio : AudioStreamPlayer3D = get_node(hotbar_change_audio_path)
@export_node_path("AudioStreamPlayer3D") var player_inventory_open_audio_path := NodePath("PlayerInventoryOpenAudio")
@onready var player_inventory_open_audio : AudioStreamPlayer3D = get_node(player_inventory_open_audio_path)
@export_node_path("AudioStreamPlayer3D") var player_inventory_close_audio_path := NodePath("PlayerInventoryCloseAudio")
@onready var player_inventory_close_audio : AudioStreamPlayer3D = get_node(player_inventory_close_audio_path)


func _ready():
	# Setup for audios ðŸ”Š
	character_inventory_system.picked.connect(_on_inventory_handler_picked)
	character_inventory_system.opened_inventory.connect(_on_player_inventory_opened)
	character_inventory_system.closed_inventory.connect(_on_player_inventory_closed)
	#character_inventory_system.hotbar.on_change_selection.connect(_on_hotbar_changed)


func _on_inventory_handler_picked(_dropped_item):
	picked_audio.play()


func _on_player_inventory_opened(_inventory : Inventory):
	player_inventory_open_audio.play()


func _on_player_inventory_closed(_inventory : Inventory):
	player_inventory_close_audio.play()


func _on_hotbar_changed(_selection : int):
	hotbar_change_audio.play()


func _physics_process(delta):
	# Add the gravity.
	if not is_on_floor():
		velocity.y -= gravity * delta

	# Handle Jump.
	if Input.is_action_just_pressed("jump_move") and is_on_floor():
		velocity.y = JUMP_VELOCITY

	# Get the input direction and handle the movement/deceleration.
	# As good practice, you should replace UI actions with custom gameplay actions.
	var input_dir = Input.get_vector("left_move", "right_move", "forward_move", "back_move")
	var direction = (transform.basis * Vector3(input_dir.x, 0, input_dir.y)).normalized()
	if direction and Input.get_mouse_mode() == Input.MOUSE_MODE_CAPTURED:
		velocity.x = direction.x * SPEED
		velocity.z = direction.z * SPEED
	else:
		velocity.x = move_toward(velocity.x, 0, SPEED)
		velocity.z = move_toward(velocity.z, 0, SPEED)

	move_and_slide()


func _input(event: InputEvent) -> void:
	# Mouse look (only if the mouse is captured).
	if event is InputEventMouseMotion and Input.get_mouse_mode() == Input.MOUSE_MODE_CAPTURED:
		rotate_camera(event.relative)


func rotate_camera(mouse_axis : Vector2) -> void:
	# Horizontal mouse look.
	rot.y -= mouse_axis.x * mouse_sensitivity
	# Vertical mouse look.
	rot.x = clamp(rot.x - mouse_axis.y * mouse_sensitivity, -vertical_angle_limit, vertical_angle_limit)

	rotation.y = rot.y
	$Camera3D.rotation.x = rot.x
</file>

<file path="godot-coop/addons/inventory-system-demos/fps/props/shelf.gd">
class_name Shelf
extends BoxInventory

@onready var visual_inventory_3d : VisualInventory = $VisualInventory3D


var slot_index : int = -1
var actions_shelf : Array

func _on_open():
	pass


func _on_close():
	pass


func get_interaction_position(interaction_point : Vector3) -> Vector3:
	var near_distance : float = 2500
	var near_position : Vector3 = global_position
	slot_index = -1
	for i in visual_inventory_3d.visual_slots.size():
		var visual_slot = visual_inventory_3d.visual_slots[i]
		var p = interaction_point.distance_squared_to(visual_slot.global_position)
		if p < near_distance:
			near_distance = p
			near_position = visual_slot.global_position
			slot_index = i
	return near_position

func interact_with_slot(character : Node, action_index : int = 0, actual_slot_index := 0):
	if openable.is_open:
		return
	var interactor = character.character_inventory_system.interactor
	var item_id = interactor.hotbar.get_selected_item()
	var definition = interactor.hotbar.database.get_item(item_id)
	var char_inventory = character.character_inventory_system.main_inventory
	var char_slot_index = interactor.hotbar.selection_index
	if action_index == 0:
		super.interact(character, action_index)
	if action_index == 1:
		var shelf_item_id = get_actual_item(actual_slot_index)
		var shelf_item_definition = interactor.hotbar.database.get_item(shelf_item_id)
		if shelf_item_definition != null:
			inventory.transfer_at(actual_slot_index, char_inventory, char_slot_index)
		return
	if action_index == 2:
		if definition != null:
			char_inventory.transfer_at(char_slot_index, inventory, actual_slot_index)
		return

func interact(character : Node, action_index : int = 0):
	interact_with_slot(character, action_index, slot_index)


func get_actual_item(actual_stack_index):
	if actual_stack_index != -1:
		return inventory.stacks[actual_stack_index].item_id
	return null


func get_interact_actions(interactor : Interactor) -> Array:
	actions_shelf.clear()
	if openable.is_open:
		return actions_shelf
	actions_shelf.append_array(actions)
	var shelf_item_id = get_actual_item(slot_index)
	var shelf_definition = inventory.database.get_item(shelf_item_id)
	if shelf_item_id != null and shelf_definition != null:
		var action = InteractAction.new()
		action.description = "Get " + shelf_definition.name
		action.input = "item_pickup"
		action.code = 1
		actions_shelf.append(action)
	var item_id : String = interactor.hotbar.get_selected_item()
	var definition = inventory.database.get_item(item_id)
	if item_id != "" and definition != null and (shelf_definition == null or shelf_definition == definition):
		var action = InteractAction.new()
		action.description = "Place " + definition.name
		action.input = "item_place"
		action.code = 2
		actions_shelf.append(action)
	return actions_shelf
</file>

<file path="godot-coop/addons/inventory-system-demos/fps/props/visual_inventory_3d.gd">
class_name VisualInventory
extends Node3D

@export var visual_slots_paths : Array[NodePath]
@export var visual_slots : Array[VisualSlot3D]
@export var property_name_of_visual = "visual_3d"
@onready var inventory = $"../Inventory"


func _ready():
	for path in visual_slots_paths:
		var visual_slot : VisualSlot3D = get_node(path)
		visual_slots.append(visual_slot)
	for i in visual_slots.size():
		var visual_slot = visual_slots[i]
		visual_slot.setup(inventory, i, property_name_of_visual)
</file>

<file path="godot-coop/addons/inventory-system-demos/fps/props/visual_slot_3d.gd">
class_name VisualSlot3D
extends Node3D

@export_node_path("Node3D") var default_hand_item_object_path = NodePath("DefaultItem3D")
@onready var default_hand_item_object := get_node(default_hand_item_object_path)
@export var distance_for_stack : float = 0.05

var property_name_of_visual : String
var last_item_id : String = ""
var inventory : Inventory
#var objects_per_id : Dictionary
var slot_index : int
var objects : Array


func setup(inv : Inventory, new_slot_index : int, property := "visual_3d"):
	self.property_name_of_visual = property
	self.inventory = inv
	self.inventory.updated_stack.connect(_on_updated_slot)
	self.slot_index = new_slot_index
	_on_updated_slot(slot_index)
#	objects_per_id = {}


func _on_updated_slot(changed_slot_index : int):
	if self.slot_index != changed_slot_index:
		return
	if changed_slot_index >= inventory.stacks.size():
		return
	_clear_last_visual()
	var item_id = inventory.items[slot_index].item_id
	var amount = inventory.items[slot_index].amount
	var definition = inventory.database.get_item(item_id)
	if item_id == "" or definition == null:
		return
	var item_scene = null
	if definition.properties.has(property_name_of_visual):
		var path = definition.properties[property_name_of_visual]
		item_scene = load(path)
	last_item_id = item_id

	if item_scene == null:
#		default_hand_item_object.visible = true
		return
#	if objects_per_id.has(item):
#		objects_per_id[item].visible = true
#	else:
	for i in amount:
		var item_obj = item_scene.instantiate()
		add_child(item_obj)
		item_obj.position.y = i * distance_for_stack
		objects.append(item_obj)
#		objects_per_id[item] = item_obj


func _clear_last_visual():
#	default_hand_item_object.visible = false
#	if last_item == null:
#		return
	for i in objects:
		i.queue_free()
	objects.clear()
#	if objects_per_id.has(last_item):
#		objects_per_id[last_item].visible = false
</file>

<file path="godot-coop/addons/inventory-system-demos/fps/tool_hand_item_3d.gd">
class_name ToolHandItem3D
extends HandItem3D

const Interactor = preload("../interaction_system/inventory_interactor.gd")


@export var use_action : InteractAction


func get_interact_actions(_interactor : Interactor) -> Array:
	return [use_action]


func interact(character : Node, _action_code : int = 0):
	character.get_node("UseItemsExample").use_item_selected_in_hotbar()
</file>

<file path="godot-coop/addons/inventory-system-demos/fps/use_items_example.gd">
class_name UseItemsExample3D
extends Node3D

@export var hotbar : Hotbar

func use_item_selected_in_hotbar():
	var stack : ItemStack = hotbar.get_stack_on_selection()
	if stack == null:
		return
	var stack_index = hotbar.get_inventory().stacks.find(stack)
	if stack_index == -1:
		return
	var definition = hotbar.database.get_item(stack.item_id)
	if definition != null:
		if stack.properties.has("durability"):
			stack.properties["durability"] = stack.properties["durability"] - 2.0
			if stack.properties["durability"] <= 0.0:
				hotbar.get_inventory().remove_at(stack_index, stack.item_id)
			else:
				hotbar.get_inventory().update_stack(stack_index)
			print(stack.properties["durability"])
</file>

<file path="godot-coop/addons/inventory-system-demos/fps/workbench.gd">
class_name Workbench
extends Node3D

const Interactor = preload("../interaction_system/inventory_interactor.gd")


@export var actions : Array
@onready var craft_station : CraftStation = $CraftStation
@onready var openable : Openable = $Openable
@onready var input_inventory: GridInventory = $InputInventory

var character


func get_interaction_position(_interaction_point : Vector3) -> Vector3:
	return position


func get_interact_actions(_interactor : Interactor) -> Array:
	if openable.is_open:
		return []
	return actions


func interact(_character : Node, action_index : int = 0):
	#craft_station.load_valid_recipes()
	if action_index == 0 and !openable.is_open:
		open(_character)
		_character.character_inventory_system.open_station(craft_station)
	else:
		self.rotate(Vector3.UP, 90)

func open(_character : Node):
	openable.open(_character)

func close(_character : Node):
	openable.close(_character)
</file>

<file path="godot-coop/addons/inventory-system-demos/interaction_system/interact_action.gd">
class_name InteractAction
extends Resource

@export var input : String = "interact"
@export var description : String = "to Interact"
@export var code : int = 0
</file>

<file path="godot-coop/addons/inventory-system-demos/interaction_system/inventory_interactor.gd">
@tool
@icon("res://addons/inventory-system/icons/interactor.svg")
extends NodeInventories

signal preview_interacted(actions : Array, position_screen : Vector2)
signal interacted(object : Node)

@export var node_base_to_interactions := NodePath(".");
@export var raycast : RayCast3D
@export var camera : Node

var last_interact_object : Node
var actual_hand_object : Node


## ðŸ«´ Interact System
func try_interact():
	var object = raycast.get_collider()
	last_interact_object = object
	var pos : Vector2 = Vector2.ZERO
	if object != null and object.has_method("get_interaction_position") and camera != null:
		pos = camera.unproject_position(object.get_interaction_position(raycast.get_collision_point()))

	var node = object as Node

	var total_actions : Array = []

	var object_actions : Array = []
	var hand_actions = get_actions(actual_hand_object)

	if raycast.is_colliding():
		object_actions = get_actions(node)

	total_actions.append_array(object_actions)
	total_actions.append_array(hand_actions)

	preview_interacted.emit(total_actions, pos)

	interact_object(object, object_actions)
	interact_hand_item(actual_hand_object, hand_actions)


func get_actions(node : Node) -> Array:
	var actions : Array = []
	if node != null and node.has_method("get_interact_actions"):
		actions = node.get_interact_actions(self)
	return actions


func interact_object(object : Node, actions : Array):
	for action in actions:
		if Input.is_action_just_pressed(action.input):
			object.interact(get_node(node_base_to_interactions), action.code)
			interacted.emit(object)
			return


func interact_hand_item(hand_object, hand_actions):
	for action in hand_actions:
		if Input.is_action_just_pressed(action.input):
			hand_object.interact(get_node(node_base_to_interactions), action.code)
			interacted.emit(hand_object)
			return


func set_actual_hand_object(new_actual_hand_object):
	actual_hand_object = new_actual_hand_object
</file>

<file path="godot-coop/addons/inventory-system-demos/mp/dropped_item_spawner.gd">
class_name DropItemSpawner
extends MultiplayerSpawner

## Class that customizes the way the spawner generates objects on the network,
## placing information on the [PackedScene] of the dropped item, position and rotation.

@export var database : InventoryDatabase

func _init():
	spawn_function = _spawn_custom


func _spawn_custom(data : Array):
	if data.size() != 5 and data.size() != 4:
		print("data size error!")
		return null
	if typeof(data[0]) != TYPE_VECTOR3 or typeof(data[1]) != TYPE_VECTOR3 or typeof(data[2]) != TYPE_STRING:
		print("data incompatible!")
		return null

	var obj = load(data[2]).instantiate()
	obj.position = data[0]
	obj.rotation = data[1]
	var item_id : String = obj.item_id
	if data.size() > 3 and typeof(data[3]) == TYPE_INT:
		obj.amount = data[3]
	if data.size() > 4  and typeof(data[4]) == TYPE_DICTIONARY:
		obj.item_properties = data[4]
	obj.item_id = item_id
	return obj
</file>

<file path="godot-coop/addons/inventory-system-demos/mp/lag_test.gd">
extends Node
class_name LagTest

@export var actived := false

func _process(_delta: float) -> void:
	if not actived:
		return
	if multiplayer.is_server():
		for i in 50000000:
			var _a := 2 + 2
</file>

<file path="godot-coop/addons/inventory-system-demos/mp/mp_demo.gd">
extends FPSDemo
class_name MPDemo

@export var player_scene : PackedScene

var connected_peer_ids : Array
var players : Array
var peer : ENetMultiplayerPeer

func _ready():
	multiplayer.peer_connected.connect(_player_connected)
	multiplayer.peer_disconnected.connect(_player_disconnected)


func _process(_delta: float) -> void:
	pass


func create_player(peer_id : int):
	connected_peer_ids.append(peer_id)
	var player = player_scene.instantiate()
	player.name = str(peer_id)
	players.append(player)
	player.position = Vector3(0,2,0)
	add_child(player)
	if multiplayer.get_unique_id() == peer_id:
		$"UI/Inventory System UI".setup(player.get_node("CharacterInventorySystem"))


@rpc
func add_newly_connected_player_character(new_peer_id):
	create_player(new_peer_id)


@rpc
func add_previously_connected_player_characters(peer_ids):
	for peer_id in peer_ids:
		create_player(peer_id)


func host_game():
	peer = ENetMultiplayerPeer.new()
	peer.create_server(4242)
	multiplayer.set_multiplayer_peer(peer)
	create_player(multiplayer.get_unique_id())
	$"UI/Connect Panel".visible = false
	await get_tree().create_timer(1).timeout
	make_scene_objects_to_network()


func make_scene_objects_to_network():
	var items = $Level/Items
	var spawner = get_node("DroppedItemSpawner")
	for i in items.get_child_count():
		var item_dropped = items.get_child(i) as DroppedItem3D
		var item_id : String = item_dropped.item_id
		var definition = database.get_item(item_id)
		var position = item_dropped.position
		var rotation = item_dropped.rotation
		var amount = item_dropped.amount
		item_dropped.queue_free()
		var dropped_item_path = definition.properties["dropped_item"]
		var _obj = spawner.spawn([position, rotation, dropped_item_path, amount])


func connect_to_ip(ip):
	peer = ENetMultiplayerPeer.new()
	peer.create_client(ip, 4242)
	multiplayer.set_multiplayer_peer(peer)
	$"UI/Connect Panel".visible = false
	var items = $Level/Items
	for i in items.get_child_count():
		var item = items.get_child(i) as DroppedItem3D
		item.queue_free()


func _player_connected(new_peer_id : int):
	if multiplayer.is_server():
		add_newly_connected_player_character.rpc(new_peer_id)
		add_previously_connected_player_characters.rpc_id(new_peer_id, connected_peer_ids)
		create_player(new_peer_id)


func _player_disconnected(peer_id : int):
	var pos = connected_peer_ids.find(peer_id)
	if pos > 0 and pos < connected_peer_ids.size():
		connected_peer_ids.remove_at(pos)
		var player = players[pos]
		players.remove_at(pos)
		player.queue_free()


func _on_host_button_button_down():
	host_game()


func _on_connect_button_button_down():
	connect_to_ip("localhost")
</file>

<file path="godot-coop/addons/inventory-system-demos/mp/mp_player.gd">
extends Player
class_name MPPlayer

func _enter_tree():
	set_multiplayer_authority(str(name).to_int())
	$CharacterInventorySystem/Inventory/SyncInventory.set_multiplayer_authority(1)
	$CharacterInventorySystem/EquipmentInventory/SyncInventory.set_multiplayer_authority(1)
	%SyncHotbar.set_multiplayer_authority(1)
	$CharacterInventorySystem/CraftStation/SyncCraftStation.set_multiplayer_authority(1)
	$Dropper.set_multiplayer_authority(1)


func _ready():
	super._ready()
	if is_multiplayer_authority():
		$Camera3D.make_current()
	else:
		$Camera3D.clear_current()
	$Camera3D/HandItem.visible = is_multiplayer_authority()
	$Camera3D/ThirdPersonHandItem.visible = not is_multiplayer_authority()
	if is_multiplayer_authority():
		$Mesh.visible = false


func _physics_process(delta):
	if is_multiplayer_authority():
		super._physics_process(delta)


func _input(event: InputEvent) -> void:
	if is_multiplayer_authority():
		super._input(event)
</file>

<file path="godot-coop/addons/inventory-system-demos/mp/networked_box_inventory.gd">
extends BoxInventory
class_name NetworkedBoxInventory

func interact(character : Node, _action_index : int = 0):
	if multiplayer.is_server():
		interact_rpc(character.get_path(), _action_index)
	else:
		interact_rpc.rpc_id(1, character.get_path(), _action_index)

@rpc("any_peer")
func interact_rpc(character_path : NodePath, _action_index : int = 0):
	super.interact(get_node(character_path), _action_index)
</file>

<file path="godot-coop/addons/inventory-system-demos/mp/networked_campfire.gd">
extends Campfire
class_name NetworkedCampfire

func _ready():
	super._ready()
	changed_burning_state.connect(_changed_burning_state)
	multiplayer.peer_connected.connect(_on_connected)


func check():
	if not multiplayer.is_server():
		return
	super.check()


func _on_connected(_id : int):
	_changed_burning_state(is_burning)


func _changed_burning_state(is_burning_now : bool):
	if not multiplayer.is_server():
		return
	_changed_burning_state_rpc.rpc(is_burning_now)


@rpc
func _changed_burning_state_rpc(is_burning_now : bool):
	if multiplayer.is_server():
		return
	self.is_burning = is_burning_now


@warning_ignore("shadowed_variable_base_class")
func interact(character : Node, _action_index : int = 0):
	if multiplayer.is_server():
		interact_rpc(character.get_path(), _action_index)
	else:
		interact_rpc.rpc_id(1, character.get_path(), _action_index)

@rpc("any_peer")
func interact_rpc(character_path : NodePath, _action_index : int = 0):
	super.interact(get_node(character_path), _action_index)
</file>

<file path="godot-coop/addons/inventory-system-demos/mp/networked_dropper.gd">
extends Dropper


@export_node_path var drop_item_spawner_path := NodePath("../../DroppedItemSpawner")
@onready var drop_item_spawner = get_node(drop_item_spawner_path)


func _ready():
	if is_multiplayer_authority():
		super._ready()


func _on_request_drop_obj(dropped_item : String, _item_id : String, amount : int, properties : Dictionary):
	if(drop_item_spawner == null):
		printerr("Spawner is null!")
		return
	var packed_scene : PackedScene = load(dropped_item)
	var data : Array
	data.append(global_position)
	data.append(global_rotation)
	data.append(packed_scene.resource_path)
	data.append(amount)
	data.append(properties)
	var obj = drop_item_spawner.spawn(data)
	dropped.emit(obj)
</file>

<file path="godot-coop/addons/inventory-system-demos/mp/networked_object_placer.gd">
extends "../character/object_placer.gd"
class_name NetworkedObjectPlacer


@export_node_path var spawner_path : NodePath = NodePath("../../../../PlaceableItemSpawner")
@onready var spawner : PlaceableItemSpawner = get_node(spawner_path)


func place_item(item_id : String, position : Vector3, rotation : Vector3):
	if item_id.is_empty():
		return
	if not multiplayer.is_server():
		place_item_rpc.rpc_id(1, item_id, position, rotation)
	else:
		place_item_rpc(item_id, position, rotation)
	return


@rpc("any_peer")
func place_item_rpc(item_id : String, position : Vector3, rotation : Vector3):
	if not multiplayer.is_server():
		return
	super.place_item(item_id, position, rotation)


func _instantiate_object(dropped_item : PackedScene, position : Vector3, rotation : Vector3):
	var obj = spawner.spawn([position, rotation, dropped_item.resource_path])
#	dropped.emit(obj)
</file>

<file path="godot-coop/addons/inventory-system-demos/mp/networked_shelf.gd">
extends Shelf
class_name NetworkedShelf


func interact(character : Node, action_index : int = 0):
	if not multiplayer.is_server():
		interact_rpc.rpc_id(1, character.get_path(), action_index, slot_index)
	else:
		interact_rpc(character.get_path(), action_index, slot_index)

@rpc("any_peer")
@warning_ignore("shadowed_variable_base_class")
func interact_rpc(character_node_path : NodePath, action_index : int, slot_index):
	if not multiplayer.is_server():
		return
	var node = get_node(character_node_path)
	if node == null:
		return
	super.interact_with_slot(node, action_index, slot_index)
</file>

<file path="godot-coop/addons/inventory-system-demos/mp/networked_use_items_example_3d.gd">
class_name NetworkedUseItemsExample3D
extends UseItemsExample3D


func use_item_selected_in_hotbar():
	if not multiplayer.is_server():
		use_item_selected_in_hotbar_rpc.rpc_id(1)
	else:
		use_item_selected_in_hotbar_rpc()


@rpc
func use_item_selected_in_hotbar_rpc():
	if not multiplayer.is_server():
		return
	super.use_item_selected_in_hotbar()
</file>

<file path="godot-coop/addons/inventory-system-demos/mp/networked_workbench.gd">
extends Workbench


@warning_ignore("shadowed_variable_base_class")
func interact(character : Node, _action_index : int = 0):
	if multiplayer.is_server():
		interact_rpc(character.get_path(), _action_index)
	else:
		interact_rpc.rpc_id(1, character.get_path(), _action_index)

@rpc("any_peer")
func interact_rpc(character_path : NodePath, _action_index : int = 0):
	super.interact(get_node(character_path), _action_index)
</file>

<file path="godot-coop/addons/inventory-system-demos/mp/placeable_item_spawner.gd">
class_name PlaceableItemSpawner
extends MultiplayerSpawner

## Class that customizes the way the spawner generates objects on the network,
## placing information on the [PackedScene] of the dropped item, position and rotation.

func _init():
	spawn_function = _spawn_custom


func _spawn_custom(data : Array):
	if data.size() != 3:
		print("data size error!")
		return null
	if typeof(data[0]) != TYPE_VECTOR3 or typeof(data[1]) != TYPE_VECTOR3 or typeof(data[2]) != TYPE_STRING:
		print("data incompatible!")
		return null

	var obj = load(data[2]).instantiate()
	obj.position = data[0]
	obj.rotation = data[1]
	return obj
</file>

<file path="godot-coop/addons/inventory-system-demos/mp/sync_craft_station.gd">
extends Node
class_name SyncCraftStation

@export var craft_station : CraftStation
@export var sync_input_inventories : bool
var craftings_data : Array


func _ready() -> void:
	craft_station.can_finish_craftings = is_multiplayer_authority()
	multiplayer.peer_connected.connect(_on_connected)
	craft_station.crafting_added.connect(_on_crafting_added)
	craft_station.crafting_removed.connect(_on_crafting_removed)
	if sync_input_inventories:
		craft_station.input_inventory_added.connect(_on_input_inventory_added)
		craft_station.input_inventory_removed.connect(_on_input_inventory_removed)


func _on_connected(peer_id : int):
	craft_station.can_finish_craftings = is_multiplayer_authority()
	if not multiplayer.is_server():
		return
	_update_craftings_rpc.rpc_id(peer_id, craftings_data)


func _on_crafting_added(crafting_index : int):
	if not multiplayer.is_server():
		return
	var crafting = craft_station.craftings[crafting_index]
	crafting_added_rpc.rpc(crafting.recipe_index)
	craftings_data.append(crafting.serialize())



func _on_crafting_removed(crafting_index : int):
	if not multiplayer.is_server():
		return
	crafting_removed_rpc.rpc(crafting_index)
	craftings_data.remove_at(crafting_index)


func _on_input_inventory_added(inventory_path : NodePath):
	if not multiplayer.is_server():
		return
	input_inventory_added_rpc.rpc(inventory_path)


func _on_input_inventory_removed(inventory_path : NodePath):
	if not multiplayer.is_server():
		return
	input_inventory_removed_rpc.rpc(inventory_path)


@rpc
func crafting_added_rpc(recipe_index : int):
	if multiplayer.is_server():
		return
	var recipe = craft_station.database.recipes[recipe_index]
	craft_station.add_crafting(recipe_index, recipe)

@rpc
func crafting_removed_rpc(crafting_index : int):
	if multiplayer.is_server():
		return
	craft_station.remove_crafting(crafting_index)

@rpc
@warning_ignore("shadowed_variable")
func _update_craftings_rpc(craftings_data : Array):
	craft_station.can_finish_craftings = is_multiplayer_authority()
	for data in craftings_data:
		var crafting = Crafting.new()
		crafting.deserialize(data)
		craft_station.craftings.append(crafting)

@rpc
func input_inventory_added_rpc(inventory_path : NodePath):
	craft_station.add_input_inventory(craft_station.get_node(inventory_path))

@rpc
func input_inventory_removed_rpc(inventory_path : NodePath):
	craft_station.remove_input_inventory(craft_station.get_node(inventory_path))
</file>

<file path="godot-coop/addons/inventory-system-demos/mp/sync_grid_inventory.gd">
class_name SyncGridInventory
extends Node

#@export var sync_item_added_signal := true
#@export var sync_item_removed_signal := true
@export var sync_when_content_update_only := false

@export var inventory : GridInventory

## Networked version of inventory where server sends rpcs to client for
## slot update, add and remove signals
##
## Why not use [MultiplayerSyncronizer]?
## The idea of using rpc signals only when changed saves a lot of bandwidth,
## but at the cost of being sure which signals will be called, ie calling
## slot[i] = new Dictionary is not replicated across the network.
## Also keep in mind that signals need to be handled if switching to a use of
## MultiplayerSyncronizer
##
## Note: Slot categories are not synced

func _ready():
	if Engine.is_editor_hint():
		return
	multiplayer.peer_connected.connect(_on_connected)
	if(inventory != null):
		setup()


func setup():
	if sync_when_content_update_only:
		inventory.contents_changed.connect(_on_contents_changed)
	else:
		inventory.stack_added.connect(_on_stack_added)
		inventory.updated_stack.connect(_on_updated_stack)
		inventory.stack_removed.connect(_on_stack_removed)



func _on_contents_changed():
	if not multiplayer.is_server():
		return
	var inv_data = inventory.serialize()
	_update_inventory_rpc.rpc(inv_data)


func _on_connected(id):
	if not multiplayer.is_server():
		return
	var inv_data = inventory.serialize()
	_update_inventory_rpc.rpc_id(id, inv_data)


func _on_stack_added(stack_index : int):
	if not multiplayer.is_server():
		return

	var item_id = inventory.stacks[stack_index].item_id
	var amount = inventory.stacks[stack_index].amount
	var properties = inventory.stacks[stack_index].properties
	var position = inventory.stack_positions[stack_index]
	var rotation = inventory.stack_rotations[stack_index]
	_stack_added_rpc.rpc(stack_index, item_id, amount, properties, position, rotation)


func _on_updated_stack(stack_index : int):
	if not multiplayer.is_server():
		return
	_updated_slot_rpc.rpc(stack_index, inventory.stacks[stack_index].serialize())


func _on_stack_removed(stack_index : int):
	if not multiplayer.is_server():
		return

	_stack_removed_rpc.rpc(stack_index)


@rpc
func _update_inventory_rpc(inv_data : Dictionary):
	if not multiplayer.is_server():
		inventory.deserialize(inv_data)
		inventory.contents_changed.emit()


@rpc
func _stack_added_rpc(_stack_index: int, item_id: String, amount: int, properties: Dictionary, position: Vector2i, rotation: bool):
	if multiplayer.is_server():
		return
	inventory.add_at_position(position, item_id, amount, properties, rotation)


@rpc
func _updated_slot_rpc(stack_index : int, slot_data : Array):
	if multiplayer.is_server():
		return
	var stack : ItemStack = inventory.stacks[stack_index]
	stack.deserialize(slot_data)
	inventory.updated_stack.emit(stack_index)

@rpc
func _stack_removed_rpc(stack_index : int):
	if multiplayer.is_server():
		return
	inventory.remove_stack(stack_index)
</file>

<file path="godot-coop/addons/inventory-system-demos/mp/sync_hotbar.gd">
extends Node
class_name	SyncHotbar

@export var hotbar : Hotbar

func _ready() -> void:
	multiplayer.peer_connected.connect(_on_connected)
	hotbar.equipped.connect(_on_equipped_stack_changed)
	hotbar.unequipped.connect(_on_unequipped_stack_changed)
	hotbar.on_change_selection.connect(_on_change_selection)



func _on_equipped_stack_changed(slot_index: int):
	if not multiplayer.is_server():
		return
	var stack = hotbar.get_stack_on_slot(slot_index)
	var stack_index = hotbar.get_inventory().stacks.find(stack)
	equipped_stack_changed_rpc.rpc(stack_index, slot_index)


func _on_unequipped_stack_changed(slot_index: int):
	if not multiplayer.is_server():
		return
	unequipped_stack_changed_rpc.rpc(slot_index)


func _on_connected(peer_id : int):
	if not multiplayer.is_server():
		return
	change_selection_rpc.rpc_id(peer_id, hotbar.selection_index)
	for i in hotbar.max_slots:
		var stack = hotbar.get_stack_on_slot(i)
		if stack == null:
			continue
		var stack_index = hotbar.get_inventory().stacks.find(stack)
		equipped_stack_changed_rpc.rpc_id(peer_id,stack_index, i)


func _on_change_selection(selection_index : int):
	if not multiplayer.is_server():
		return
	change_selection_rpc.rpc(selection_index)


@rpc
func equipped_stack_changed_rpc(stack_index : int, slot_index: int):
	var stack: ItemStack = null
	if stack_index >= 0 and stack_index < hotbar.get_inventory().stacks.size():
		stack = hotbar.get_inventory().stacks[stack_index]
	hotbar.equip(stack, slot_index)


@rpc
func unequipped_stack_changed_rpc(slot_index: int):
	hotbar.unequip(slot_index)


@rpc
func change_selection_rpc(selection_index: int):
	hotbar.selection_index = selection_index
</file>

<file path="godot-coop/addons/inventory-system-demos/ui/craft/craft_station_ui.gd">
class_name CraftStationUI
extends Control

## Represents a [CraftStation] in the interface.
## It uses instanced scenes from [RecipeUI] to represent every possible station recipe.
## Use the [CraftingsUI] to represent each active crafting in the station.

signal on_craft(craft_station : CraftStation, recipe_index : int)

## It uses instanced scenes from [RecipeUI] to represent every possible station recipe.
@export var recipe_ui_scene : PackedScene

## [InventoryUI] which represents the input inventory.
@onready var input_inventory_ui : GridInventoryUI = %InputGridInventoryUI

## [InventoryUI] which represents the output inventory.
@onready var output_inventory_ui : GridInventoryUI = %OutputGridInventoryUI

## Show input inventory when open [CraftStationUI].
@export var view_input_inventory := true

## Show output inventory when open [CraftStationUI].
@export var view_output_inventory := true

@onready var _recipes_container : VBoxContainer = %RecipesContent
@onready var _craftings_ui : CraftingsUI = %CraftingsUI

var craft_station : CraftStation

var _recipe_uis : Array[RecipeUI]


## Configure a craftstation for the [Recipe] list and [CraftingsUI] list
func open(_craft_station : CraftStation):
	
	if(self.craft_station != null):
		for i in self.craft_station.input_inventories.size():
			if self.craft_station.get_input_inventory(i).contents_changed.is_connected(_on_input_inventory_contents_changed):
				self.craft_station.get_input_inventory(i).contents_changed.disconnect(_on_input_inventory_contents_changed)
	
	self.craft_station = _craft_station
	_clear()
	_craftings_ui.set_craft_station(craft_station)
	var recipes = craft_station.database.recipes
	for i in craft_station.valid_recipes.size():
		var recipe_index = craft_station.valid_recipes[i]
		var recipe = craft_station.database.recipes[recipe_index]
		var recipe_ui : RecipeUI = recipe_ui_scene.instantiate()
		_recipe_uis.append(recipe_ui)
		_recipes_container.add_child(recipe_ui)
		recipe_ui.set_recipe(craft_station, recipe, recipe_index)
		recipe_ui.craft_button.button_down.connect(_on_craft_button_button_down.bind(craft_station, recipe_index))
	visible = true
	var valid_input = view_input_inventory and craft_station.input_inventories.size() > 0 and craft_station.input_inventories[0] != null
	var valid_output = view_output_inventory and craft_station.output_inventories.size() > 0 and craft_station.output_inventories[0] != null
	if valid_input: 
		input_inventory_ui.inventory = craft_station.get_input_inventory(0)
	if valid_output: 
		input_inventory_ui.inventory = craft_station.get_input_inventory(0)
	input_inventory_ui.visible = valid_input
	output_inventory_ui.visible = valid_output
	
	for i in craft_station.input_inventories.size():
		craft_station.get_input_inventory(i).contents_changed.connect(_on_input_inventory_contents_changed)


func _on_input_inventory_contents_changed():
	for recipe_ui in _recipe_uis:
		recipe_ui.check_if_has_ingredients()


## Hidden this UI
func close():
	visible = false


func _clear():
	for recipe_ui in _recipe_uis:
		recipe_ui.queue_free()
	_recipe_uis.clear()


func _on_craft_button_button_down(_craft_station : CraftStation, _recipe_index : int):
	on_craft.emit(_craft_station, _recipe_index)
</file>

<file path="godot-coop/addons/inventory-system-demos/ui/craft/crafting_ui.gd">
class_name CraftingUI
extends Control

## Interface that represents a crafting that is in a craft station list.

## What station is this crafting from
var station : CraftStation

## Crafting information (Time and recipe)
var crafting : Crafting 

@onready var _icon : TextureRect = %Icon
@onready var _progress_bar : ProgressBar = %ProgressBar


## Set crafting based on [CraftStation] crafting index
func set_crafting(_station : CraftStation, crafting_index : int):
	self.station = _station
	crafting = station.craftings[crafting_index]
	var recipe_index = crafting.recipe_index
	var recipe = station.database.recipes[recipe_index]
	var definition = station.database.get_item(recipe.products[0].item_id)
	_icon.texture = definition.icon
	_progress_bar.max_value = recipe.time_to_craft


func _process(_delta : float):
	_progress_bar.value =  _progress_bar.max_value - crafting.time
</file>

<file path="godot-coop/addons/inventory-system-demos/ui/craft/craftings_ui.gd">
class_name CraftingsUI
extends VBoxContainer

## Represents the active craftings of [CraftStation] with a user interface.

## Scene to be instantiated that represents a crafting from the [CraftStation]'s crafting list
@export var crafting_ui_scene : PackedScene


var _craft_station : CraftStation
var _craftings : Array[CraftingUI]


## Configure crafting list for this interface
func set_craft_station(craft_station : CraftStation):
	_clear()
	if _craft_station != null and _craft_station != craft_station:
		_craft_station.crafting_added.disconnect(_on_add_crafting_at)
		_craft_station.crafting_removed.disconnect(_on_remove_crafting_at)
	if _craft_station != craft_station:
		craft_station.crafting_added.connect(_on_add_crafting_at)
		craft_station.crafting_removed.connect(_on_remove_crafting_at)
	_craft_station = craft_station
	
	for i in craft_station.craftings.size():
		_on_add_crafting_at(i)


func _clear():
	for crafting in _craftings:
		crafting.queue_free()	
	_craftings.clear()


func _on_add_crafting_at(crafting_index : int):
	var crafting_obj = crafting_ui_scene.instantiate()
	add_child(crafting_obj)
	move_child(crafting_obj, 0)
	_craftings.insert(crafting_index, crafting_obj)
	crafting_obj.set_crafting(_craft_station, crafting_index)


func _on_remove_crafting_at(crafting_index : int):
	_craftings[crafting_index].queue_free()
	_craftings.remove_at(crafting_index)
</file>

<file path="godot-coop/addons/inventory-system-demos/ui/craft/ingredient_ui.gd">
class_name IngredientUI
extends Control

## Interface represents Ingredient in [RecipeUI].

@onready var icon : TextureRect = get_node("Icon")
@onready var amount : Label = get_node("Amount")
var database : InventoryDatabase

## Setup ingredient
func setup(_database : InventoryDatabase, item_stack : ItemStack):
	self.database = _database
	var definition = database.get_item(item_stack.item_id)
	self.icon.texture = definition.icon
	self.amount.text = "X "+str(item_stack.amount)
</file>

<file path="godot-coop/addons/inventory-system-demos/ui/drop_area.gd">
extends Control
class_name DropArea

signal request_drop(stack: ItemStack, inventory: Inventory)

@onready var player_grid_inventory_ui: GridInventoryPanel = %PlayerGridInventoryUI


func _can_drop_data(_at_position: Vector2, _data: Variant) -> bool:
	return true


func _drop_data(_at_position: Vector2, data: Variant) -> void:
	request_drop.emit(data.stack, data.inventory)
</file>

<file path="godot-coop/addons/inventory-system-demos/ui/grid/grid_draggable_element_ui.gd">
@tool
extends Panel
class_name GridDraggableElementUI

# Somewhat hacky way to do static signals:
# https://stackoverflow.com/questions/77026156/how-to-write-a-static-event-emitter-in-gdscript/77026952#77026952

static var dragable_grabbed: Signal = (func():
	if (GridDraggableElementUI as Object).has_user_signal("dragable_grabbed"):
		return (GridDraggableElementUI as Object).dragable_grabbed
	(GridDraggableElementUI as Object).add_user_signal("dragable_grabbed")
	return Signal(GridDraggableElementUI, "dragable_grabbed")
).call()

static var dragable_dropped: Signal = (func():
	if (GridDraggableElementUI as Object).has_user_signal("dragable_dropped"):
		return (GridDraggableElementUI as Object).dragable_dropped
	(GridDraggableElementUI as Object).add_user_signal("dragable_dropped")
	return Signal(GridDraggableElementUI, "dragable_dropped")
).call()

signal grabbed(position)
#signal dropped(zone, position)

static var _grabbed_dragable: GridDraggableElementUI = null
static var _grab_offset: Vector2

var _enabled: bool = true


static func get_grabbed_dragable() -> GridDraggableElementUI:
	if !is_instance_valid(_grabbed_dragable):
		return null
	return _grabbed_dragable


static func get_grab_offset() -> Vector2:
	return _grab_offset


static func get_grab_offset_local_to(control: Control) -> Vector2:
	return GridDraggableElementUI.get_grab_offset() / control.get_global_transform().get_scale()


func _get_drag_data(at_position: Vector2):
	if !_enabled:
		return null

	_grabbed_dragable = self
	_grab_offset = at_position * get_global_transform().get_scale()
	dragable_grabbed.emit(_grabbed_dragable, _grab_offset)
	grabbed.emit(_grab_offset)

	var preview = Control.new()
	var sub_preview = create_preview()
	sub_preview.position = -get_grab_offset()
	preview.add_child(sub_preview)
	set_drag_preview(preview)
	return self


func _notification(what: int) -> void:
	if what == NOTIFICATION_DRAG_END:
		_grabbed_dragable = null


func create_preview() -> Control:
	return null


func activate() -> void:
	_enabled = true


func deactivate() -> void:
	_enabled = false


func is_active() -> bool:
	return _enabled


func is_dragged() -> bool:
	return _grabbed_dragable == self
</file>

<file path="godot-coop/addons/inventory-system-demos/ui/grid/grid_drop_zone_ui.gd">
@tool
extends Control
class_name GridDropZoneUI

signal dragable_dropped(dragable, position)


func activate() -> void:
	mouse_filter = Control.MOUSE_FILTER_PASS


func deactivate() -> void:
	mouse_filter = Control.MOUSE_FILTER_IGNORE


func is_active() -> bool:
	return (mouse_filter != Control.MOUSE_FILTER_IGNORE)


func _can_drop_data(_at_position: Vector2, data) -> bool:
	if data == null:
		return false
	return data is GridDraggableElementUI


func _drop_data(at_position: Vector2, data) -> void:
	var local_offset := GridDraggableElementUI.get_grab_offset_local_to(self)
	dragable_dropped.emit(data, at_position - local_offset)
	GridDraggableElementUI.dragable_dropped.emit(data, self, at_position - local_offset)
</file>

<file path="godot-coop/addons/inventory-system-demos/ui/grid/grid_inventory_panel.gd">
extends PanelContainer
class_name GridInventoryPanel


signal request_split(inventory : Inventory, stack_index : int, amount : int)
signal request_transfer_to(origin_inventory: GridInventory, origin_position: Vector2i, inventory: GridInventory, destination_position : Vector2i, amount : int, is_rotated: bool)
signal request_fast_transfer(origin_inventory: GridInventory, origin_position: Vector2i, inventory: GridInventory, amount : int)
#signal request_sort
signal inventory_stack_context_activated(event: InputEvent, inventory : Inventory, stack: ItemStack)

@export var inventory: GridInventory:
	set(new_Inventory):
		inventory = new_Inventory
		if inventory != null:
			if title_label != null:
				title_label.text = inventory.name
			grid_inventory_ui.inventory_path = grid_inventory_ui.get_path_to(inventory)

@export var grid_inventory_ui: GridInventoryUI
@export var title_label: Label
#@onready var sort_button: Button = %SortButton


func _ready() -> void:
	#sort_button.pressed.connect(func():
		#request_sort.emit(inventory)
	#)
	grid_inventory_ui.request_split.connect(func(_inventory: GridInventory, stack_index: int, amount : int):
		request_split.emit(_inventory, stack_index, amount)
	)
	grid_inventory_ui.request_transfer_to.connect(func(origin_inventory: GridInventory, origin_position: Vector2i, destination_inventory : GridInventory, destination_position: Vector2i, amount: int, is_rotated: bool):
		request_transfer_to.emit(origin_inventory, origin_position, destination_inventory, destination_position, amount, is_rotated)
	)
	grid_inventory_ui.request_fast_transfer.connect(func(origin_inventory: GridInventory, origin_position: Vector2i, amount: int):
		request_fast_transfer.emit(origin_inventory, origin_position, amount)
	)
	grid_inventory_ui.inventory_stack_context_activated.connect(func(event: InputEvent,  _inventory: Inventory, stack: ItemStack):
		inventory_stack_context_activated.emit(event, _inventory, stack)
	)

# TODO Console mode (Code from old inventory_ui
#for stack_index in ui_stacks.size():
		#var ui_stack = ui_stacks[stack_index]
		#for neighbor in ["left", "top", "right", "bottom"]:
			#var neighbor_idx: int
			#match neighbor:
				#"left":
					#neighbor_idx = stack_index - 1
					#if stack_index % slots_container.columns == 0:
						#neighbor_idx = -1
				#"top":
					#neighbor_idx = stack_index - slots_container.columns
				#"right":
					#neighbor_idx = stack_index + 1
					#if (stack_index + 1) % slots_container.columns == 0:
						#neighbor_idx = -1
				#"bottom":
					#neighbor_idx = stack_index + slots_container.columns
			#if neighbor_idx >= 0 and neighbor_idx < ui_stacks.size():
				#ui_stack.set("focus_neighbor_"+neighbor, ui_stacks[neighbor_idx].get_path())
</file>

<file path="godot-coop/addons/inventory-system-demos/ui/grid/grid_inventory_ui.gd">
extends Control
class_name GridInventoryUI

#region Signals

## Emitted when a grabbed [ItemStack] is dropped.
signal item_dropped(item: ItemStack, offset)
## Emitted when the selection has changed. Use [method get_selected_inventory_item]
## to obtain the currently selected item.
signal selection_changed
## Emitted when an [InventoryItem] is activated (i.e. double clicked).
signal inventory_item_activated(item)
## Emitted when the context menu of an [ItemStack] is activated
## (i.e. right clicked).
signal inventory_stack_context_activated(event: InputEvent,  inventory: Inventory, item: ItemStack)
## Emitted when the mouse enters the [Rect2] area of the control representing
## the given [InventoryItem].
signal item_mouse_entered(item)
## Emitted when the mouse leaves the [Rect2] area of the control representing
## the given [InventoryItem].
signal item_mouse_exited(item)

signal request_split(inventory : Inventory, stack_index : int, amount : int)
signal request_transfer_to(origin_inventory: GridInventory, origin_position: Vector2i, inventory: GridInventory, destination_position: Vector2i, amount: int, is_rotated: bool)
signal request_fast_transfer(origin_inventory: GridInventory, origin_position: Vector2i, amount: int)

#endregion

enum SelectMode {SELECT_SINGLE = 0, SELECT_MULTI = 1}

#region Variables
@export var grid_slot_ui_scene: PackedScene
@export var grid_item_stack_ui_scene: PackedScene

## Path to an [Inventory] node.
@export var inventory_path: NodePath:
	set(new_inv_path):
		if new_inv_path == inventory_path:
			return
		inventory_path = new_inv_path
		var node: Node = get_node_or_null(inventory_path)

		if node == null:
			return

		if is_inside_tree():
			assert(node is GridInventory)
			
		inventory = node
		update_configuration_warnings()

## The size of each inventory gird slot in pixels.
@export var grid_slot_size: Vector2 = Vector2(32, 32)

## The spacing between items in pixels.
@export var item_spacing: int = 0

## Single or multi select mode (hold CTRL to select multiple items).
@export_enum("Single", "Multi") var select_mode: int = SelectMode.SELECT_SINGLE:
	set(new_select_mode):
		if select_mode == new_select_mode:
			return
		select_mode = new_select_mode
		_clear_selection()


@export_group("Custom Styles")
## Style of a rectangle that will be drawn on top of the selected item.
@export var selection_style: StyleBox:
	set(new_selection_style):
		selection_style = new_selection_style
		_queue_refresh()


## The [Inventory] node linked to this control.
var inventory: GridInventory = null:
	set(new_inventory):
		
		if inventory == new_inventory:
			return
		
		_clear_selection()
		_disconnect_inventory_signals()
		inventory = new_inventory
		_connect_inventory_signals()

		_queue_refresh()
		_update_stacks()

var _grid_inventory_content_ui: Control = null
var _grid_slots_container: Control = null
var _grid_slots: Array = []
var _refresh_queued: bool = false
var _stack_uis: Array = []
var _selected_stacks: Array[GridItemStackUI] = []
var _ctrl_item_container: Control = null
var _grid_drop_zone_ui: GridDropZoneUI = null
#endregion


#region Default Functions
func _ready() -> void:
	if Engine.is_editor_hint():
		# Clean up, in case it is duplicated in the editor
		if is_instance_valid(_grid_inventory_content_ui):
			_grid_inventory_content_ui.queue_free()
			_grid_slots_container.queue_free()

	if has_node(inventory_path):
		inventory = get_node_or_null(inventory_path)
		
	_grid_slots_container = Control.new()
	_grid_slots_container.name = "GridSlotsContainer"
	add_child(_grid_slots_container)

	_grid_inventory_content_ui = Control.new()
	_grid_inventory_content_ui.name = "GridInventoryContentUI"
	_grid_inventory_content_ui.resized.connect(_update_size)
	_grid_inventory_content_ui.mouse_filter = Control.MOUSE_FILTER_IGNORE
	add_child(_grid_inventory_content_ui)
	
	_ctrl_item_container = Control.new()
	_ctrl_item_container.size = size
	_ctrl_item_container.mouse_filter = Control.MOUSE_FILTER_IGNORE
	_grid_inventory_content_ui.resized.connect(func(): _ctrl_item_container.size = size)
	_grid_inventory_content_ui.add_child(_ctrl_item_container)

	_grid_drop_zone_ui = GridDropZoneUI.new()
	_grid_drop_zone_ui.dragable_dropped.connect(_on_dragable_dropped)
	_grid_drop_zone_ui.size = size
	resized.connect(func(): _grid_drop_zone_ui.size = size)
	GridDraggableElementUI.dragable_grabbed.connect(func(_dragable: GridDraggableElementUI, _grab_position: Vector2):
		_grid_drop_zone_ui.activate()
	)
	GridDraggableElementUI.dragable_dropped.connect(func(_dragable: GridDraggableElementUI, _zone: GridDropZoneUI, _drop_position: Vector2):
		_grid_drop_zone_ui.deactivate()
	)
	_grid_inventory_content_ui.add_child(_grid_drop_zone_ui)

	_update_size()
	_queue_refresh()
	
func _process(_delta) -> void:
	if _refresh_queued:
		_refresh()
		_refresh_queued = false


func _get_configuration_warnings() -> PackedStringArray:
	if inventory_path.is_empty():
		return PackedStringArray([
				"This node is not linked to an inventory and it can't display any content.\n" + \
				"Set the inventory_path property to point to an InventoryGrid node."])
	return PackedStringArray()
	

func _notification(what: int) -> void:
	if what == NOTIFICATION_DRAG_END:
		_grid_drop_zone_ui.deactivate()
		


func _input(event) -> void:
	if !(event is InputEventMouseMotion):
		return
	if !is_instance_valid(inventory):
		return
	_highlight_grabbed_item()
#endregion


func _connect_inventory_signals() -> void:
	if !is_instance_valid(inventory):
		return
	if !inventory.stack_added.is_connected(_on_inventory_stack_added):
		inventory.stack_added.connect(_on_inventory_stack_added)
	if !inventory.stack_removed.is_connected(_on_inventory_stack_removed):
		inventory.stack_removed.connect(_on_inventory_stack_removed)
	if !inventory.size_changed.is_connected(_on_inventory_resized):
		inventory.size_changed.connect(_on_inventory_resized)


func _disconnect_inventory_signals() -> void:
	if !is_instance_valid(inventory):
		return
	if inventory.stack_added.is_connected(_on_inventory_stack_added):
		inventory.stack_added.disconnect(_on_inventory_stack_added)
	if inventory.stack_removed.is_connected(_on_inventory_stack_removed):
		inventory.stack_removed.disconnect(_on_inventory_stack_removed)
	if inventory.size_changed.is_connected(_on_inventory_resized):
		inventory.size_changed.disconnect(_on_inventory_resized)


func _on_stack_added(_stack_index : int):
	_queue_refresh()


func _update_stacks():
	for stack_ui in _stack_uis:
		stack_ui.queue_free()
	_stack_uis.clear()
	for stack_index in inventory.stacks.size():
		_on_inventory_stack_added(stack_index)
	

func _on_inventory_stack_added(stack_index: int):
	var stack = inventory.stacks[stack_index]
	add_grid_item_stack_ui(stack)


func _on_inventory_stack_removed(stack_index: int):
	var _stack_ui = _stack_uis[stack_index]
	_stack_ui.queue_free()
	_stack_uis.remove_at(stack_index)


func _refresh() -> void:
	_refresh_grid_slots()
	size = custom_minimum_size
	
	if is_instance_valid(_grid_drop_zone_ui):
		_grid_drop_zone_ui.deactivate()
	if is_instance_valid(_grid_inventory_content_ui):
		_grid_inventory_content_ui.custom_minimum_size = _get_inventory_size_pixels()


func _queue_refresh() -> void:
	_refresh_queued = true
		

#region Grid Slots
func get_grid_slot_coords(local_pos: Vector2) -> Vector2i:
	# We have to consider the item spacing when calculating grid slot coordinates, thus we expand the
	# size of each field by Vector2(item_spacing, item_spacing).
	var grid_slot_dimensions_ex = grid_slot_size + Vector2(item_spacing, item_spacing)

	# We also don't want the item spacing to disturb snapping to the closest field, so we add half
	# the spacing to the local coordinates.
	var local_pos_ex = local_pos + (Vector2(item_spacing, item_spacing) / 2)

	var x: int = local_pos_ex.x / (grid_slot_dimensions_ex.x)
	var y: int = local_pos_ex.y / (grid_slot_dimensions_ex.y)
	return Vector2i(x, y)


func _refresh_grid_slots() -> void:
	if is_instance_valid(_grid_slots_container):
		while _grid_slots_container.get_child_count() > 0:
			_grid_slots_container.get_children()[0].queue_free()
			_grid_slots_container.remove_child(_grid_slots_container.get_children()[0])
	_grid_slots = []

	if !is_instance_valid(inventory):
		return
	
	for i in range(inventory.size.x):
		_grid_slots.append([])
		for j in range(inventory.size.y):
			var grid_slot_ui: GridSlotUI = grid_slot_ui_scene.instantiate()
			grid_slot_ui.size = grid_slot_size
			grid_slot_ui.position = _get_grid_slot_position(Vector2i(i, j))
			grid_slot_ui.setup(Vector2i(i, j), inventory)
			_grid_slots_container.add_child(grid_slot_ui)
			_grid_slots[i].append(grid_slot_ui)
			
			
func _set_selected_grid_slots(rect: Rect2i, selected: bool) -> void:
	var h_range = min(rect.size.x + rect.position.x, inventory.size.x)
	for i in range(rect.position.x, h_range):
		var v_range = min(rect.size.y + rect.position.y, inventory.size.y)
		for j in range(rect.position.y, v_range):
			if selected:
				_grid_slots[i][j].select()
			else:
				_grid_slots[i][j].unselect()


func _set_dragged_grid_slots(rect: Rect2i, dragged: bool) -> void:
	var h_range = min(rect.size.x + rect.position.x, inventory.size.x)
	for i in range(rect.position.x, h_range):
		var v_range = min(rect.size.y + rect.position.y, inventory.size.y)
		for j in range(rect.position.y, v_range):
			_grid_slots[i][j].item_dragged = dragged


func _fill_background(style: StyleBox, priority: int) -> void:
	for panel in _grid_slots_container.get_children():
		panel.set_style(style, priority)
#endregion


func _update_size() -> void:
	custom_minimum_size = _grid_inventory_content_ui.size
	size = _grid_inventory_content_ui.size


func _on_inventory_resized() -> void:
	_queue_refresh()
	_refresh_grid_slots()


func _highlight_grabbed_item():
	var grabbed_item: ItemStack = _get_global_grabbed_item()
	if !grabbed_item:
		return

	var global_grabbed_item_pos: Vector2 = _get_global_grabbed_item_local_pos()
	if !_is_hovering(global_grabbed_item_pos):
		#_set_dragged_grid_slots(rect, false)
		return

	#_set_dragged_grid_slots(rect, false)

	var grabbed_item_coords := get_grid_slot_coords(global_grabbed_item_pos + (grid_slot_size / 2))
	var definition : ItemDefinition = inventory.database.get_item(grabbed_item.item_id)
	var item_size := definition.size
	var rect := Rect2i(grabbed_item_coords, item_size)
	if !Rect2i(Vector2i.ZERO, inventory.size).encloses(rect):
		return
	#_set_dragged_grid_slots(rect, true)


func _is_hovering(local_pos: Vector2) -> bool:
	return Rect2(Vector2.ZERO, size).has_point(local_pos)


func _get_global_grabbed_item() -> ItemStack:
	if GridDraggableElementUI.get_grabbed_dragable() == null:
		return null
	return (GridDraggableElementUI.get_grabbed_dragable() as GridItemStackUI).stack


func _get_global_grabbed_item_local_pos() -> Vector2:
	if GridDraggableElementUI.get_grabbed_dragable():
		return get_local_mouse_position() - GridDraggableElementUI.get_grab_offset_local_to(self)
	return Vector2(-1, -1)


## Returns the currently selected item. In case multiple items are selected,
## the first one is returned.
func get_selected_inventory_item() -> GridItemStackUI:
	if !is_instance_valid(_grid_inventory_content_ui):
		return null
	return _selected_stacks[0]


## Returns all the currently selected items.
func get_selected_stacks() -> Array[GridItemStackUI]:
	return _selected_stacks.duplicate()

	
#region ContentUI
func _on_item_drop(zone: GridDropZoneUI, drop_position: Vector2, grid_item_stack_ui: GridItemStackUI) -> void:
	var stack: ItemStack = grid_item_stack_ui.item
	# The item might have been freed in case the item stack has been moved and merged with another
	# stack.
	if is_instance_valid(stack) and inventory.has_stack(stack):
		if zone == null:
			item_dropped.emit(stack, drop_position + grid_item_stack_ui.position)


func add_grid_item_stack_ui(stack: ItemStack):
	var grid_item_stack_ui : GridItemStackUI = grid_item_stack_ui_scene.instantiate()
	grid_item_stack_ui.size = _get_stack_sprite_size(stack)
	grid_item_stack_ui.setup(inventory, stack)
	grid_item_stack_ui.grabbed.connect(_on_item_grab.bind(grid_item_stack_ui))
	#grid_item_stack_ui.dropped.connect(_on_item_drop.bind(grid_item_stack_ui))
	grid_item_stack_ui.activated.connect(_on_item_activated.bind(grid_item_stack_ui))
	grid_item_stack_ui.context_activated.connect(_on_item_context_activated.bind(grid_item_stack_ui))
	grid_item_stack_ui.mouse_entered.connect(func():
		item_mouse_entered.emit(grid_item_stack_ui.stack)
	)
	grid_item_stack_ui.mouse_exited.connect(func():
		item_mouse_exited.emit(grid_item_stack_ui.stack)
	)
	grid_item_stack_ui.clicked.connect(_on_item_clicked.bind(grid_item_stack_ui))
	grid_item_stack_ui.middle_clicked.connect(_on_item_middle_clicked.bind(grid_item_stack_ui))
	grid_item_stack_ui.position = _get_grid_slot_position(inventory.get_stack_position(stack))

	_ctrl_item_container.add_child(grid_item_stack_ui)
	_stack_uis.append(grid_item_stack_ui)
	
		
func _on_item_middle_clicked(grid_item_stack_ui) -> void:
	var stack = grid_item_stack_ui.stack
	if !is_instance_valid(stack):
		return
	
	var stack_size : int = stack.amount
	var stack_index = inventory.stacks.find(stack)

	# All this floor/float jazz just to do integer division without warnings
	var new_stack_size: int = floor(float(stack_size) / 2)
	request_split.emit(inventory, stack_index, new_stack_size)


func _on_item_clicked(grid_item_stack_ui) -> void:
	var stack = grid_item_stack_ui.stack
	if !is_instance_valid(stack):
			return
	
	if Input.is_action_pressed("ui_inventory_transfer"):
		var stack_position : Vector2i = inventory.get_stack_position(stack)
		#TODO make rotation with R key or mouse wheel
		var _is_rotated: bool = inventory.is_stack_rotated(stack)
		
		request_fast_transfer.emit(inventory, stack_position, stack.amount)
	else:
		
		if select_mode == SelectMode.SELECT_MULTI && Input.is_key_pressed(KEY_CTRL):
			if !_is_item_selected(stack):
				_select(grid_item_stack_ui)
			else:
				_deselect(grid_item_stack_ui)
		else:
			_clear_selection()
			_select(grid_item_stack_ui)


func _on_item_grab(_offset: Vector2, _grid_item_stack_ui: GridItemStackUI) -> void:
	_clear_selection()


func _on_item_context_activated(event: InputEvent, grid_item_stack_ui: GridItemStackUI) -> void:
	var stack = grid_item_stack_ui.stack
	if !stack:
		return

	inventory_stack_context_activated.emit(event, inventory, stack)


func _on_dragable_dropped(dragable: GridDraggableElementUI, drop_position: Vector2) -> void:
	var stack: ItemStack = dragable.stack
	if stack == null:
		return

	if !is_instance_valid(inventory):
		return

	_handle_stack_transfer(stack, drop_position, dragable.inventory)


func _handle_stack_transfer(stack: ItemStack, drop_position: Vector2, source_inventory : Inventory) -> void:
	var grid_slot_coords = get_grid_slot_coords(drop_position + (grid_slot_size / 2))
	
	if source_inventory == null:
		printerr("source_inventory is null?")
		return
	
	if source_inventory.database != inventory.database:
		return
		
	var stack_position : Vector2i = source_inventory.get_stack_position(stack)
	#TODO make rotation with R key or mouse wheel
	var is_rotated: bool = source_inventory.is_stack_rotated(stack)
	request_transfer_to.emit(source_inventory, stack_position, inventory, grid_slot_coords, stack.amount, is_rotated)


#region Stack UI Utils
func get_stack_rect(stack: ItemStack) -> Rect2:
	if !is_instance_valid(stack):
		return Rect2()
	return Rect2(
		_get_grid_slot_position(inventory.get_stack_position(stack)),
		_get_stack_sprite_size(stack)
	)


func _get_stack_sprite_size(stack: ItemStack) -> Vector2:
	var item_size: Vector2i = inventory.get_stack_size(stack)
	var sprite_size := Vector2(item_size) * grid_slot_size
	# Also take item spacing into consideration
	sprite_size += (Vector2(item_size) - Vector2.ONE) * item_spacing
	return sprite_size


func _get_grid_slot_position(grid_slot_coords: Vector2i) -> Vector2:
	var grid_slot_position = Vector2(grid_slot_coords.x * grid_slot_size.x, \
		grid_slot_coords.y * grid_slot_size.y)
	grid_slot_position += Vector2(item_spacing * grid_slot_coords)
	return grid_slot_position


func _get_inventory_size_pixels() -> Vector2:
	if !is_instance_valid(inventory):
		return Vector2.ZERO

	var result := Vector2(inventory.size.x * grid_slot_size.x, \
		inventory.size.y * grid_slot_size.y)

	# Also take item spacing into consideration
	result += Vector2(inventory.size - Vector2i.ONE) * item_spacing

	return result
#endregion

#region Selected Stacks
func _on_selection_changed() -> void:
	_handle_selection_change()
	selection_changed.emit()


func _handle_selection_change() -> void:
	if !is_instance_valid(inventory):
		return

	for stack_ui in _stack_uis:
		if stack_ui:
			_set_selected_grid_slots(inventory.get_stack_rect(stack_ui.stack), stack_ui in get_selected_stacks())


func _is_item_selected(stack: ItemStack) -> bool:
	return stack in _selected_stacks


func _select(stack_ui: GridItemStackUI) -> void:
	var stack = stack_ui.stack
	if stack in _selected_stacks:
		return

	if stack != null && !inventory.has_stack(stack):
		return

	_selected_stacks.append(stack_ui)
	_on_selection_changed()
	stack_ui.select()
	
	
func _deselect(stack_ui: GridItemStackUI) -> void:
	var stack = stack_ui.stack
	if !(stack in _selected_stacks):
		return
	var idx := _selected_stacks.find(stack_ui)
	if idx < 0:
		return
	_selected_stacks.remove_at(idx)
	_on_selection_changed()
	stack_ui.unselect()


func _clear_selection() -> void:
	if _selected_stacks.is_empty():
		return
	for selected_stack in _selected_stacks:
		if is_instance_valid(selected_stack):
			selected_stack.unselect()
	_selected_stacks.clear()
	selection_changed.emit()
	
	
func _on_item_activated(grid_item_stack_ui: GridItemStackUI) -> void:
	var stack = grid_item_stack_ui.stack
	if !stack:
		return

	inventory_item_activated.emit(stack)
#endregion
#endregion
</file>

<file path="godot-coop/addons/inventory-system-demos/ui/grid/grid_selection_panel.gd">
extends Panel
class_name GridSelectionPanel

func set_style(style: StyleBox) -> void:
	remove_theme_stylebox_override("panel")
	if style != null:
		add_theme_stylebox_override("panel", style)
</file>

<file path="godot-coop/addons/inventory-system-demos/ui/grid/grid_slot_ui.gd">
@tool
extends Panel
class_name GridSlotUI

enum StylePriority {HIGH = 0, MEDIUM = 1, LOW = 2}

@export var regular_style: StyleBox
@export var hover_style: StyleBox
@export var selected_style: StyleBox
var _styles: Array[StyleBox] = [null, null, null]
@onready var audio_stream_player: AudioStreamPlayer = $AudioStreamPlayer

@onready var category_icon: TextureRect = %CategoryIcon
var _grid_position: Vector2i
var inventory: GridInventory


var item_dragged: bool = false:
	set(value):
		pass
		#print("item_grabbed",value)
		
		
func setup(grid_position: Vector2i, new_inventory: GridInventory):
	self._grid_position = grid_position
	self.inventory = new_inventory


func select():
	if is_instance_valid(selected_style):
		_set_panel_style(selected_style)


func unselect():
	_set_panel_style(regular_style)


func _ready() -> void:
	_set_panel_style(regular_style)
	mouse_entered.connect(func():
		_set_panel_style(hover_style)
		audio_stream_player.play()
	)
	mouse_exited.connect(func():
		_set_panel_style(regular_style)
	)
	if inventory == null:
		return
	for i in inventory.grid_constraints:
		if i is CategoryGridInventoryConstraint:
			var category: String = i.get_category(_grid_position)
			if category != "" and inventory.database != null:
				var cat: ItemCategory = inventory.database.get_category_from_id(category)
				if cat != null:
					category_icon.visible = true
					category_icon.texture = cat.icon
					self_modulate = cat.color
					return
	self_modulate = Color.WHITE
	category_icon.visible = false


func set_style(style: StyleBox, priority: int = StylePriority.LOW) -> void:
	if priority > 2 || priority < 0:
		return
	if _styles[priority] == style:
		return

	#_styles[priority] = style
#
	#for i in range(0, 3):
		#if _styles[i] != null or i == 2:
			#_set_panel_style(_styles[i])
			#return


func _set_panel_style(style: StyleBox) -> void:
	remove_theme_stylebox_override("panel")
	if style != null:
		add_theme_stylebox_override("panel", style)
</file>

<file path="godot-coop/addons/inventory-system-demos/ui/hotbar/hotbar_slot_ui.gd">
extends Panel
class_name HotbarSlotUI

@onready var icon: TextureRect = %Icon
@onready var slot_index_label: Label = $SlotIndexLabel
@onready var selection_panel: Panel = $SelectionPanel
var stack: ItemStack
var database: InventoryDatabase
var inventory: Inventory
var default_size: Vector2


@export var texture_rect: Array[TextureRect]

func _ready() -> void:
	default_size = size


func set_selection(is_selected: bool):
	selection_panel.visible = is_selected


func _process(_delta: float) -> void:
	if database == null or stack == null:
		return
	var def = database.get_item(stack.item_id)
	if def == null:
		return

func update_info_with_stack(_database: InventoryDatabase, _stack: ItemStack, _inventory: Inventory, slot_indexes: PackedInt32Array):
	self.database = _database
	self.stack = _stack
	self.inventory = _inventory
	for i in texture_rect.size():
		texture_rect[i].visible = i == slot_indexes[0]
	var slot_text = ""
	for i in slot_indexes:
		slot_text += str(i + 1)
		if slot_indexes.size() != i + 1:
			slot_text += " "
	slot_index_label.text = slot_text
	
	if stack == null:
		icon.visible = false
		return
		
	var def = database.get_item(stack.item_id)
	if def == null:
		icon.visible = false
		size = default_size
		custom_minimum_size = default_size
		return
		
	size = Vector2(def.size.x * default_size.x, def.size.y * default_size.y)
	custom_minimum_size = Vector2(def.size.x * default_size.x, def.size.y * default_size.y)
		
	icon.visible = true
	icon.texture = def.icon
	icon.size = Vector2(def.size.x * default_size.x, def.size.y * default_size.y)
</file>

<file path="godot-coop/addons/inventory-system-demos/ui/hotbar/hotbar_ui.gd">
class_name HotbarUI
extends Control

## [PackedScene] which is used to instantiate [SlotUI] for each slot added in [Hotbar]
@export var slot_ui_scene: PackedScene

## Parent [Control] for the [SlotUI] instances
@export var slots_container: Container

var hotbar: Hotbar

var ui_stacks: Array[Panel]
# Group of slot indices for each UI (same order as ui_stacks)
var ui_stack_groups: Array[PackedInt32Array] = []


## Defines an [Hotbar] linked to this hotbar UI.
## This function disconnects signals from the previous [Inventory] and connects signals with new [Inventory]
func set_hotbar(new_hotbar: Hotbar):
	if new_hotbar != self.hotbar:
		if self.hotbar != null:
			self.hotbar.on_change_selection.disconnect(_on_changed_selection)
		self.hotbar = new_hotbar
		self.hotbar.on_change_selection.connect(_on_changed_selection)
		self.hotbar.equipped.connect(_on_equipped_stack)
		self.hotbar.unequipped.connect(_on_equipped_stack)
		_update_slots()
		_on_changed_selection(hotbar.selection_index)


func _on_changed_selection(_selection_index):
	_update_selection()


func _update_selection():
	if hotbar == null:
		return
	# Highlight only the grouped UI that contains the current selection index
	for i in ui_stacks.size():
		var ui_stack: Panel = ui_stacks[i]
		var group: PackedInt32Array = ui_stack_groups[i]
		var selected := group.has(hotbar.selection_index)
		if ui_stack.has_method("set_selection"):
			ui_stack.set_selection(selected)


func _on_equipped_stack(_slot_index: int):
	_update_slots()


func _update_slots():
	# Clear previous UI
	for ui_stack in ui_stacks:
		ui_stack.queue_free()
	ui_stacks.clear()
	ui_stack_groups.clear()

	if hotbar == null:
		return

	# Map stacks to all slot indices they occupy (group duplicates)
	var stack_groups := { }  # key: instance_id (int) or "empty:<slot>" string; value: PackedInt32Array
	for i in hotbar.max_slots:
		var stack := hotbar.get_stack_on_slot(i)
		if stack != null and stack.has_valid():
			var key := str(stack.get_instance_id())
			if not stack_groups.has(key):
				stack_groups[key] = PackedInt32Array()
			stack_groups[key].append(i)
		else:
			# Keep empty/inactive slots as unique entries so UI still shows them
			var key_empty := "empty:%d" % i
			stack_groups[key_empty] = PackedInt32Array([i])

	# Create one UI per group (first slot is the primary index)
	for key in stack_groups.keys():
		var indices: PackedInt32Array = stack_groups[key]
		var primary_index := indices[0]
		var stack := hotbar.get_stack_on_slot(primary_index)

		var stack_ui: HotbarSlotUI = slot_ui_scene.instantiate()
		slots_container.add_child(stack_ui)

		stack_ui.update_info_with_stack(hotbar.database, stack, hotbar.get_inventory(), indices)

		# Visible if any covered slot is active (or at least the primary is active)
		var any_active := false
		for idx in indices:
			if hotbar.is_active_slot(idx):
				any_active = true
				break
		stack_ui.visible = any_active

		ui_stacks.append(stack_ui)
		ui_stack_groups.append(indices)

	_update_selection()
</file>

<file path="godot-coop/addons/inventory-system-demos/ui/interactor/action_message_ui.gd">
class_name ActionMessageUI
extends HBoxContainer

@export var input_helper : InputHelper
@export var input_icons : InputIcons
@export var texture_rect : TextureRect
@export var interact_message : Label
@export var action_input : String:
	set(value):
		action_input = value
		setup_icon(value)
@export var description : String:
	set(value):
		description = value
		setup_description(value)
		


func setup_icon(input_text : String):
	var action_0_events : Array[InputEvent] = InputMap.action_get_events(input_text)
	if action_0_events.is_empty():
		return
	var action_0_event_0 : InputEvent = action_0_events[0]
	var texture = input_helper.get_event_as_icon(action_0_event_0, input_icons)
	texture_rect.visible = true
	texture_rect.texture = texture


func setup_description(new_description : String):
	interact_message.text = new_description


func hide_message():
	visible = false


func show_message(new_action_input : String, new_description : String):
	self.action_input = new_action_input
	self.description = new_description
	visible = true
</file>

<file path="godot-coop/addons/inventory-system-demos/ui/interactor/input_helper.gd">
################################################################################
# MIT License
# Copyright (c) 2021 PunchablePlushie
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
@tool
class_name InputHelper
extends Resource

enum InputType {INVALID, KEYBOARD, MOUSE, GP_BTN, GP_MOTION}

@export var joy_name_abbr: Dictionary = {
	"XInput Gamepad": "xbox",
	"Xbox Series Controller": "xbox",
	"Sony DualSense": "ps",
	"PS5 Controller": "ps",
	"PS4 Controller": "ps",
	"Switch": "switch",
} 

@export var labels: Dictionary = {
	"mouse": [
		"LMB", "RMB", "MMB", "MW Up", "MW Down", "MW Left", "MW Right", "MB1", "MB2"
	],
	
	"xbox": [
		"A", "B", "X", "Y", "Back", "Home", "Start", "L", "R", "LB", "RB",
		"DPad Up", "DPad Down", "DPad Left", "DPad Right", "Share"
	],
	
	"ps": [
		"Cross", "Circle", "Square", "Triangle", "Select", "PS", "Start",
		"L3", "R3", "L1", "R1", "DPad Up", "DPad Down", "DPad Left",
		"DPad Right", "Microphone"
	],
	
	"switch": [
		"B", "A", "Y", "X", "Minus", "", "Plus", "", "", "", "",
		"DPad Up", "DPad Down", "DPad Left", "DPad Right", "Capture"
	],
	
	"other": [
		"A", "B", "X", "Y", "Back", "Home", "Start", "L", "R", "LB", "RB",
		"DPad Up", "DPad Down", "DPad Left", "DPad Right", "Share",
		"Paddle 1", "Paddle 2", "Paddle 3", "Paddle 4", "Touch"
	],
	
	"motion": [
		{"-": "LStick Left", "+": "LStick Right"},
		{"-": "LStick Up", "+": "LStick Down"},
		{"-": "RStick Left", "+": "RStick Right"},
		{"-": "RStick Up", "+": "RStick Down"},
		{"+": "Left Trigger"},
		{"+": "Right Trigger"}
	],
}


func get_event_id(event: InputEvent) -> int:
	if event is InputEventKey:
		if event.physical_keycode == 0:
			return -1
		
		return event.physical_keycode | event.get_modifiers_mask()
	
	if event is InputEventMouseButton:
		return event.button_index | event.get_modifiers_mask()
	
	if event is InputEventJoypadButton:
		return event.button_index
	
	if event is InputEventJoypadMotion:
		return event.axis
	
	return -1


func set_event_id(event: InputEvent, id: int) -> void:
	if event is InputEventKey:
		event.physical_keycode = id & ~(KEY_MASK_SHIFT | KEY_MASK_CTRL | KEY_MASK_ALT)
		_set_event_modifiers(event, id)
	
	if event is InputEventMouseButton:
		event.button_index = id & ~(KEY_MASK_SHIFT | KEY_MASK_CTRL | KEY_MASK_ALT)
		_set_event_modifiers(event, id)
	
	if event is InputEventJoypadButton:
		event.button_index = id
	
	if event is InputEventJoypadMotion:
		event.axis = id


func get_event_type(event: InputEvent) -> InputType:
	if event is InputEventKey:
		return InputType.KEYBOARD
	
	if event is InputEventMouseButton:
		return InputType.MOUSE
	
	if event is InputEventJoypadButton:
		return InputType.GP_BTN
	
	if event is InputEventJoypadMotion:
		return InputType.GP_MOTION
	
	return InputType.INVALID


func create_event_from_type(type: InputType) -> InputEvent:
	match type:
		InputType.KEYBOARD:
			return InputEventKey.new()
		InputType.MOUSE:
			return InputEventMouseButton.new()
		InputType.GP_BTN:
			return InputEventJoypadButton.new()
		InputType.GP_MOTION:
			return InputEventJoypadMotion.new()
		_:
			return null


func input_already_exists(event: InputEvent, self_action: String) -> Array:
	for action in InputMap.get_actions():
		if action.begins_with("ui_"):
			continue
		
		if action == self_action:
			continue
		
		if InputMap.action_has_event(action, event):
			return [true, action]
	
	return [false, ""]

 
func _set_event_modifiers(event: InputEventWithModifiers, modifier_mask: int) -> void:
	event.shift_pressed = bool(modifier_mask & KEY_MASK_SHIFT)
	event.ctrl_pressed = bool(modifier_mask & KEY_MASK_CTRL)
	event.alt_pressed = bool(modifier_mask & KEY_MASK_ALT)


### Events as Text

func get_event_as_text(event: InputEvent) -> String:
	if get_event_id(event) == -1:
		return "INVALID"
	
	if event is InputEventKey:
		return OS.get_keycode_string(event.get_physical_keycode_with_modifiers())
	
	if event is InputEventMouseButton:
		return _get_mouse_event_as_text(event)
	
	if event is InputEventJoypadButton:
		return _get_gp_btn_event_as_text(event)
	
	if event is InputEventJoypadMotion:
		return _get_gp_motion_event_as_text(event)
	
	return ""


func _get_modifiers_as_string(event: InputEventWithModifiers) -> String:
	var modifiers: PackedStringArray
	if event.shift_pressed:
		modifiers.append("Shift")
	
	if event.ctrl_pressed:
		modifiers.append("Ctrl")
	
	if event.alt_pressed:
		modifiers.append("Alt")
	
	var modifiers_string: String = "+".join(modifiers) 
	return modifiers_string


func _get_joy_name_abbr(name: String) -> String:
	if joy_name_abbr.has(name):
		return joy_name_abbr[name]
	else:
		return "other"


func _get_mouse_event_as_text(event: InputEventMouseButton) -> String:
	var modifiers: String = _get_modifiers_as_string(event)
	var btn: String = labels["mouse"][event.button_index - 1]
	var result: String = "%s"%btn if modifiers.is_empty() else "%s+%s"%[modifiers, btn]
	return result


func _get_gp_btn_event_as_text(event: InputEventJoypadButton) -> String:
	var device_name: String = Input.get_joy_name(event.device)
	device_name = _get_joy_name_abbr(device_name)
	return labels[device_name][event.button_index]


func _get_gp_motion_event_as_text(event: InputEventJoypadMotion) -> String:
	var axis_value: String = "-" if event.axis_value < 0 else "+"
	return labels["motion"][event.axis][axis_value]


### Events as Icons

func get_event_as_icon(event: InputEvent, icon_db: InputIcons) -> Texture2D:
	if event is InputEventKey:
		return _get_keyboard_event_as_icon(event, icon_db)
		
	if event is InputEventMouseButton:
		return _get_mouse_event_as_icon(event, icon_db)
	
	if event is InputEventJoypadButton:
		return _get_gp_btn_event_as_icon(event, icon_db)
	
	if event is InputEventJoypadMotion:
		return _get_gp_motion_event_as_icon(event, icon_db)
	
	return null


func _get_keyboard_event_as_icon(event: InputEventKey, icon_db: InputIcons) -> Texture2D:
	var keycode: int = event.physical_keycode
	var icon: Texture2D = icon_db.get_keyboard_button_texture(keycode)
	
	return icon


func _get_mouse_event_as_icon(event: InputEventMouse, icon_db: InputIcons) -> Texture2D:
	var button_index: int = event.button_index
	var icon: Texture2D = icon_db.get_mouse_button_texture(button_index)
	
	return icon


func _get_gp_btn_event_as_icon(event: InputEventJoypadButton, icon_db: InputIcons) -> Texture2D:
	var device_name: String = Input.get_joy_name(event.device)
	device_name = _get_joy_name_abbr(device_name)
	
	var button_index: int = event.button_index
	var icon: Texture2D = icon_db.get_gp_button_texture(device_name, button_index)
	
	return icon


func _get_gp_motion_event_as_icon(event: InputEventJoypadMotion, icon_db: InputIcons) -> Texture2D:
	var device_name: String = Input.get_joy_name(event.device)
	device_name = _get_joy_name_abbr(device_name)
	
	var axis: int = event.axis
	var axis_dir: String = "-" if event.axis_value < 1 else "+"
	var icon: Texture2D = icon_db.get_gp_motion_texture(device_name, axis, axis_dir)
	
	return icon
</file>

<file path="godot-coop/addons/inventory-system-demos/ui/interactor/input_icons.gd">
################################################################################
# MIT License
# Copyright (c) 2021 PunchablePlushie
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

@tool
class_name InputIcons
extends Resource

var property_map: Dictionary = {
	"keycodes": {
		67: "c",
		69: "e",
		73: "i",
		70: "l",
		82: "r",
		84: "t",
		4194332: "f1",
		4194333: "f2",
		4194334: "f3",
		4194335: "f4",
		4194336: "f5",
		4194337: "f6",
		4194338: "f7",
		4194339: "f8",
		4194340: "f9",
		4194341: "f10",
		4194342: "f11",
		4194343: "f12",
	},
	
	"mouse_button": [
		"lmb", "rmb", "mmb", "mw_up", "mw_down", "mw_left", "mw_right", "mb1", "mb2"
	],
	
	"gp_button": [
		"bot", "right", "left", "top",
		"back", "guide", "start",
		"left_stick", "right_stick",
		"left_shoulder", "right_shoulder",
		"dup", "ddown", "dleft", "dright",
		"misc", "pad1", "pad2", "pad3", "pad4",
		"touch"
	],
	
	"gp_motion": [
		{"-": "ls_left", "+": "ls_right"},
		{"-": "ls_down", "+": "ls_up"},
		{"-": "rs_left", "+": "rs_right"},
		{"-": "rs_down", "+": "rs_up"},
		{"+": "left_trigger"},
		{"+": "right_trigger"},
	],
}


@export_category("Icon Database")
@export_group("Keyboard", "keyboard_")
@export var keyboard_c: Texture2D  # 67
@export var keyboard_e: Texture2D  # 69
@export var keyboard_i: Texture2D  # 73
@export var keyboard_r: Texture2D  # 82
@export var keyboard_t: Texture2D  # 84
@export var keyboard_f1: Texture2D  # 4194332
@export var keyboard_f2: Texture2D  # 4194333
@export var keyboard_f3: Texture2D  # 4194334
@export var keyboard_f4: Texture2D  # 4194335
@export var keyboard_f5: Texture2D  # 4194336
@export var keyboard_f6: Texture2D  # 4194337
@export var keyboard_f7: Texture2D  # 4194338
@export var keyboard_f8: Texture2D  # 4194339
@export var keyboard_f9: Texture2D  # 4194340
@export var keyboard_f10: Texture2D  # 4194341
@export var keyboard_f11: Texture2D  # 4194342
@export var keyboard_f12: Texture2D  # 4194343



@export_group("Mouse", "mouse_")
@export var mouse_lmb: Texture2D
@export var mouse_rmb: Texture2D
@export var mouse_mmb: Texture2D
@export var mouse_mw_up: Texture2D
@export var mouse_mw_down: Texture2D
@export var mouse_mw_left: Texture2D
@export var mouse_mw_right: Texture2D
@export var mouse_mb1: Texture2D
@export var mouse_mb2: Texture2D


@export_group("XBox", "xbox_")
@export_subgroup("XBox Motions", "xbox_")
@export var xbox_ls_left: Texture2D
@export var xbox_ls_right: Texture2D
@export var xbox_ls_up: Texture2D
@export var xbox_ls_down: Texture2D
@export var xbox_rs_left: Texture2D
@export var xbox_rs_right: Texture2D
@export var xbox_rs_up: Texture2D
@export var xbox_rs_down: Texture2D
@export var xbox_left_trigger: Texture2D
@export var xbox_right_trigger: Texture2D
@export_subgroup("XBox Buttons", "xbox_")
@export var xbox_bot: Texture2D
@export var xbox_right: Texture2D
@export var xbox_left: Texture2D
@export var xbox_top: Texture2D
@export var xbox_back: Texture2D
@export var xbox_guide: Texture2D
@export var xbox_start: Texture2D
@export var xbox_left_stick: Texture2D
@export var xbox_right_stick: Texture2D
@export var xbox_left_shoulder: Texture2D
@export var xbox_right_shoulder: Texture2D
@export var xbox_dup: Texture2D
@export var xbox_ddown: Texture2D
@export var xbox_dleft: Texture2D
@export var xbox_dright: Texture2D
@export var xbox_misc: Texture2D
@export var xbox_pad1: Texture2D
@export var xbox_pad2: Texture2D
@export var xbox_pad3: Texture2D
@export var xbox_pad4: Texture2D
@export var xbox_touch: Texture2D

@export_group("Playstation", "ps_")
@export_subgroup("PS Motions", "ps_")
@export var ps_ls_left: Texture2D
@export var ps_ls_right: Texture2D
@export var ps_ls_up: Texture2D
@export var ps_ls_down: Texture2D
@export var ps_rs_left: Texture2D
@export var ps_rs_right: Texture2D
@export var ps_rs_up: Texture2D
@export var ps_rs_down: Texture2D
@export var ps_left_trigger: Texture2D
@export var ps_right_trigger: Texture2D
@export_subgroup("PS Buttons", "ps_")
@export var ps_bot: Texture2D
@export var ps_right: Texture2D
@export var ps_left: Texture2D
@export var ps_top: Texture2D
@export var ps_back: Texture2D
@export var ps_guide: Texture2D
@export var ps_start: Texture2D
@export var ps_left_stick: Texture2D
@export var ps_right_stick: Texture2D
@export var ps_left_shoulder: Texture2D
@export var ps_right_shoulder: Texture2D
@export var ps_dup: Texture2D
@export var ps_ddown: Texture2D
@export var ps_dleft: Texture2D
@export var ps_dright: Texture2D
@export var ps_misc: Texture2D
@export var ps_pad1: Texture2D
@export var ps_pad2: Texture2D
@export var ps_pad3: Texture2D
@export var ps_pad4: Texture2D
@export var ps_touch: Texture2D

@export_group("Switch", "switch_")
@export_subgroup("Switch Motions", "switch_")
@export var switch_ls_left: Texture2D
@export var switch_ls_right: Texture2D
@export var switch_ls_up: Texture2D
@export var switch_ls_down: Texture2D
@export var switch_rs_left: Texture2D
@export var switch_rs_right: Texture2D
@export var switch_rs_up: Texture2D
@export var switch_rs_down: Texture2D
@export var switch_left_trigger: Texture2D
@export var switch_right_trigger: Texture2D
@export_subgroup("Switch Buttons", "switch_")
@export var switch_bot: Texture2D
@export var switch_right: Texture2D
@export var switch_left: Texture2D
@export var switch_top: Texture2D
@export var switch_back: Texture2D
@export var switch_guide: Texture2D
@export var switch_start: Texture2D
@export var switch_left_stick: Texture2D
@export var switch_right_stick: Texture2D
@export var switch_left_shoulder: Texture2D
@export var switch_right_shoulder: Texture2D
@export var switch_dup: Texture2D
@export var switch_ddown: Texture2D
@export var switch_dleft: Texture2D
@export var switch_dright: Texture2D
@export var switch_misc: Texture2D
@export var switch_pad1: Texture2D
@export var switch_pad2: Texture2D
@export var switch_pad3: Texture2D
@export var switch_pad4: Texture2D
@export var switch_touch: Texture2D

@export_group("Other", "other_")
@export_subgroup("Other Motions", "other_")
@export var other_ls_left: Texture2D
@export var other_ls_right: Texture2D
@export var other_ls_up: Texture2D
@export var other_ls_down: Texture2D
@export var other_rs_left: Texture2D
@export var other_rs_right: Texture2D
@export var other_rs_up: Texture2D
@export var other_rs_down: Texture2D
@export var other_left_trigger: Texture2D
@export var other_right_trigger: Texture2D
@export_subgroup("Other Buttons", "other_")
@export var other_bot: Texture2D
@export var other_right: Texture2D
@export var other_left: Texture2D
@export var other_top: Texture2D
@export var other_back: Texture2D
@export var other_guide: Texture2D
@export var other_start: Texture2D
@export var other_left_stick: Texture2D
@export var other_right_stick: Texture2D
@export var other_left_shoulder: Texture2D
@export var other_right_shoulder: Texture2D
@export var other_dup: Texture2D
@export var other_ddown: Texture2D
@export var other_dleft: Texture2D
@export var other_dright: Texture2D
@export var other_misc: Texture2D
@export var other_pad1: Texture2D
@export var other_pad2: Texture2D
@export var other_pad3: Texture2D
@export var other_pad4: Texture2D
@export var other_touch: Texture2D


func get_keyboard_button_texture(keycode: int) -> Texture2D:
	return get("keyboard_%s"%property_map["keycodes"][keycode])


func get_mouse_button_texture(button_index: int) -> Texture2D:
	return get("mouse_%s"%property_map["mouse_button"][button_index - 1])


func get_gp_button_texture(category: String, button_index: int) -> Texture2D:
	return get("%s_%s"%[category, property_map["gp_button"][button_index]])


func get_gp_motion_texture(category: String, axis: int, axis_dir: String) -> Texture2D:
	return get("%s_%s"%[category, property_map["gp_motion"][axis][axis_dir]])
</file>

<file path="godot-coop/addons/inventory-system-demos/ui/interactor/interactor_ui.gd">
class_name InteractorUI
extends Control

const Interactor = preload("../../interaction_system/inventory_interactor.gd")

@export var interact_messages : Array[ActionMessageUI]
@onready var interact_position : Control = $InteractPosition
var default_interact_message_position : Vector2
@export var interactor : Interactor
@export var input_icons : InputIcons

var interact_object
var interact_hand_object

func setup(_interactor : Interactor):
	if self.interactor != null:
		interactor.preview_interacted.disconnect(_on_preview_interacted)
	self.interactor = _interactor
	interactor.preview_interacted.connect(_on_preview_interacted)


func _ready():
	for i in interact_messages:
		i.input_icons = input_icons
		i.hide_message()
	default_interact_message_position = interact_position.position


func _on_preview_interacted(actions : Array, position_on_screen : Vector2):
	preview_interact(actions, position_on_screen)


func preview_interact(actions : Array, position_on_screen : Vector2):
	for i in interact_messages:
		i.visible = true
	if position_on_screen == Vector2.ZERO:
		interact_position.position = default_interact_message_position
	else:
		interact_position.position = position_on_screen
	for i in interact_messages.size():
		var interact_message = interact_messages[i]
		if i < actions.size():
			interact_message.show_message(actions[i].input, actions[i].description)
			
		else:
			interact_message.hide_message()
</file>

<file path="godot-coop/addons/inventory-system-demos/ui/inventory_system_ui.gd">
class_name InventorySystemUI
extends Control

const Interactor = preload("../interaction_system/inventory_interactor.gd")

## This script manages inventory system UI information
## Contains drag slot information, UI inventories and item drop area

@export var console_mode : bool = false:
	set(value):
		player_inventory_ui.console_mode = console_mode
		loot_inventory_ui.console_mode = console_mode
		console_mode = value
		
@export var character : CharacterInventorySystem

## Stores [Crafter] information to connect all signals and callbacks
@export var interactor : Interactor

## Player [InventoryUI], Typically the main usage inventory
@onready var player_inventory_ui : GridInventoryPanel = %PlayerGridInventoryUI

## Loot [InventoryUI], Typically an inventory that has been opened
@onready var loot_inventory_ui : GridInventoryPanel = %LootGridInventoryUI

## Loot [Equipment UI], Typically an inventory that has been opened
@onready var equipment_container: VBoxContainer = $MarginContainer/HBoxContainer/EquipmentContainer

## Hotbar [HotbarUI]
@onready var hotbar_ui : HotbarUI = get_node(NodePath("HotbarUI"))

## Control that identifies area where a transaction slot can call the handler to drop items
@onready var drop_area: DropArea = get_node(NodePath("DropArea"))


@onready var player_craft_station_ui : CraftStationUI = %PlayerCraftStationUI

@onready var other_craft_station_ui : CraftStationUI = %OtherCraftStationUI

@onready var interactor_ui : InteractorUI = get_node(NodePath("InteractorUI"))

@onready var stack_popup_menu: PopupMenu = $StackPopupMenu


var alternative_inventory : Inventory

func _ready():
	stack_popup_menu.id_pressed.connect(_on_stack_popup_menu_id_pressed)
	# TODO connect
	# _setup_inventory_system_connection()
	player_inventory_ui.visible = false
	loot_inventory_ui.visible = false
	drop_area.visible = false
	hotbar_ui.visible = true
	equipment_container.visible = false
	player_craft_station_ui.close()
	other_craft_station_ui.close()
	drop_area.request_drop.connect(_request_drop)
	
	player_inventory_ui.request_transfer_to.connect(_request_transfer_to)
	loot_inventory_ui.request_transfer_to.connect(_request_transfer_to)
	
	player_inventory_ui.request_fast_transfer.connect(_request_fast_transfer)
	loot_inventory_ui.request_fast_transfer.connect(_request_fast_transfer)
	
	player_inventory_ui.request_split.connect(_request_split)
	loot_inventory_ui.request_split.connect(_request_split)
	#player_inventory_ui.request_sort.connect(_request_sort)
	#loot_inventory_ui.request_sort.connect(_request_sort)
	
	player_inventory_ui.inventory_stack_context_activated.connect(_inventory_stack_context)
	loot_inventory_ui.inventory_stack_context_activated.connect(_inventory_stack_context)
	
	other_craft_station_ui.input_inventory_ui.inventory_stack_context_activated.connect(_inventory_stack_context)
	
	#player_craft_station_ui.input_inventory_ui.request_transfer_to.connect(_request_transfer_to)
	other_craft_station_ui.input_inventory_ui.request_transfer_to.connect(_request_transfer_to)
	other_craft_station_ui.input_inventory_ui.request_fast_transfer.connect(_request_fast_transfer)
	other_craft_station_ui.input_inventory_ui.request_split.connect(_request_split)
	
	player_craft_station_ui.on_craft.connect(_on_craft)
	other_craft_station_ui.on_craft.connect(_on_craft)


## Setup inventory handler and connect all signals
func setup(_character : CharacterInventorySystem):
	self.character = _character
	
	var inventories : Array[Inventory]
	inventories.append(character.main_inventory)
	#inventories.append(character.equipment_inventory)
	set_player_inventory(character.main_inventory)
	character.opened_inventory.connect(_on_open_inventory)
	character.closed_inventory.connect(_on_close_inventory)
	
	# Stations
	character.opened_station.connect(_on_open_craft_station)
	character.closed_station.connect(_on_close_craft_station)
	# Interactor
	self.interactor = interactor
	interactor_ui.setup(character.interactor)
	# Hotbar
	hotbar_ui.set_hotbar(character.hotbar)
	


## Setup player inventories
func set_player_inventory(player_inventory : GridInventory):
	player_inventory_ui.inventory = player_inventory


func _drop_area_input(event : InputEvent):
	if event is InputEventMouseButton:
		if event.pressed:
			pass
			#character.drop_holder()


func _open_player_inventory():
	player_inventory_ui.visible = true
		
	hotbar_ui.visible = false
	drop_area.visible = true
#	TODO console mode?
	#if console_mode and not player_inventories_ui.is_empty():
		#if player_inventories_ui[0].items.is_empty():
			#player_inventories_ui[0].items[0].grab_focus()


# Open Inventory of player	
func _on_open_inventory(inventory : Inventory):
	if character.main_inventory != inventory:
		print(inventory.name)
		loot_inventory_ui.inventory = inventory
		loot_inventory_ui.visible = true
		equipment_container.visible = true
		alternative_inventory = loot_inventory_ui.inventory
	else:
		_open_player_inventory()
		

# Open Craft Station	
func _on_open_craft_station(craft_station : CraftStation):
	# TODO #42 Different skins for different types of craft stations
	if craft_station == character.main_station:
		player_craft_station_ui.open(craft_station)
	else:
		other_craft_station_ui.open(craft_station)
		alternative_inventory = craft_station.get_input_inventory()
	hotbar_ui.visible = false
	_open_player_inventory()


func _on_close_craft_station(craft_station : CraftStation):
	if craft_station == character.main_station:
		player_craft_station_ui.close()
	else:
		other_craft_station_ui.close()
		alternative_inventory = null
	hotbar_ui.visible = true
	_close_player_inventory()


func _on_close_inventory(inventory : Inventory):
	if character.main_inventory != inventory:
		alternative_inventory = null
	_close_player_inventory()


func _close_player_inventory():
	player_inventory_ui.visible = false
	loot_inventory_ui.visible = false
	#if loot_inventory_ui.inventory != null:
		#loot_inventory_ui.disconnect_old_inventory()
	drop_area.visible = false
	hotbar_ui.visible = true


func _on_craft(craft_station : CraftStation, recipe_index : int):
	character.craft(craft_station, recipe_index)


func _request_transfer_to(inventory: GridInventory, origin_pos: Vector2i, destination: GridInventory, destination_pos: Vector2i, amount: int, is_rotated: bool):
	character.transfer_to(inventory, origin_pos, destination, destination_pos, amount, is_rotated)


func _request_fast_transfer(inventory: GridInventory, origin_pos: Vector2i, amount: int):
	var destination: Inventory
	if inventory == player_inventory_ui.inventory:
		if alternative_inventory == null:
			return
		destination = alternative_inventory
	else:
		destination = player_inventory_ui.inventory
	character.transfer(inventory, origin_pos, destination, amount)


func _request_split(inventory : Inventory, stack_index : int, amount : int):
	character.split(inventory, stack_index, amount)


func _request_drop(stack: ItemStack, inventory: Inventory):
	character.drop(stack, inventory)


func _request_rotate(stack: ItemStack, inventory: Inventory):
	character.rotate(stack, inventory)


func _request_equip(stack: ItemStack, inventory: Inventory, slot_index: int):
	character.equip(stack, inventory, slot_index)


func _request_sort(inventory : Inventory):
	character.sort(inventory)


var current_stack: ItemStack
var current_inventory: GridInventory
const STACK_MENU_ID_SPLIT = 0
const STACK_MENU_ID_DROP = 1
const STACK_MENU_ID_EQUIP = 2
const STACK_MENU_ID_ROTATE = 3
const STACK_MENU_ID_MOVE_TO = 4
const STACK_MENU_ID_SORT = 9

func _inventory_stack_context(event: InputEvent, inventory: GridInventory, stack: ItemStack):
	current_stack = stack
	current_inventory = inventory
	if !(event is InputEventMouseButton):
		return

	var mb_event: InputEventMouseButton = event
	
	#var def = inventory.database.get_item(stack.item_id)
	#var stack_name = str(stack.amount) + " x "
	#if def == null:
		#stack_name += stack.item_id
	#else:
		#stack_name += def.name
	
	stack_popup_menu.clear()
	stack_popup_menu.add_item("Split", STACK_MENU_ID_SPLIT)
	stack_popup_menu.add_item("Rotate", STACK_MENU_ID_ROTATE)
	stack_popup_menu.add_item("Drop", STACK_MENU_ID_DROP)
	
	
	
	var equip_menu : PopupMenu = PopupMenu.new()
	for i in 4:
		if hotbar_ui.hotbar.is_active_slot(i):
			equip_menu.add_item(str("Equip on ",(i+1)), i)
	equip_menu.id_pressed.connect(_on_equip_menu_id_pressed)
	
	
	stack_popup_menu.add_submenu_node_item("Equip", equip_menu)
	#stack_popup_menu.add_item("Move to ", STACK_MENU_ID_MOVE_TO)
	stack_popup_menu.add_separator()
	stack_popup_menu.add_item("Sort Inventory", STACK_MENU_ID_SORT)
	
	stack_popup_menu.set_item_disabled(0, stack.amount == 1)
	
	stack_popup_menu.position = mb_event.global_position
	stack_popup_menu.popup()

func _on_stack_popup_menu_id_pressed(id: int):
	if current_stack == null:
		return
	if current_inventory == null:
		return
	match id:
		STACK_MENU_ID_SPLIT:
			var stack_index = current_inventory.stacks.find(current_stack)
			if stack_index == -1:
				return
			_request_split(current_inventory, stack_index, (int)(current_stack.amount/2.0))
		STACK_MENU_ID_DROP:
			_request_drop(current_stack, current_inventory)
		STACK_MENU_ID_ROTATE:
			_request_rotate(current_stack, current_inventory)
		STACK_MENU_ID_SORT:
			_request_sort(current_inventory)
		STACK_MENU_ID_MOVE_TO:
			_request_sort(current_inventory)


func _on_equip_menu_id_pressed(id: int):
	if current_stack == null:
		return
	if current_inventory == null:
		return
	_request_equip(current_stack, current_inventory, id)
</file>

<file path="godot-coop/characters/npcs/human_dummy/human_npc.gd">
extends CharacterBase
</file>

<file path="godot-coop/characters/player/components/camera_follow.gd">
extends Camera3D
@export var lerp_speed := 5
@export var target_node : Node3D
@export var camera_x_offset: float = 0.5 # Offset lateral (derecha positivo, izquierda negativo)

func _ready() -> void:
	if is_multiplayer_authority():
		current = true
	else:
		current = false
		set_process(false)

func _process(delta: float) -> void:
	var target_pos = target_node.position
	
	target_pos.x += camera_x_offset
	
	position = lerp(position, target_pos, delta * lerp_speed)
</file>

<file path="godot-coop/characters/player/components/camera_spring_arm.gd">
extends Node3D

@export var mouse_sensivity := 0.0025
@onready var spring_arm_3d: SpringArm3D = $SpringArm3D


func _ready() -> void:
	if is_multiplayer_authority():
		Input.mouse_mode = Input.MOUSE_MODE_CAPTURED
	else: set_process(false)
	

func _input(event: InputEvent) -> void:
	if is_multiplayer_authority():
		if event is InputEventMouseMotion and Input.get_mouse_mode() == Input.MOUSE_MODE_CAPTURED:
			rotation.y -= event.relative.x * mouse_sensivity
			rotation.y = wrapf(rotation.y, 0.0, TAU)
			
			rotation.x -= event.relative.y * mouse_sensivity
			rotation.x = clamp(rotation.x, deg_to_rad(-90), deg_to_rad(30))
</file>

<file path="godot-coop/characters/player/components/coop_character_inventory_system_ui.gd">
extends Control
class_name CoopInventorySystemUI

var coop_character_inventory_system : CoopCharacterInventorySystem
@onready var player_inventory_ui: GridInventoryPanel = %GridInventoryPanel



func _ready() -> void:
	player_inventory_ui.visible = false


func setup(characterInventorySystem : CoopCharacterInventorySystem) -> void:
	self.coop_character_inventory_system = characterInventorySystem
	
	set_player_inventory(coop_character_inventory_system.main_inventory)
	coop_character_inventory_system.opened_inventory.connect(_on_open_inventory)

## Setup player inventories
func set_player_inventory(player_inventory : GridInventory):
	player_inventory_ui.inventory = player_inventory
	
# Open Inventory of player	
func _on_open_inventory(inventory : Inventory):
	#if character.main_inventory != inventory:
		#loot_inventory_ui.inventory = inventory
		#loot_inventory_ui.visible = true
		#alternative_inventory = loot_inventory_ui.inventory
	#else:
		_open_player_inventory()
func _open_player_inventory():
	player_inventory_ui.visible = true
</file>

<file path="godot-coop/characters/player/components/coop_character_inventory_system.gd">
@tool
@icon("res://addons/inventory-system-demos/icons/character_inventory_system.svg")
extends NodeInventories
class_name CoopCharacterInventorySystem

#region Signals
signal opened_inventory(inventory : Inventory)
#endregion
const Interactor = preload("res://addons/inventory-system-demos/interaction_system/inventory_interactor.gd")

var opened_inventories : Array[Inventory]

@export_group("ðŸ—ƒï¸ Inventory Nodes")

@onready var main_inventory: GridInventory = $Inventory
@onready var drop_parent: CharacterBody3D = $".."
@export_node_path var interactor_path := NodePath("Interactor")
@onready var interactor : Interactor = get_node(interactor_path)



@export_group("âŒ¨ï¸ Inputs")
## Change mouse state based on inventory status
@export var change_mouse_state : bool = true
@export var check_inputs : bool = true
@export var toggle_inventory_input : String = "toggle_inventory"

@export_group("ðŸ«´ Interact")
@export var can_interact : bool = true
@export var raycast : RayCast3D:
	set(value):
		raycast = value
		var _interactor = get_node(interactor_path)
		if _interactor != null and value != null:
			_interactor.raycast = value
@export var camera_3d : Camera3D:
	set(value):
		camera_3d = value
		var _interactor = get_node(interactor_path)
		if _interactor != null and value != null:
			_interactor.camera = value

func _ready():
	if Engine.is_editor_hint():
		return

func _physics_process(_delta : float):
	if Engine.is_editor_hint():
		return
	if not can_interact:
		return
	interactor.try_interact()



func _input(_event : InputEvent) -> void:
	if Engine.is_editor_hint():
		return
	if check_inputs:
		inventory_inputs()


func inventory_inputs() -> void:
	if Input.is_action_just_released(toggle_inventory_input):
		# Check if any inventory or craft statis is already open
		if not is_any_station_or_inventory_opened():
			open_main_inventory()
			pass

func open_main_inventory():
	open_inventory(main_inventory)

func is_any_station_or_inventory_opened() -> bool:
	return is_open_any_station() or is_open_main_inventory()

func pick_to_inventory(node : Node):
	if main_inventory == null:
		return

	if node == null:
		return

	if !node.get("is_pickable"):
		return

	var item_id = node.item_id
	var item_properties = node.item_properties
	var amount = node.amount

	if main_inventory.add(item_id, amount, item_properties, true) == 0:
		node.queue_free();
		return

	printerr("pick_to_inventory return false");


#region Open Inventories

func is_open_inventory(inventory : Inventory):
	return opened_inventories.find(inventory) != -1


func open_inventory(inventory: Inventory) -> void:
	if is_open_inventory(inventory):
		return
	add_open_inventory(inventory)


func add_open_inventory(inventory: Inventory) -> void:
	opened_inventories.append(inventory)
	opened_inventory.emit(inventory)
	if not is_open_main_inventory():
		#inventory.request_drop_obj.connect(_on_request_drop_obj)
		open_main_inventory()


func _check_inputs():
	if is_any_station_or_inventory_opened():
		Input.mouse_mode = Input.MOUSE_MODE_VISIBLE
	else:
		Input.mouse_mode = Input.MOUSE_MODE_CAPTURED

func is_open_main_inventory():
	return is_open_inventory(main_inventory)
#endregion
	
#region Open Craft Stations
func is_open_station(_station : CraftStation):
	# TODO: Add craft station logic
	return false
func is_open_any_station() -> bool:
	return false
	#return !opened_stations.is_empty()
#endregion
</file>

<file path="godot-coop/levels/maps/main.gd">
extends Node
class_name MainCoopScene

@export var player_scene : PackedScene
@export var database : InventoryDatabase

var connected_peer_ids : Array
var players : Array
var peer : ENetMultiplayerPeer



func _ready():
	multiplayer.peer_connected.connect(_player_connected)
	multiplayer.peer_disconnected.connect(_player_disconnected)




func host_game() -> void:
	peer = ENetMultiplayerPeer.new()
	peer.create_server(4242)
	multiplayer.set_multiplayer_peer(peer)
	create_player(multiplayer.get_unique_id())
	$"UI/Connect Panel".visible = false
	await get_tree().create_timer(1).timeout
	make_scene_objects_to_network()

func connect_to_ip(ip):
	peer = ENetMultiplayerPeer.new()
	peer.create_client(ip, 4242)
	multiplayer.set_multiplayer_peer(peer)
	$"UI/Connect Panel".visible = false
	var items = $Level/Items
	for i in items.get_child_count():
		var item = items.get_child(i) as DroppedItem3D
		item.queue_free()

func create_player(client_id) -> void:
	connected_peer_ids.append(client_id)
	var player = player_scene.instantiate()
	player.name = str(client_id)
	players.append(player)
	player.position = Vector3(0,2,0)
	add_child(player)
	if multiplayer.get_unique_id() == client_id:
		$"UI/InventorySystemUI".setup(player.get_node("CharacterInventorySystem"))



func make_scene_objects_to_network() -> void:
	var items = $Level/Items
	var spawner = get_node("DroppedItemSpawner")
	for i in items.get_child_count():
		var item_dropped = items.get_child(i) as DroppedItem3D
		var item_id : String = item_dropped.item_id
		var definition = database.get_item(item_id)
		var position = item_dropped.position
		var rotation = item_dropped.rotation
		var amount = item_dropped.amount
		item_dropped.queue_free()
		var dropped_item_path = definition.properties["dropped_item"]
		var _obj = spawner.spawn([position, rotation, dropped_item_path, amount])

func _player_connected(new_peer_id : int):
	if multiplayer.is_server():
		add_newly_connected_player_character.rpc(new_peer_id)
		add_previously_connected_player_characters.rpc_id(new_peer_id, connected_peer_ids)
		create_player(new_peer_id)


func _player_disconnected(peer_id : int):
	var pos = connected_peer_ids.find(peer_id)
	if pos > 0 and pos < connected_peer_ids.size():
		connected_peer_ids.remove_at(pos)
		var player = players[pos]
		players.remove_at(pos)
		player.queue_free()

@rpc
func add_newly_connected_player_character(new_peer_id):
	create_player(new_peer_id)


@rpc
func add_previously_connected_player_characters(peer_ids):
	for peer_id in peer_ids:
		create_player(peer_id)



func _on_host_button_button_up() -> void:
	host_game()
	pass # Replace with function body.


func _on_connect_button_button_up() -> void:
	connect_to_ip("localhost")
	pass # Replace with function body.
</file>

<file path="godot-coop/systems/network_manager.gd">
extends Node

const PORT := 4000
const IP_ADDRESS := "localhost"
var peer : ENetMultiplayerPeer

func start_server() -> void:
	peer = ENetMultiplayerPeer.new()
	peer.create_server(PORT)
	multiplayer.multiplayer_peer = peer
	multiplayer.peer_connected.connect(on_peer_connected)
	multiplayer.peer_disconnected.connect(on_peer_disconnected)
	
	
func connect_client() -> void:
	peer = ENetMultiplayerPeer.new()
	peer.create_client(IP_ADDRESS, PORT)
	multiplayer.multiplayer_peer = peer
	
func on_peer_connected(_client_id : int) -> void:
	print("client conected")

func on_peer_disconnected(_client_id : int) -> void:
	print("client disconnected")
</file>

<file path="godot-coop/systems/projectile_spawner.gd">
extends MultiplayerSpawner

class_name ProjectileSpawner


func _init() -> void:
	spawn_function = _spawn_projectile

func _spawn_projectile(data: Array):
	var pos = data[0]
	var rot = data[1]
	var vel = data[2]
	var path_to_tres  = data[3]
	
	
	var stats_resource = load(path_to_tres) as ThrowableData
	if not stats_resource: return null
	var scene_inside_resource = stats_resource.projectile_scene

	if not scene_inside_resource: return null
	var obj = scene_inside_resource.instantiate()
	obj.position = pos
	obj.rotation = rot
	if obj is RigidBody3D:
		obj.linear_velocity = vel
	if obj.has_method("setup_projectile"):
		obj.setup_projectile(stats_resource, vel)
	
	return obj
</file>

<file path="godot-coop/addons/inventory-system-demos/fps/loot_box_inventory.gd">
extends BoxInventory
class_name LootBoxInventory

@onready var loot_generator: LootGenerator = $LootGenerator

func _on_open():
	print("generate loot")
	loot_generator.generate_loot()
	super._on_open()


func _on_close():
	inventory.clear()
	super._on_close()
</file>

<file path="godot-coop/addons/inventory-system-demos/mp/networked_character_inventory_system.gd">
@tool
class_name NetworkedCharacterInventorySystem
extends "../character/character_inventory_system.gd"
@onready var equipment_manager: EquipmentManager = $EquipmentManager


func _ready():
	if Engine.is_editor_hint():
		return
	if is_multiplayer_authority():
		# Setup for enabled/disabled mouse ðŸ–±ï¸ðŸ˜€
		opened_inventory.connect(_update_opened_inventories)
		closed_inventory.connect(_update_opened_inventories)
		opened_station.connect(_update_opened_stations)
		closed_station.connect(_update_opened_stations)
		_update_opened_inventories(main_inventory)
	else:
		picked.connect(_on_picked)
	hotbar.active_slot(0)
	hotbar.active_slot(1)


func _on_picked(obj : Node):
	picked_rpc.rpc(obj.get_path())


func _input(event : InputEvent):
	if Engine.is_editor_hint():
		return
	if check_inputs and is_multiplayer_authority():
		hot_bar_inputs(event)
		inventory_inputs()


func open_main_inventory():
	if multiplayer.is_server():
		super.open_main_inventory()
		for inventory in equipment_manager.get_children():
			if inventory is GridInventory:
				open_inventory(inventory)
	else:
		open_main_inventory_rpc.rpc_id(1)


func open_inventory(inventory : Inventory):
	if multiplayer.is_server():
		super.open_inventory(inventory)
	else:
		open_inventory_rpc.rpc_id(1, inventory.get_path())


func add_open_inventory(inventory : Inventory):
	if multiplayer.is_server():
		add_open_inventory_rpc.rpc(inventory.get_path())
	super.add_open_inventory(inventory)


func remove_open_inventory(inventory : Inventory):
	if multiplayer.is_server():
		remove_open_inventory_rpc.rpc(inventory.get_path())
	super.remove_open_inventory(inventory)


func close_inventories():
	if multiplayer.is_server():
		super.close_inventories()
		
	else:
		close_inventories_rpc.rpc_id(1)


func pick_to_inventory(node : Node):
	if multiplayer.is_server():
		super.pick_to_inventory(node)
	else:
		pick_to_inventory_rpc.rpc_id(1, node.get_path())


func transfer_to(inventory: GridInventory, origin_pos: Vector2i, destination: GridInventory, destination_pos: Vector2i, amount: int, is_rotated: bool):
	if multiplayer.is_server():
		super.transfer_to(inventory, origin_pos, destination, destination_pos, amount, is_rotated)
	else:
		transfer_to_rpc.rpc_id(1, inventory.get_path(), origin_pos, destination.get_path(), destination_pos, amount, is_rotated)


func rotate(stack: ItemStack, inventory: Inventory):
	if multiplayer.is_server():
		super.rotate(stack, inventory)
	else:
		var stack_index = inventory.stacks.find(stack)
		if stack_index != -1:
			rotate_rpc.rpc_id(1, stack_index, inventory.get_path())


func split(inventory : Inventory, stack_index : int, amount : int):
	if multiplayer.is_server():
		super.split(inventory, stack_index, amount)
	else:
		split_rpc.rpc_id(1, inventory.get_path(), stack_index, amount)


func sort(inventory : Inventory):
	if multiplayer.is_server():
		super.sort(inventory)
	else:
		sort_rpc.rpc_id(1, inventory.get_path())


func drop(stack: ItemStack, inventory: Inventory):
	if multiplayer.is_server():
		super.drop(stack, inventory)
	else:
		var stack_index = inventory.stacks.find(stack)
		if stack_index != -1:
			drop_rpc.rpc_id(1, stack_index, inventory.get_path())


func equip(stack: ItemStack, inventory: Inventory, slot_index: int):
	if multiplayer.is_server():
		super.equip(stack, inventory, slot_index)
	else:
		var stack_index = inventory.stacks.find(stack)
		if stack_index != -1:
			equip_rpc.rpc_id(1, stack_index, inventory.get_path(), slot_index)


func hotbar_change_selection(index : int):
	if multiplayer.is_server():
		super.hotbar_change_selection(index)
	else:
		hotbar_change_selection_rpc.rpc_id(1, index)


func hotbar_previous_item():
	if multiplayer.is_server():
		super.hotbar_previous_item()
	else:
		hotbar_previous_item_rpc.rpc_id(1)


func hotbar_next_item():
	if multiplayer.is_server():
		super.hotbar_next_item()
	else:
		hotbar_next_item_rpc.rpc_id(1)


func open_main_craft_station():
	if multiplayer.is_server():
		super.open_main_craft_station()
	else:
		open_main_craft_station_rpc.rpc_id(1)


func close_craft_stations():
	if multiplayer.is_server():
		super.close_craft_stations()
	else:
		close_stations_rpc.rpc_id(1)


func craft(craft_station : CraftStation, recipe_index : int):
	if multiplayer.is_server():
		craft_rpc(craft_station.get_path(), recipe_index)
	else:
		craft_rpc.rpc(craft_station.get_path(), recipe_index)


func open_station(craft_station : CraftStation):
	if multiplayer.is_server():
		open_station_rpc(get_path_to(craft_station))
	else:
		open_station_rpc.rpc(get_path_to(craft_station))


func add_open_station(craft_station : CraftStation):
	if multiplayer.is_server():
		add_open_station_rpc.rpc(craft_station.get_path())
	super.add_open_station(craft_station)


func remove_open_station(craft_station : CraftStation):
	if multiplayer.is_server():
		remove_open_station_rpc.rpc(craft_station.get_path())
	super.remove_open_station(craft_station)


@rpc("any_peer")
func picked_rpc(obj_path : NodePath):
	var obj = get_node(obj_path)
	picked.emit(obj)


@rpc("any_peer")
func open_main_inventory_rpc():
	super.open_main_inventory()


@rpc
func open_inventory_rpc(inventory_path : NodePath):
	var inventory = get_node(inventory_path)
	super.open_inventory(inventory)


@rpc("any_peer")
func add_open_inventory_rpc(inventory_path : NodePath):
	var inventory = get_node(inventory_path)
	super.add_open_inventory(inventory)


@rpc("any_peer")
func remove_open_inventory_rpc(inventory_path : NodePath):
	var inventory = get_node(inventory_path)
	super.remove_open_inventory(inventory)


@rpc("any_peer")
func add_open_station_rpc(station_path : NodePath):
	var station = get_node(station_path)
	super.add_open_station(station)


@rpc("any_peer")
func remove_open_station_rpc(station_path : NodePath):
	var station = get_node(station_path)
	super.remove_open_station(station)


@rpc
func close_inventories_rpc():
	if multiplayer.is_server():
		super.close_inventories()


@rpc
func pick_to_inventory_rpc(node_path: NodePath):
	super.pick_to_inventory(get_node(node_path))


@rpc
func transfer_to_rpc(inventory_path: NodePath, origin_pos: Vector2i, destination_path: NodePath, destination_pos: Vector2i, amount: int, is_rotated: bool):
	var inv = get_node(inventory_path)
	var dest_inv = get_node(destination_path)
	if inv == null or dest_inv == null:
		return
	super.transfer_to(inv, origin_pos, dest_inv, destination_pos, amount, is_rotated)


@rpc
func split_rpc(inventory_path: NodePath, stack_index: int, amount: int):
	var inv = get_node(inventory_path)
	if inv == null:
		return
	super.split(inv, stack_index, amount)


@rpc
func rotate_rpc(stack_index: int, inventory_path: NodePath):
	var inv = get_node(inventory_path)
	if inv == null:
		return
	var stack = inv.stacks[stack_index]
	super.rotate(stack, inv)


@rpc
func sort_rpc(inventory_path: NodePath):
	var inv = get_node(inventory_path)
	if inv == null:
		return
	super.sort(inv)


@rpc
func drop_rpc(stack_index: int, inventory_path: NodePath):
	var inv = get_node(inventory_path)
	if inv == null:
		return
	var stack = inv.stacks[stack_index]
	super.drop(stack, inv)


@rpc
func equip_rpc(stack_index: int, inventory_path: NodePath, slot_index: int):
	var inv = get_node(inventory_path)
	if inv == null:
		return
	var stack = inv.stacks[stack_index]
	super.equip(stack, inv, slot_index)


@rpc
func hotbar_change_selection_rpc(selection_index: int):
	if not multiplayer.is_server():
		return
	super.hotbar_change_selection(selection_index)


@rpc
func hotbar_previous_item_rpc():
	if not multiplayer.is_server():
		return
	super.hotbar_previous_item()


@rpc
func hotbar_next_item_rpc():
	if not multiplayer.is_server():
		return
	super.hotbar_next_item()

@rpc
func open_main_craft_station_rpc():
	super.open_main_craft_station()


@rpc
func open_station_rpc(craft_station_path : NodePath):
	var station = get_node(craft_station_path)
	super.open_station(station)


@rpc
func close_stations_rpc():
	if multiplayer.is_server():
		super.close_craft_stations()


@rpc
func craft_rpc(craft_station_path : NodePath, recipe_index : int):
	var station = get_node(craft_station_path)
	station.craft(recipe_index)


func _physics_process(_delta : float):
	if Engine.is_editor_hint():
		return
	if not can_interact:
		return
	if multiplayer.multiplayer_peer != null and is_multiplayer_authority():
		interactor.try_interact()
</file>

<file path="godot-coop/addons/inventory-system-demos/ui/craft/recipe_ui.gd">
class_name RecipeUI
extends Control

## Represents a [Recipe] in the interface. It is instantiated by [CraftStationUI]

# Scene to instantiate the [IngredientUI]
@export var ingredient_scene : PackedScene

@onready var icon : TextureRect = get_node("Control/ItemIcon")
@onready var item_name : Label = get_node("ItemName")
@onready var time_to_craft : Label = get_node("TimeToCraft")
@onready var craft_button : Button = get_node("CraftButton")
@onready var ingredients_container : HBoxContainer = get_node("IngredientsItemsList")
@onready var required_items_list = %RequiredItemsList


var recipe_index : int
var craft_station : CraftStation
var _ingredients : Array[IngredientUI]

## Configures the recipe with index values from [Recipe] from [InventoryDatabase].
## Called by [CraftStationUI].
func set_recipe(_craft_station : CraftStation, _recipe : Recipe, _recipe_index : int):
	self.craft_station = _craft_station
	self.recipe_index = _recipe_index
	var product_item : ItemDefinition = craft_station.database.get_item(_recipe.products[0].item_id)
	icon.texture = product_item.icon
	item_name.text = product_item.name
	time_to_craft.text = str(_recipe.time_to_craft) + " Seconds"
	_clear_ingredients()
	for ingredient in _recipe.ingredients:
		var ingredient_obj : IngredientUI = ingredient_scene.instantiate()
		ingredients_container.add_child(ingredient_obj)
		ingredient_obj.setup(craft_station.database, ingredient)
		_ingredients.append(ingredient_obj)
	for ingredient in _recipe.required_items:
		var ingredient_obj : IngredientUI = ingredient_scene.instantiate()
		ingredients_container.add_child(ingredient_obj)
		ingredient_obj.setup(craft_station.database, ingredient)
		_ingredients.append(ingredient_obj)
	check_if_has_ingredients()


func _clear_ingredients():
	for ingredient_ui in _ingredients:
		ingredient_ui.queue_free()
		_ingredients.clear()


func check_if_has_ingredients():
	var recipe = craft_station.database.recipes[recipe_index]
	craft_button.disabled = not craft_station.can_craft(recipe)
</file>

<file path="godot-coop/addons/inventory-system-demos/ui/grid/grid_item_stack_ui.gd">
@tool
extends GridDraggableElementUI
class_name GridItemStackUI

signal activated
signal clicked
signal middle_clicked
signal context_activated(event: InputEvent)

@export var stack_style: StyleBox
@export var hover_stack_style: StyleBox
@export var selected_stack_style: StyleBox
@export var unknown_icon: Texture2D

@onready var texture_bg: Panel = $TextureBG
@onready var item_icon: TextureRect = %ItemIcon
@onready var stack_size_label: Label = $StackSizeLabel
@onready var audio_stream_player: AudioStreamPlayer = $AudioStreamPlayer
@onready var audio_stream_player_2: AudioStreamPlayer = $AudioStreamPlayer2

var inventory : GridInventory
var stack: ItemStack


func setup(inv: Inventory, new_stack: ItemStack):
	self.inventory = inv
	self.stack = new_stack
	if stack and inventory != null:
		var definition: ItemDefinition = inventory.database.get_item(stack.item_id)
		tooltip_text = definition.description
		var is_rotated = inventory.is_stack_rotated(stack)
		var texture = definition.icon
		if is_rotated:
			var image = texture.get_image()
			image.rotate_90(CLOCKWISE)
			texture = ImageTexture.create_from_image(image)
		%ItemIcon.texture = texture

		activate()
		_disconnect_item_signals()
		_connect_item_signals(stack)
	else:
		%ItemIcon.texture = null
		deactivate()
	_update_stack_size()


func _connect_item_signals(new_item: ItemStack) -> void:
	if new_item == null:
		return

	if !new_item.updated.is_connected(_refresh):
		new_item.updated.connect(_refresh)

	if inventory != null and !inventory.updated_stack.is_connected(_update_stack_index):
		inventory.updated_stack.connect(_update_stack_index)


func _disconnect_item_signals() -> void:
	if !is_instance_valid(stack):
		return

	if stack.updated.is_connected(_refresh):
		stack.updated.disconnect(_refresh)

	if inventory != null and inventory.updated_stack.is_connected(_update_stack_index):
		inventory.updated_stack.disconnect(_update_stack_index)


func _ready() -> void:
	_set_panel_style(stack_style)
	mouse_entered.connect(func():
		# Solo feedback visual si estÃ¡ activo (revelado)
		if is_active(): 
			_set_panel_style(hover_stack_style)
			audio_stream_player_2.play()
	)
	mouse_exited.connect(func():
		_set_panel_style(stack_style)
	)
	grabbed.connect(func(_offset):
		visible = false
		audio_stream_player.play()
	)
	if stack == null:
		deactivate()
	else:
		# Ejecutar lÃ³gica visual al inicio
		_update_visuals()

func _update_visuals():
	if not stack or not inventory:
		return

	# 1. Comprobamos si estÃ¡ revelado (por defecto true si no existe la propiedad)
	var is_revealed: bool = stack.properties.get("revealed", true)
	
	if is_revealed:
		# --- ESTADO REVELADO (LÃ³gica Original) ---
		var definition: ItemDefinition = inventory.database.get_item(stack.item_id)
		tooltip_text = definition.description
		
		# GestiÃ³n de rotaciÃ³n
		var is_rotated = inventory.is_stack_rotated(stack)
		var texture = definition.icon
		if is_rotated:
			var image = texture.get_image()
			image.rotate_90(CLOCKWISE)
			texture = ImageTexture.create_from_image(image)
		
		%ItemIcon.texture = texture
		%ItemIcon.modulate = Color(1, 1, 1, 1) # Restaurar color normal
		
		# Activar arrastre e interacciÃ³n
		activate() 
		
	else:
		# --- ESTADO OCULTO ("Searching...") ---
		tooltip_text = "Searching..."
		
		# Usar icono de incÃ³gnita si existe, si no, poner el del item pero oscuro
		if unknown_icon:
			%ItemIcon.texture = unknown_icon
			%ItemIcon.modulate = Color(1, 1, 1, 1)
		else:
			# Fallback: Si no has asignado icono unknown, mostramos el item muy oscuro
			var definition = inventory.database.get_item(stack.item_id)
			%ItemIcon.texture = definition.icon
			%ItemIcon.modulate = Color(0.1, 0.1, 0.1, 1) # Muy oscuro/silueta
		
		# DESACTIVAR ARRASTRE (Importante: impide robarlo)
		deactivate()

	# Actualizar etiqueta de cantidad (si estÃ¡ oculto, quizÃ¡s quieras ocultar la cantidad tambiÃ©n)
	_update_stack_size(is_revealed)


func _update_stack_index(_stack_index: int) -> void:
	_refresh()


func select():
	if is_instance_valid(selected_stack_style):
		_set_panel_style(selected_stack_style)


func unselect():
	_set_panel_style(stack_style)


func _notification(what) -> void:
	if what == NOTIFICATION_DRAG_END:
		visible = true


func _update_stack_size(is_revealed: bool = true) -> void:
	if !is_instance_valid(stack_size_label):
		return
		
	# Si no estÃ¡ revelado, ocultamos la cantidad (opcional, estilo Tarkov hardcore)
	if not is_revealed:
		stack_size_label.text = "?"
		return

	if !is_instance_valid(stack):
		stack_size_label.text = ""
		return
	var stack_size: int = stack.amount
	if stack_size <= 1:
		if stack.properties.has("durability"):
			var definition: ItemDefinition = inventory.database.get_item(stack.item_id)
			if definition != null:
				var actual : float = stack.properties["durability"]
				var total : float = definition.properties["durability"]
				stack_size_label.text = str(int(actual/total * 100.0)) + "%"
				return
	else:
		stack_size_label.text = "%d" % stack_size
		return
	stack_size_label.text = ""


func _refresh() -> void:
	# Cuando el servidor actualiza la propiedad 'revealed' a true,
	# se dispara esta funciÃ³n. Re-ejecutamos la lÃ³gica visual.
	_update_visuals()


func create_preview() -> Control:
	var preview = self.duplicate()
	preview.setup(inventory, stack)
	preview.visible = true
	return preview


func _gui_input(event: InputEvent) -> void:
	if !(event is InputEventMouseButton):
		return
		
	# BLOQUEO DE INPUT SI NO ESTÃ REVELADO
	if not is_active():
		return 

	var mb_event: InputEventMouseButton = event
	if !mb_event.pressed:
		return
	if mb_event.button_index == MOUSE_BUTTON_LEFT:
		if mb_event.double_click:
			activated.emit()
		else:
			clicked.emit()
	if mb_event.button_index == MOUSE_BUTTON_MIDDLE:
		middle_clicked.emit()
	elif mb_event.button_index == MOUSE_BUTTON_MASK_RIGHT:
		context_activated.emit(mb_event)


func _set_panel_style(style: StyleBox) -> void:
	remove_theme_stylebox_override("panel")
	if style != null:
		add_theme_stylebox_override("panel", style)
</file>

<file path="godot-coop/systems/multiplayer_spawner.gd">
extends MultiplayerSpawner




func _ready() -> void:
	multiplayer.peer_connected.connect(spawn_player)
	
	


func spawn_player(client_id : int) -> void:
	
	if not multiplayer.is_server(): return
	
	var player = preload("res://characters/player/player.tscn").instantiate()
	player.name = str(client_id)
	
	get_node(spawn_path).call_deferred("add_child", player)
</file>

<file path="godot-coop/characters/player/components/item_thrower.gd">
extends Node3D
#class_name ItemThrower
#
#@export var hotbar: Hotbar
#@export var hand: Node3D
#@export var camera: Camera3D
#@export var throw_force: float = 15.0
#
#@onready var projectile_spawner : MultiplayerSpawner = get_tree().get_first_node_in_group("ProjectileSpawner")
#
#
#func _input(event: InputEvent) -> void:
	#if is_multiplayer_authority():
		#if event.is_action_pressed("throw"):
			#if Input.is_mouse_button_pressed(MOUSE_BUTTON_RIGHT):
				#check_and_throw()
	#else:
		#set_process(false)
#
#func  check_and_throw() -> void:
	#var stack = hotbar.get_stack_on_selection()
	#if stack == null:
		#return
	#var item_id = stack.item_id
	#var item_def = hotbar.database.get_item(item_id)
	#if item_def == null:
		#return
	#if not item_def.properties.has("throwable_data"): 
		#return
#
	#var stats = item_def.properties["throwable_data"]
	#if stats == null: return
#
#
	#var spawn_pos = hand.global_position
	#var direction = -camera.global_transform.basis.z
	#var velocity = direction * throw_force
	#var stack_index = hotbar.selection_index
	#
	#if multiplayer.is_server():
		#throw_potion_rpc(stack_index, spawn_pos, camera.global_rotation, velocity, stats)
		#pass
	#else:
		#throw_potion_rpc.rpc_id(1, stack_index, spawn_pos, camera.global_rotation, velocity, stats)
		#pass
			#
		#
#@rpc("any_peer", "call_local", "reliable")
#func throw_potion_rpc(stack_index: int, pos: Vector3, rot: Vector3, vel: Vector3, path_to_tres : String) -> void:
	#if not multiplayer.is_server():
		#return
	#var inventory = hotbar.get_inventory()
	#if stack_index >= inventory.stacks.size(): return
	#
	#if projectile_spawner:
		#projectile_spawner.spawn([pos, rot, vel, path_to_tres ])
	#else:
		#print("No item spawner")
	#var item_id = inventory.stacks[stack_index].item_id
	#inventory.remove_at(stack_index, item_id, 1)
	#pass
</file>

<file path="godot-coop/items/definitions/throwable_data.gd">
class_name ThrowableData
extends Resource

@export_group("Physics & Visuals")
@export var projectile_scene : PackedScene 
@export var throw_force : float = 15.0

@export_group("Explosion Settings")
@export var blast_radius : float = 3.0       # Mantenemos esto aquÃ­ (es propiedad de la explosiÃ³n fÃ­sica)
@export var area_effect_duration : float = 0.5 # CuÃ¡nto tiempo dura el Ã¡rea de efecto activa (fuego en el suelo)

@export_group("Gameplay Effects")
# AQUÃ ESTÃ LA CLAVE: Un array de recursos
@export var effects: Array[GameplayEffect] = []
</file>

<file path="godot-coop/items/projectile_base.gd">
extends RigidBody3D


class_name ProjectileBase

var data: ThrowableData
var thrower_id: int = 0

@onready var visuals: Node3D = $Visuals
@onready var area_effect: Area3D = %AreaEffect
@onready var impact_sound: AudioStreamPlayer3D = %ImpactSound
@onready var impact_particles: GPUParticles3D = %ImpactParticles


func _ready() -> void:
	contact_monitor = false
	max_contacts_reported = 1
	if multiplayer.is_server():
		body_entered.connect(on_inpact)

func setup_projectile(new_data : ThrowableData, initial_velocity: Vector3) -> void:
	self.data = new_data
	self.linear_velocity = initial_velocity

func on_inpact(body: Node) -> void:
	pass
</file>

<file path="godot-coop/characters/character_base.gd">
class_name CharacterBase
extends CharacterBody3D

@onready var attribute_set: AttributeSet = %AttributeSet






func receive_gameplay_effects(effects: Array[GameplayEffect]) -> void:
	if attribute_set:
		attribute_set.apply_gameplay_effects(effects)
</file>

<file path="godot-coop/characters/player/player.gd">
extends CharacterBase


const JUMP_VELOCITY = 4.5
const ROTATION_SPEED = 10.0 # Velocidad de giro del personaje
var is_strafing = false

@onready var camera: Camera3D = $SpringArmPivot/Camera3D
@onready var mesh_instance_3d: MeshInstance3D = $MeshInstance3D
@onready var character_inventory_system: NetworkedCharacterInventorySystem = $CharacterInventorySystem

func _enter_tree() -> void:
	set_multiplayer_authority(name.to_int())
	$CharacterInventorySystem/Inventory/SyncInventory.set_multiplayer_authority(1)
	$CharacterInventorySystem/EquipmentInventory/SyncInventory.set_multiplayer_authority(1)
	%SyncHotbar.set_multiplayer_authority(1)
	$CharacterInventorySystem/CraftStation/SyncCraftStation.set_multiplayer_authority(1)
	#$Dropper.set_multiplayer_authority(1)
func _ready() -> void:
	#var Fireball = GameplayAbility.new()
	#attribute_set.grant_ability(Fireball, "ability.primary")
	pass
	#Input.mouse_mode = Input.MOUSE_MODE_CAPTURED

func _physics_process(delta: float) -> void:
	if !is_multiplayer_authority(): return
	if Input.is_action_just_pressed("aim"):
		is_strafing = true
	if Input.is_action_just_released("aim"):
		is_strafing = false
	
	if not is_on_floor():
		velocity += get_gravity() * delta

	if Input.is_action_just_pressed("ui_accept") and is_on_floor():
		velocity.y = JUMP_VELOCITY

	var input_dir := Input.get_vector("move_left", "move_right", "move_forward", "move_backward")
	var direction := Vector3(input_dir.x, 0, input_dir.y).normalized()
	
	# Rotamos el vector de direcciÃ³n segÃºn la cÃ¡mara
	direction = direction.rotated(Vector3.UP, camera.global_rotation.y)
	if is_strafing:
		mesh_instance_3d.global_rotation.y = camera.global_rotation.y
	
	if direction:
		velocity.x = direction.x * attribute_set.speed
		velocity.z = direction.z * attribute_set.speed
		
		# --- AQUÃ ESTÃ LA LÃ“GICA DE ROTACIÃ“N ---
		var target_rotation = atan2(direction.x, direction.z) + PI
		if not is_strafing:
			mesh_instance_3d.rotation.y = lerp_angle(mesh_instance_3d.rotation.y, target_rotation, delta * ROTATION_SPEED)

		
	else:
		velocity.x = move_toward(velocity.x, 0, attribute_set.speed)
		velocity.z = move_toward(velocity.z, 0, attribute_set.speed)

	move_and_slide()
func _input(event: InputEvent) -> void:
	# Only the local player controls input
	if not is_multiplayer_authority(): return
	
	# --- ABILITY INPUT MAPPING ---
	
	# Primary Attack (Left Click)
	if event.is_action_pressed("attack_primary"): # Or "throw" if you kept that name
		attribute_set.server_ability_input_pressed.rpc(AttributeSet.INPUT_PRIMARY)
		
	if event.is_action_released("attack_primary"):
		attribute_set.server_ability_input_released.rpc(AttributeSet.INPUT_PRIMARY)

	# Secondary Attack (Right Click - Aiming/Alt Fire)
	if event.is_action_pressed("attack_secondary"):
		attribute_set.server_ability_input_pressed.rpc(AttributeSet.INPUT_SECONDARY)
		
	if event.is_action_released("attack_secondary"):
		attribute_set.server_ability_input_released.rpc(AttributeSet.INPUT_SECONDARY)
		
	# You can add more mappings here (Reload, Jump, Ultimate...)
</file>

<file path="godot-coop/characters/player/components/attribute_set.gd">
class_name AttributeSet
extends Node

signal health_changed(new_value, max_value)
signal died()

# --- INPUT TAGS CONSTANTS ---
const INPUT_PRIMARY = "ability.primary"
const INPUT_SECONDARY = "ability.secondary"
const INPUT_RELOAD = "ability.reload"
const INPUT_JUMP = "ability.jump"

# ATRIBUTOS VÃLIDOS (Fuente de verdad)
const VALID_ATTRIBUTES: PackedStringArray = ["health", "max_health", "speed", "stamina", "mana"]

@export_group("Base Stats")
@export var base_max_health: float = 100.0
@export var base_speed: float = 5.0
@export var base_stamina: float = 50.0

# CURRENT STATS (Valores actuales)
var health: float:
	set(value):
		var current_max = get_total_stat("max_health")
		var old_health = health
		health = clamp(value, 0.0, current_max)
		
		# Solo disparamos la seÃ±al y el print si realmente cambiÃ³
		if health != old_health:
			print("[AttributeSet] HEALTH UPDATE: ", health, " / ", current_max)
			health_changed.emit(health, current_max)
			if health == 0.0:
				print("[AttributeSet] CHARACTER DIED!")
				died.emit()
var speed: float:
	get:
		return get_total_stat("speed")

#region Internal GAS classes


# GESTIÃ“N DE MODIFICADORES TEMPORALES
class ActiveEffect:
	var handle: EffectSpecHandle
	var source_effect: GameplayEffect
	var time_left: float
	var tick_timer: float
	
	func _init(p_handle: EffectSpecHandle, effect: GameplayEffect):
		handle = p_handle
		source_effect = effect
		time_left = effect.duration
		tick_timer = 0.0

# --- INTERNAL CLASS FOR GRANTED ABILITIES ---
class AbilitySpec:
	var handle: AbilitySpecHandle
	var ability: GameplayAbility # The resource definition
	var input_tag: String # The input slot (e.g., "ability.primary")
	var is_active: bool = false
	
	func _init(p_handle: AbilitySpecHandle, p_ability: GameplayAbility, p_input: String):
		handle = p_handle
		ability = p_ability
		input_tag = p_input

#endregion



var active_effect_registry: Dictionary = {}
var active_modifiers: Dictionary = {}
var active_periodic_effects: Array[ActiveEffect] = []
var granted_abilities: Dictionary = {}



func _ready() -> void:
	for attr in VALID_ATTRIBUTES:
		active_modifiers[attr] = []
	health = base_max_health
	print("[AttributeSet] Initialized. Starting Health: ", health)

func _process(delta: float) -> void:
	if not multiplayer.is_server(): return
	
	_process_periodic_effects(delta)
	_process_duration_modifiers(delta)

# --- 1. LÃ“GICA DE APLICACIÃ“N ---

#region Effect Functions

func apply_gameplay_effects(effects: Array[GameplayEffect]) -> Array[EffectSpecHandle]:
	if not multiplayer.is_server(): return []
	
	var created_handles: Array[EffectSpecHandle] = []
	
	for effect in effects:
		match effect.mode:
			GameplayEffect.ApplicationMode.INSTANT:
				# Instant effects don't need handles as they don't persist
				print("[AttributeSet] Applying INSTANT effect: '", effect.effect_name, "'")
				_apply_instant_change(effect)
				
			GameplayEffect.ApplicationMode.PERIODIC:
				var handle = _create_active_effect(effect)
				print("[AttributeSet] Added PERIODIC effect: '", effect.effect_name, "' Handle: ", handle)
				active_periodic_effects.append(active_effect_registry[handle])
				created_handles.append(handle)
				
			GameplayEffect.ApplicationMode.DURATION: # (And INFINITE/PASSIVE in the future)
				var handle = _create_active_effect(effect)
				print("[AttributeSet] Added DURATION modifier: '", effect.effect_name, "' Handle: ", handle)
				active_modifiers[effect.target_attribute].append(active_effect_registry[handle])
				_on_modifier_changed(effect.target_attribute)
				created_handles.append(handle)
	
	return created_handles

func remove_effect(handle: EffectSpecHandle) -> void:
	if not multiplayer.is_server(): return
	
	if not active_effect_registry.has(handle):
		print("[AttributeSet] Warning: Check to remove effect ", handle, " failed. Not found.")
		return
	
	var active_effect = active_effect_registry[handle]
	var source_data = active_effect.source_effect
	
	print("[AttributeSet] Removing effect manually: ", handle)
	
	# 1. Clean up from logic lists
	match source_data.mode:
		GameplayEffect.ApplicationMode.PERIODIC:
			active_periodic_effects.erase(active_effect)
			
		GameplayEffect.ApplicationMode.DURATION:
			var attr_name = source_data.target_attribute
			if active_modifiers.has(attr_name):
				active_modifiers[attr_name].erase(active_effect)
				_on_modifier_changed(attr_name) # Recalculate stats immediately
	
	# 2. Remove from central registry
	active_effect_registry.erase(handle)

#endregion


#region Ability Functions
func grant_ability(ability_res: GameplayAbility, input_tag: String = "") -> AbilitySpecHandle:
	if not multiplayer.is_server(): return null
	if ability_res == null: return null
	
	# 1. Generate the unique ID (Receipt)
	var handle = AbilitySpecHandle.new(ability_res.ability_name)
	
	# 2. Create the runtime specification (Instance data)
	var spec = AbilitySpec.new(handle, ability_res, input_tag)
	
	# 3. Store in the registry
	granted_abilities[handle] = spec
	
	print("[AttributeSet] Granted Ability: '", ability_res.ability_name, "' | Handle: ", handle, " | Input: ", input_tag)
	
	return handle

func clear_ability(handle: AbilitySpecHandle) -> void:
	if not multiplayer.is_server(): return
	
	if not granted_abilities.has(handle):
		print("[AttributeSet] Warning: Check to clear ability ", handle, " failed. Not found.")
		return
		
	var spec = granted_abilities[handle]
	
	# Force end if running
	if spec.is_active:
		# We pass 'get_parent()' assuming AttributeSet is child of CharacterBase
		spec.ability.end_ability(get_parent(), handle)
	
	granted_abilities.erase(handle)
	print("[AttributeSet] Cleared Ability: ", handle)



# RPC called by the client when a button is pressed
@rpc("any_peer", "call_local", "reliable")
func server_ability_input_pressed(input_tag: String) -> void:
	# Security check: Ensure logic runs only on server
	if not multiplayer.is_server(): return
	
	# Find abilities bound to this input tag
	for handle in granted_abilities:
		var spec: AbilitySpec = granted_abilities[handle]
		
		if spec.input_tag == input_tag:
			# Found a matching ability!
			# We assume 'get_parent()' is the CharacterBase (the Actor)
			var actor = get_parent()
			
			print("[AttributeSet] Input '", input_tag, "' triggered ability: ", spec.ability.ability_name)
			
			spec.is_active = true
			spec.ability.activate(actor, handle)

# RPC called by the client when a button is released
@rpc("any_peer", "call_local", "reliable")
func server_ability_input_released(input_tag: String) -> void:
	if not multiplayer.is_server(): return
	
	for handle in granted_abilities:
		var spec: AbilitySpec = granted_abilities[handle]
		
		if spec.input_tag == input_tag:
			# Notify the ability that input was released (useful for charged attacks, bows, etc)
			var actor = get_parent()
			spec.ability.input_released(actor, handle)
			# Note: We don't set is_active = false here automatically. 
			# The ability should decide when to end itself callind end_ability().


#endregion



# Helper to create the ActiveEffect and register it
func _create_active_effect(effect: GameplayEffect) -> EffectSpecHandle:
	var handle = EffectSpecHandle.new(effect.effect_name)
	var active = ActiveEffect.new(handle, effect)
	active_effect_registry[handle] = active
	return handle

# --- 2. CÃLCULO DE STATS TOTALES ---

func get_total_stat(stat_name: String) -> float:
	if stat_name == "health": return health 
	
	var base_val = get("base_" + stat_name)
	if base_val == null: return 0.0
	
	var final_value = base_val
	var multiplier = 1.0
	
	for active in active_modifiers[stat_name]:
		var eff = active.source_effect
		match eff.operation:
			GameplayEffect.ModifierOp.ADD: final_value += eff.value
			GameplayEffect.ModifierOp.SUBTRACT: final_value -= eff.value
			GameplayEffect.ModifierOp.MULTIPLY: multiplier *= eff.value
			GameplayEffect.ModifierOp.DIVIDE: if eff.value != 0: multiplier /= eff.value
			
	return final_value * multiplier

# --- 3. MANEJO INTERNO DE EFECTOS ---

func _apply_instant_change(effect: GameplayEffect) -> void:
	var val = effect.value
	if effect.operation == GameplayEffect.ModifierOp.SUBTRACT: val = -val
	
	if effect.target_attribute == "health":
		var old_h = health
		self.health += val
		print("[AttributeSet] Instant change applied: ", effect.value, " | Health went from ", old_h, " to ", health)
	else:
		printerr("[AttributeSet] WARNING: INSTANT effects are usually for current stats (health, mana). Check effect: ", effect.effect_name)

func _on_modifier_changed(stat_name: String) -> void:
	print("[AttributeSet] Recalculating TOTAL stat for: ", stat_name, " | New Total: ", get_total_stat(stat_name))
	if stat_name == "max_health":
		self.health = self.health 

func _process_periodic_effects(delta: float) -> void:
	for i in range(active_periodic_effects.size() - 1, -1, -1):
		var active = active_periodic_effects[i]
		active.time_left -= delta
		active.tick_timer += delta
		
		if active.tick_timer >= active.source_effect.tick_rate:
			active.tick_timer = 0.0
			_apply_instant_change(active.source_effect)
			
		if active.time_left <= 0:
			# Cleanup
			active_effect_registry.erase(active.handle) # <--- REMOVE FROM REGISTRY
			active_periodic_effects.remove_at(i)

func _process_duration_modifiers(delta: float) -> void:
	for attr in active_modifiers.keys():
		var modifiers_list = active_modifiers[attr]
		var changed = false
		for i in range(modifiers_list.size() - 1, -1, -1):
			var active = modifiers_list[i]
			active.time_left -= delta
			if active.time_left <= 0:
				# Cleanup
				active_effect_registry.erase(active.handle) # <--- REMOVE FROM REGISTRY
				modifiers_list.remove_at(i)
				changed = true
		
		if changed:
			_on_modifier_changed(attr)
</file>

<file path="godot-coop/items/world_models/potions/fire_potion_projectile.gd">
extends ProjectileBase

class_name PotionProjectile
var has_exploded: bool = false
var hit_targets: Array = []

func on_inpact(body: Node) -> void:
	if has_exploded:
		return
	if multiplayer.is_server():
		trigger_explosion_sequence()
	

func trigger_explosion_sequence() -> void:
	has_exploded = true
	freeze = true
	area_effect.monitoring = true
	
	### GAME LOGIC
	apply_area_effects()
	
	### VFX/SFX
	play_impact_effects.rpc()
	
	get_tree().create_timer(data.area_effect_duration).timeout.connect(on_effect_finished)
	

		
		

func apply_area_effects() -> void:

	var radius = data.blast_radius
	var shape = $AreaEffect/ExplosionShape.shape as SphereShape3D
	if shape:
		shape.radius = radius


func _apply_specific_effect(target: Node) -> void:
	if target.has_method("receive_gameplay_effects"):
		target.receive_gameplay_effects(data.effects)


func _on_timer_timeout() -> void:
	contact_monitor = true

@rpc("authority", "call_local", "reliable")
func play_impact_effects() -> void:
	visuals.visible = false
	$PhysicsShape.disabled = true
	impact_particles.emitting = true
	impact_sound.play()


func _on_area_effect_area_entered(area: Area3D) -> void:
	if not multiplayer.is_server(): return
	var target = area.get_parent()
	if target in hit_targets:
		return
	if not target.has_method("receive_gameplay_effects"): return
	hit_targets.append(target)
	
	_apply_specific_effect(target)

func on_effect_finished() -> void:
	area_effect.monitoring = false
	queue_free()
</file>

</files>
