This file is a merged representation of a subset of the codebase, containing specifically included files, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: godot-coop/characters/character_base.gd, godot-coop/characters/common_components/gas/ability_manager.gd, godot-coop/characters/common_components/gas/ability_system_component.gd, godot-coop/characters/common_components/gas/attribute_set.gd, godot-coop/characters/common_components/gas/cast_manager.gd, godot-coop/characters/common_components/gas/effect_manager.gd, godot-coop/characters/common_components/gas/tag_container.gd, godot-coop/characters/common_components/tag_reaction_component.gd, godot-coop/characters/npcs/human_dummy/human_npc.gd, godot-coop/characters/player/components/camera_follow.gd, godot-coop/characters/player/components/camera_spring_arm.gd, godot-coop/characters/player/components/coop_character_inventory_system.gd, godot-coop/characters/player/components/coop_character_inventory_system_ui.gd, godot-coop/characters/player/equipment_manager.gd, godot-coop/characters/player/player.gd, godot-coop/characters/test_tag_reaction_component.gd, godot-coop/interactables/harvest_nodes/harvestable.gd, godot-coop/interactables/harvest_nodes/harvestable_data.gd, godot-coop/interactables/interactable_base.gd, godot-coop/interactables/items/ingredients/ingredient_base.gd, godot-coop/interactables/items/item_base.gd, godot-coop/interactables/loot_container/loot_container.gd, godot-coop/interactables/loot_container/loot_container_data.gd, godot-coop/interactables/loot_container/search_constraint.gd, godot-coop/items/abilities/ga_aim.gd, godot-coop/items/abilities/ga_drink_potion.gd, godot-coop/items/abilities/ga_throw_projectile.gd, godot-coop/items/definitions/ability_grant.gd, godot-coop/items/definitions/ability_spec_handle.gd, godot-coop/items/definitions/effect_spec_handle.gd, godot-coop/items/definitions/equipment_data.gd, godot-coop/items/definitions/gameplay_ability.gd, godot-coop/items/definitions/gameplay_effect.gd, godot-coop/items/definitions/potion_data.gd, godot-coop/items/definitions/projectiles/fire_potion_projectile.gd, godot-coop/items/definitions/projectiles/projectile_base.gd, godot-coop/levels/maps/main.gd, godot-coop/systems/inventory/equipment_slot_constraint.gd, godot-coop/systems/inventory/inventory_system_manager.gd, godot-coop/systems/log_helper/Logger.gd, godot-coop/systems/multiplayer_spawner.gd, godot-coop/systems/network_manager.gd, godot-coop/systems/projectile_spawner.gd, godot-coop/test/unit-test/test_ability_manager.gd, godot-coop/test/unit-test/test_cast_manager.gd, godot-coop/test/unit-test/test_data_equipment.gd, godot-coop/test/unit-test/test_data_gameplay_ability.gd, godot-coop/test/unit-test/test_data_gameplay_effect.gd, godot-coop/test/unit-test/test_data_integrity.gd, godot-coop/test/unit-test/test_data_potion.gd, godot-coop/test/unit-test/test_effect_manager.gd, godot-coop/test/unit-test/test_tag_container.gd, godot-coop/addons/inventory-system-demos/interaction_system/inventory_interactor.gd, godot-coop/addons/inventory-system-demos/interaction_system/interact_action.gd, godot-coop/addons/inventory-system-demos/fps/box_inventory.gd, godot-coop/addons/inventory-system-demos/fps/campfire.gd, godot-coop/addons/inventory-system-demos/fps/constraints/category_grid_inventory_constraint.gd, godot-coop/addons/inventory-system-demos/fps/constraints/stack_size_constraint.gd, godot-coop/addons/inventory-system-demos/fps/dropper.gd, godot-coop/addons/inventory-system-demos/fps/fps_demo.gd, godot-coop/addons/inventory-system-demos/fps/loot_box_inventory.gd, godot-coop/addons/inventory-system-demos/fps/modding_demo.gd, godot-coop/addons/inventory-system-demos/fps/player.gd, godot-coop/addons/inventory-system-demos/fps/props/shelf.gd, godot-coop/addons/inventory-system-demos/fps/props/visual_inventory_3d.gd, godot-coop/addons/inventory-system-demos/fps/props/visual_slot_3d.gd, godot-coop/addons/inventory-system-demos/fps/tool_hand_item_3d.gd, godot-coop/addons/inventory-system-demos/fps/use_items_example.gd, godot-coop/addons/inventory-system-demos/fps/workbench.gd, godot-coop/addons/inventory-system-demos/mp/sync_grid_inventory.gd, godot-coop/addons/inventory-system-demos/mp/sync_hotbar.gd, godot-coop/addons/inventory-system-demos/mp/sync_craft_station.gd, godot-coop/addons/inventory-system-demos/mp/placeable_item_spawner.gd, godot-coop/addons/inventory-system-demos/mp/networked_workbench.gd, godot-coop/addons/inventory-system-demos/mp/networked_use_items_example_3d.gd, godot-coop/addons/inventory-system-demos/mp/networked_shelf.gd, godot-coop/addons/inventory-system-demos/mp/networked_object_placer.gd, godot-coop/addons/inventory-system-demos/mp/networked_dropper.gd, godot-coop/addons/inventory-system-demos/mp/networked_character_inventory_system.gd, godot-coop/addons/inventory-system-demos/mp/networked_campfire.gd, godot-coop/addons/inventory-system-demos/mp/networked_box_inventory.gd, godot-coop/addons/inventory-system-demos/mp/mp_player.gd, godot-coop/addons/inventory-system-demos/mp/mp_demo.gd, godot-coop/addons/inventory-system-demos/mp/lag_test.gd, godot-coop/addons/inventory-system-demos/mp/dropped_item_spawner.gd, godot-coop/addons/inventory-system-demos/ui/inventory_system_ui.gd, godot-coop/addons/inventory-system-demos/ui/drop_area.gd, godot-coop/addons/inventory-system-demos/ui/craft/recipe_ui.gd, godot-coop/addons/inventory-system-demos/ui/craft/ingredient_ui.gd, godot-coop/addons/inventory-system-demos/ui/craft/craftings_ui.gd, godot-coop/addons/inventory-system-demos/ui/craft/crafting_ui.gd, godot-coop/addons/inventory-system-demos/ui/craft/craft_station_ui.gd, godot-coop/addons/inventory-system-demos/ui/interactor/interactor_ui.gd, godot-coop/addons/inventory-system-demos/ui/interactor/input_icons.gd, godot-coop/addons/inventory-system-demos/ui/interactor/input_helper.gd, godot-coop/addons/inventory-system-demos/ui/interactor/action_message_ui.gd, godot-coop/addons/inventory-system-demos/ui/hotbar/hotbar_ui.gd, godot-coop/addons/inventory-system-demos/ui/hotbar/hotbar_slot_ui.gd, godot-coop/addons/inventory-system-demos/ui/grid/grid_slot_ui.gd, godot-coop/addons/inventory-system-demos/ui/grid/grid_selection_panel.gd, godot-coop/addons/inventory-system-demos/ui/grid/grid_item_stack_ui.gd, godot-coop/addons/inventory-system-demos/ui/grid/grid_inventory_ui.gd, godot-coop/addons/inventory-system-demos/ui/grid/grid_inventory_panel.gd, godot-coop/addons/inventory-system-demos/ui/grid/grid_drop_zone_ui.gd, godot-coop/addons/inventory-system-demos/ui/grid/grid_draggable_element_ui.gd, godot-coop/addons/inventory-system-demos/character/character_inventory_system.gd, godot-coop/addons/inventory-system-demos/character/hand_item_holder_3d.gd, godot-coop/addons/inventory-system-demos/character/networked_openable.gd, godot-coop/addons/inventory-system-demos/character/openable.gd
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
godot-coop/addons/inventory-system-demos/character/character_inventory_system.gd
godot-coop/addons/inventory-system-demos/character/hand_item_holder_3d.gd
godot-coop/addons/inventory-system-demos/character/networked_openable.gd
godot-coop/addons/inventory-system-demos/character/openable.gd
godot-coop/addons/inventory-system-demos/fps/box_inventory.gd
godot-coop/addons/inventory-system-demos/fps/campfire.gd
godot-coop/addons/inventory-system-demos/fps/constraints/category_grid_inventory_constraint.gd
godot-coop/addons/inventory-system-demos/fps/constraints/stack_size_constraint.gd
godot-coop/addons/inventory-system-demos/fps/dropper.gd
godot-coop/addons/inventory-system-demos/fps/fps_demo.gd
godot-coop/addons/inventory-system-demos/fps/loot_box_inventory.gd
godot-coop/addons/inventory-system-demos/fps/modding_demo.gd
godot-coop/addons/inventory-system-demos/fps/player.gd
godot-coop/addons/inventory-system-demos/fps/props/shelf.gd
godot-coop/addons/inventory-system-demos/fps/props/visual_inventory_3d.gd
godot-coop/addons/inventory-system-demos/fps/props/visual_slot_3d.gd
godot-coop/addons/inventory-system-demos/fps/tool_hand_item_3d.gd
godot-coop/addons/inventory-system-demos/fps/use_items_example.gd
godot-coop/addons/inventory-system-demos/fps/workbench.gd
godot-coop/addons/inventory-system-demos/interaction_system/interact_action.gd
godot-coop/addons/inventory-system-demos/interaction_system/inventory_interactor.gd
godot-coop/addons/inventory-system-demos/mp/dropped_item_spawner.gd
godot-coop/addons/inventory-system-demos/mp/lag_test.gd
godot-coop/addons/inventory-system-demos/mp/mp_demo.gd
godot-coop/addons/inventory-system-demos/mp/mp_player.gd
godot-coop/addons/inventory-system-demos/mp/networked_box_inventory.gd
godot-coop/addons/inventory-system-demos/mp/networked_campfire.gd
godot-coop/addons/inventory-system-demos/mp/networked_character_inventory_system.gd
godot-coop/addons/inventory-system-demos/mp/networked_dropper.gd
godot-coop/addons/inventory-system-demos/mp/networked_object_placer.gd
godot-coop/addons/inventory-system-demos/mp/networked_shelf.gd
godot-coop/addons/inventory-system-demos/mp/networked_use_items_example_3d.gd
godot-coop/addons/inventory-system-demos/mp/networked_workbench.gd
godot-coop/addons/inventory-system-demos/mp/placeable_item_spawner.gd
godot-coop/addons/inventory-system-demos/mp/sync_craft_station.gd
godot-coop/addons/inventory-system-demos/mp/sync_grid_inventory.gd
godot-coop/addons/inventory-system-demos/mp/sync_hotbar.gd
godot-coop/addons/inventory-system-demos/ui/craft/craft_station_ui.gd
godot-coop/addons/inventory-system-demos/ui/craft/crafting_ui.gd
godot-coop/addons/inventory-system-demos/ui/craft/craftings_ui.gd
godot-coop/addons/inventory-system-demos/ui/craft/ingredient_ui.gd
godot-coop/addons/inventory-system-demos/ui/craft/recipe_ui.gd
godot-coop/addons/inventory-system-demos/ui/drop_area.gd
godot-coop/addons/inventory-system-demos/ui/grid/grid_draggable_element_ui.gd
godot-coop/addons/inventory-system-demos/ui/grid/grid_drop_zone_ui.gd
godot-coop/addons/inventory-system-demos/ui/grid/grid_inventory_panel.gd
godot-coop/addons/inventory-system-demos/ui/grid/grid_inventory_ui.gd
godot-coop/addons/inventory-system-demos/ui/grid/grid_item_stack_ui.gd
godot-coop/addons/inventory-system-demos/ui/grid/grid_selection_panel.gd
godot-coop/addons/inventory-system-demos/ui/grid/grid_slot_ui.gd
godot-coop/addons/inventory-system-demos/ui/hotbar/hotbar_slot_ui.gd
godot-coop/addons/inventory-system-demos/ui/hotbar/hotbar_ui.gd
godot-coop/addons/inventory-system-demos/ui/interactor/action_message_ui.gd
godot-coop/addons/inventory-system-demos/ui/interactor/input_helper.gd
godot-coop/addons/inventory-system-demos/ui/interactor/input_icons.gd
godot-coop/addons/inventory-system-demos/ui/interactor/interactor_ui.gd
godot-coop/addons/inventory-system-demos/ui/inventory_system_ui.gd
godot-coop/characters/character_base.gd
godot-coop/characters/common_components/gas/ability_manager.gd
godot-coop/characters/common_components/gas/ability_system_component.gd
godot-coop/characters/common_components/gas/attribute_set.gd
godot-coop/characters/common_components/gas/cast_manager.gd
godot-coop/characters/common_components/gas/effect_manager.gd
godot-coop/characters/common_components/gas/tag_container.gd
godot-coop/characters/common_components/tag_reaction_component.gd
godot-coop/characters/npcs/human_dummy/human_npc.gd
godot-coop/characters/player/components/camera_follow.gd
godot-coop/characters/player/components/camera_spring_arm.gd
godot-coop/characters/player/components/coop_character_inventory_system_ui.gd
godot-coop/characters/player/components/coop_character_inventory_system.gd
godot-coop/characters/player/equipment_manager.gd
godot-coop/characters/player/player.gd
godot-coop/characters/test_tag_reaction_component.gd
godot-coop/interactables/harvest_nodes/harvestable_data.gd
godot-coop/interactables/harvest_nodes/harvestable.gd
godot-coop/interactables/interactable_base.gd
godot-coop/interactables/items/ingredients/ingredient_base.gd
godot-coop/interactables/items/item_base.gd
godot-coop/interactables/loot_container/loot_container_data.gd
godot-coop/interactables/loot_container/loot_container.gd
godot-coop/interactables/loot_container/search_constraint.gd
godot-coop/items/abilities/ga_aim.gd
godot-coop/items/abilities/ga_drink_potion.gd
godot-coop/items/abilities/ga_throw_projectile.gd
godot-coop/items/definitions/ability_grant.gd
godot-coop/items/definitions/ability_spec_handle.gd
godot-coop/items/definitions/effect_spec_handle.gd
godot-coop/items/definitions/equipment_data.gd
godot-coop/items/definitions/gameplay_ability.gd
godot-coop/items/definitions/gameplay_effect.gd
godot-coop/items/definitions/potion_data.gd
godot-coop/items/definitions/projectiles/fire_potion_projectile.gd
godot-coop/items/definitions/projectiles/projectile_base.gd
godot-coop/levels/maps/main.gd
godot-coop/systems/inventory/equipment_slot_constraint.gd
godot-coop/systems/inventory/inventory_system_manager.gd
godot-coop/systems/log_helper/Logger.gd
godot-coop/systems/multiplayer_spawner.gd
godot-coop/systems/network_manager.gd
godot-coop/systems/projectile_spawner.gd
godot-coop/test/unit-test/test_ability_manager.gd
godot-coop/test/unit-test/test_cast_manager.gd
godot-coop/test/unit-test/test_data_equipment.gd
godot-coop/test/unit-test/test_data_gameplay_ability.gd
godot-coop/test/unit-test/test_data_gameplay_effect.gd
godot-coop/test/unit-test/test_data_integrity.gd
godot-coop/test/unit-test/test_data_potion.gd
godot-coop/test/unit-test/test_effect_manager.gd
godot-coop/test/unit-test/test_tag_container.gd
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="godot-coop/addons/inventory-system-demos/character/networked_openable.gd">
class_name NetworkedOpenable
extends Openable


func _ready() -> void:
	if Engine.is_editor_hint():
		return
	multiplayer.peer_connected.connect(_on_connected.bind())
	opened.connect(_on_opened.bind())
	closed.connect(_on_closed.bind())


func _on_connected(id):
	if not multiplayer.is_server():
		return
	if is_open:
		_opened_rpc.rpc_id(id)

func _on_opened(character : Node):
	if not multiplayer.is_server():
		return
	_opened_rpc.rpc(character.get_path())


func _on_closed(character : Node):
	if not multiplayer.is_server():
		return
	_closed_rpc.rpc(character.get_path())


@rpc
func _opened_rpc(character_node_path : NodePath):
	if multiplayer.is_server():
		return
	is_open = true
	opened.emit(get_node(character_node_path))


@rpc
func _closed_rpc(character_node_path : NodePath):
	if multiplayer.is_server():
		return
	is_open = false
	closed.emit(get_node(character_node_path))
</file>

<file path="godot-coop/addons/inventory-system-demos/character/openable.gd">
extends Node
class_name Openable

signal opened(character : Node)
signal closed(character : Node)

@export var is_open : bool

var characters : Array[Node] = []

func open(character : Node):
	if is_open:
		return
	characters.append(character)
	is_open = true
	opened.emit(character)

func close(character : Node):
	if !is_open:
		return
	var index = characters.find(character)
	if index == -1:
		return
	characters.remove_at(index)
	if not characters.is_empty():
		return
	is_open = false
	closed.emit(character)
</file>

<file path="godot-coop/addons/inventory-system-demos/fps/box_inventory.gd">
class_name BoxInventory
extends Node3D

const Interactor = preload("../interaction_system/inventory_interactor.gd")

@onready var inventory : Inventory = $Inventory
@export var actions : Array
@onready var openable : Openable = $Openable
@export var constraints : Array[GridInventoryConstraint]

func _ready():
	openable.closed.connect(_on_openable_closed)
	openable.opened.connect(_on_openable_opened)
	inventory.grid_constraints = constraints

func get_inventory() -> Inventory:
	return $Inventory


func _on_inventory_opened():
	_on_open()


func _on_open():
	$box.visible = false
	$boxOpen.visible = true
	$Open.play()


func _on_close():
	$box.visible = true
	$boxOpen.visible = false
	$Close.play()


func get_interaction_position(_interaction_point : Vector3) -> Vector3:
	return position


func get_interact_actions(_interactor : Interactor) -> Array:
	if openable.is_open:
		return []
	return actions


func interact(character : Node, _action_index : int = 0):
	if !openable.is_open:
		character.character_inventory_system.open_inventory(inventory)
		open(character)


func open(character : Node):
	openable.open(character)


func close(character : Node):
	openable.close(character)


func _on_openable_opened(_character: Node) -> void:
	_on_open()


func _on_openable_closed(_character: Node) -> void:
	_on_close()
</file>

<file path="godot-coop/addons/inventory-system-demos/fps/campfire.gd">
class_name Campfire
extends Workbench

signal changed_burning_state(is_burning : bool)

@export var burnable_category : String = "burnables"
@onready var gpu_particles_3d = $Node/GPUParticles3D
@onready var audio_stream_player_3d = $Node/AudioStreamPlayer3D
@onready var craft_audio = $Node/CraftAudio
@export var toggle_fire_action : InteractAction

@export var decrease_fuel_multiplier = 1

var active_fire : bool = true:
	set(value):
		active_fire = value
		if value:
			is_burning = fuel > 0.0
		else:
			is_burning = false


var fuel := 0.0:
	set(new_value):
		fuel = new_value
		is_burning = fuel > 0.0

var max_seconds := 120.0

var is_burning := false:
	set(new_value):
		if is_burning != new_value:
			is_burning = new_value
			check()
			changed_burning_state.emit(is_burning)
			_update_is_burning()


func _ready():
	_update_is_burning()
	craft_station.on_crafted.connect(_on_crafted)
	input_inventory.contents_changed.connect(_on_input_inventory_contents_changed)


func _update_is_burning():
	$Node.visible = is_burning
	craft_station.auto_craft = is_burning
	craft_station.can_processing_craftings = is_burning
	audio_stream_player_3d.playing = is_burning


func _on_input_inventory_contents_changed():
	check()


func _on_crafted(_recipe_index: int):
	craft_audio.play(1.0)


func check() -> bool:
	if not active_fire:
		return false
	if is_burning:
		return false
	var category = input_inventory.database.get_category_from_id(burnable_category)
	if not input_inventory.contains_category(category):
		return false
	var index = input_inventory.get_stack_index_with_an_item_of_category(category)
	if index == -1:
		return false
	var item_id = input_inventory.stacks[index].item_id
	var definition = input_inventory.database.get_item(item_id)
	if not definition.properties.has("fuel"):
		return false
	fuel += definition.properties["fuel"]
	input_inventory.remove(item_id)
	return true


func _process(delta):
	if not active_fire:
		return
	if fuel > 0.0:
		fuel -= delta * decrease_fuel_multiplier


func get_interaction_position(_interaction_point : Vector3) -> Vector3:
	return position


func get_interact_actions(_interactor : Interactor) -> Array:
	if openable.is_open:
		return []
	var current_actions : Array = self.actions.duplicate()
	if fuel > 0.0:
		if active_fire:
			toggle_fire_action.description = "Disable Fire"
		else:
			toggle_fire_action.description = "Enable Fire"
		current_actions.append(toggle_fire_action)
	return current_actions


func interact(_character : Node, action_index : int = 0):
	if action_index == 0 and !openable.is_open:
		_character.character_inventory_system.open_inventory(craft_station.get_input_inventory())
		#craft_station.load_valid_recipes()
		openable.open(_character)
	else:
		active_fire = !active_fire
</file>

<file path="godot-coop/addons/inventory-system-demos/fps/constraints/category_grid_inventory_constraint.gd">
extends GridInventoryConstraint
class_name CategoryGridInventoryConstraint

@export var category_position: Dictionary
@export var is_only_one_category_for_slots: bool
@export var one_category_for_slots: String

func _can_add_on_position(inventory: Node, position: Vector2i, item_id: String, _amount: int, _properties: Dictionary, _is_rotated: bool):
	var def: ItemDefinition = inventory.database.get_item(item_id)
	if def == null:
		return false

	var size: Vector2i
	if _is_rotated:
		size = Vector2i(def.size.y, def.size.x)
	else:
		size = def.size

	for x in range(position.x,position.x + size.x):
		for y in range(position.y,position.y + size.y):
			var pos = Vector2i(x, y)
			var category: String = get_category(pos)
			if not contains_category(def, category):
				return false
	return true


func contains_category(def: ItemDefinition, category: String):
	if category != "":
		for c in def.categories:
			if c.id == category:
				return true
		return false
	else:
		return true

func get_category(position: Vector2i) -> String:
	if is_only_one_category_for_slots:
		return one_category_for_slots
	else:
		if category_position.has(position):
			var category : String = category_position[position]
			return category
		return ""
</file>

<file path="godot-coop/addons/inventory-system-demos/fps/constraints/stack_size_constraint.gd">
extends InventoryConstraint
class_name StackSizeConstraint

@export var max_size_stack: int = 2

func _can_add_new_stack_on_inventory(inventory: Node, _item_id: String, _amount: int, _properties: Dictionary) -> bool:
	if inventory.stacks.size() >= max_size_stack:
		return false
	return true

func _get_max_stack(_inventory: Node, item_id: String, _amount: int, _properties: Dictionary, max_stack: int) -> int:
	if item_id == "wood":
		return 32
	return max_stack
</file>

<file path="godot-coop/addons/inventory-system-demos/fps/dropper.gd">
extends Node3D
class_name Dropper

signal dropped(node : Node)

@export var inventories: Array[Inventory]
@export var database: InventoryDatabase
@export var dropped_item_property_name: String = "dropped_item"


func _ready() -> void:
	for inventory in inventories:
		inventory.request_drop_item.connect(drop)


func drop(item: String, amount:int = 1, properties: Dictionary = {}):
	var def = database.get_item(item)
	if def == null:
		return
	if not def.properties.has(dropped_item_property_name):
		return
	var obj = def.properties[dropped_item_property_name]
	if obj == null:
		return
	_on_request_drop_obj(obj, item, amount, properties)


func _on_request_drop_obj(dropped_item : String, item_id: String, amount: int, properties: Dictionary):
	var _database: InventoryDatabase = inventories[0].database
	var packed_scene : PackedScene = load(dropped_item)
	var node = packed_scene.instantiate()
	get_parent().get_parent().add_child(node)
	node.set("item_id", item_id)
	node.set("amount", amount)
	node.position = global_position
	node.set("rotation", global_rotation)
	node.set("item_properties", properties)
	dropped.emit(node)
</file>

<file path="godot-coop/addons/inventory-system-demos/fps/fps_demo.gd">
class_name FPSDemo
extends Node

@export var database : InventoryDatabase

var main_inventory : Inventory

func _ready():
	$"UI/Inventory System UI".setup($"Player/CharacterInventorySystem")
	main_inventory = $"Player/CharacterInventorySystem".main_inventory
	main_inventory.add("workbench", 1)
	main_inventory.add("helmet_labor", 1)
	main_inventory.add("wood", 16)
	main_inventory.add("stone", 8)

#
func _process(_delta):
	pass
	if Input.is_action_just_released("add_item_a"):
		main_inventory.add("wood", 1)
	if Input.is_action_just_released("remove_item_a"):
		main_inventory.remove("wood", 1)

	if Input.is_action_just_released("add_item_b"):
		main_inventory.add("stone", 1)
	if Input.is_action_just_released("remove_item_b"):
		main_inventory.remove("stone", 1)
#
	if Input.is_action_just_released("add_item_c"):
		main_inventory.add("grass", 1)
	if Input.is_action_just_released("remove_item_c"):
		main_inventory.remove("grass", 1)
</file>

<file path="godot-coop/addons/inventory-system-demos/fps/modding_demo.gd">
extends Node

@export var database : InventoryDatabase
@export var modding_file_path : String

func _ready() -> void:
	database.import_json_file(modding_file_path)
</file>

<file path="godot-coop/addons/inventory-system-demos/fps/player.gd">
class_name Player
extends CharacterBody3D

const SPEED = 5.0
const JUMP_VELOCITY = 4.5

# Get the gravity from the project settings to be synced with RigidBody nodes.
var gravity = ProjectSettings.get_setting("physics/3d/default_gravity")

@export var mouse_sensitivity := 0.002
@export var vertical_angle_limit := 90.0
var rot := Vector3()
@onready var character_inventory_system : CharacterInventorySystem = $CharacterInventorySystem
@onready var raycast : RayCast3D = $Camera3D/RayCast3D
@onready var camera_3d : Camera3D = $Camera3D

@export_group("ðŸ”Š Audios")
@export_node_path("AudioStreamPlayer3D") var picked_audio_path := NodePath("PickupAudio")
@onready var picked_audio : AudioStreamPlayer3D = get_node(picked_audio_path)
@export_node_path("AudioStreamPlayer3D") var drop_audio_path := NodePath("DropAudio")
@onready var drop_audio : AudioStreamPlayer3D = get_node(drop_audio_path)
@export_node_path("AudioStreamPlayer3D") var hotbar_change_audio_path := NodePath("HotbarChangeAudio")
@onready var hotbar_change_audio : AudioStreamPlayer3D = get_node(hotbar_change_audio_path)
@export_node_path("AudioStreamPlayer3D") var player_inventory_open_audio_path := NodePath("PlayerInventoryOpenAudio")
@onready var player_inventory_open_audio : AudioStreamPlayer3D = get_node(player_inventory_open_audio_path)
@export_node_path("AudioStreamPlayer3D") var player_inventory_close_audio_path := NodePath("PlayerInventoryCloseAudio")
@onready var player_inventory_close_audio : AudioStreamPlayer3D = get_node(player_inventory_close_audio_path)


func _ready():
	# Setup for audios ðŸ”Š
	character_inventory_system.picked.connect(_on_inventory_handler_picked)
	character_inventory_system.opened_inventory.connect(_on_player_inventory_opened)
	character_inventory_system.closed_inventory.connect(_on_player_inventory_closed)
	#character_inventory_system.hotbar.on_change_selection.connect(_on_hotbar_changed)


func _on_inventory_handler_picked(_dropped_item):
	picked_audio.play()


func _on_player_inventory_opened(_inventory : Inventory):
	player_inventory_open_audio.play()


func _on_player_inventory_closed(_inventory : Inventory):
	player_inventory_close_audio.play()


func _on_hotbar_changed(_selection : int):
	hotbar_change_audio.play()


func _physics_process(delta):
	# Add the gravity.
	if not is_on_floor():
		velocity.y -= gravity * delta

	# Handle Jump.
	if Input.is_action_just_pressed("jump_move") and is_on_floor():
		velocity.y = JUMP_VELOCITY

	# Get the input direction and handle the movement/deceleration.
	# As good practice, you should replace UI actions with custom gameplay actions.
	var input_dir = Input.get_vector("left_move", "right_move", "forward_move", "back_move")
	var direction = (transform.basis * Vector3(input_dir.x, 0, input_dir.y)).normalized()
	if direction and Input.get_mouse_mode() == Input.MOUSE_MODE_CAPTURED:
		velocity.x = direction.x * SPEED
		velocity.z = direction.z * SPEED
	else:
		velocity.x = move_toward(velocity.x, 0, SPEED)
		velocity.z = move_toward(velocity.z, 0, SPEED)

	move_and_slide()


func _input(event: InputEvent) -> void:
	# Mouse look (only if the mouse is captured).
	if event is InputEventMouseMotion and Input.get_mouse_mode() == Input.MOUSE_MODE_CAPTURED:
		rotate_camera(event.relative)


func rotate_camera(mouse_axis : Vector2) -> void:
	# Horizontal mouse look.
	rot.y -= mouse_axis.x * mouse_sensitivity
	# Vertical mouse look.
	rot.x = clamp(rot.x - mouse_axis.y * mouse_sensitivity, -vertical_angle_limit, vertical_angle_limit)

	rotation.y = rot.y
	$Camera3D.rotation.x = rot.x
</file>

<file path="godot-coop/addons/inventory-system-demos/fps/props/shelf.gd">
class_name Shelf
extends BoxInventory

@onready var visual_inventory_3d : VisualInventory = $VisualInventory3D


var slot_index : int = -1
var actions_shelf : Array

func _on_open():
	pass


func _on_close():
	pass


func get_interaction_position(interaction_point : Vector3) -> Vector3:
	var near_distance : float = 2500
	var near_position : Vector3 = global_position
	slot_index = -1
	for i in visual_inventory_3d.visual_slots.size():
		var visual_slot = visual_inventory_3d.visual_slots[i]
		var p = interaction_point.distance_squared_to(visual_slot.global_position)
		if p < near_distance:
			near_distance = p
			near_position = visual_slot.global_position
			slot_index = i
	return near_position

func interact_with_slot(character : Node, action_index : int = 0, actual_slot_index := 0):
	if openable.is_open:
		return
	var interactor = character.character_inventory_system.interactor
	var item_id = interactor.hotbar.get_selected_item()
	var definition = interactor.hotbar.database.get_item(item_id)
	var char_inventory = character.character_inventory_system.main_inventory
	var char_slot_index = interactor.hotbar.selection_index
	if action_index == 0:
		super.interact(character, action_index)
	if action_index == 1:
		var shelf_item_id = get_actual_item(actual_slot_index)
		var shelf_item_definition = interactor.hotbar.database.get_item(shelf_item_id)
		if shelf_item_definition != null:
			inventory.transfer_at(actual_slot_index, char_inventory, char_slot_index)
		return
	if action_index == 2:
		if definition != null:
			char_inventory.transfer_at(char_slot_index, inventory, actual_slot_index)
		return

func interact(character : Node, action_index : int = 0):
	interact_with_slot(character, action_index, slot_index)


func get_actual_item(actual_stack_index):
	if actual_stack_index != -1:
		return inventory.stacks[actual_stack_index].item_id
	return null


func get_interact_actions(interactor : Interactor) -> Array:
	actions_shelf.clear()
	if openable.is_open:
		return actions_shelf
	actions_shelf.append_array(actions)
	var shelf_item_id = get_actual_item(slot_index)
	var shelf_definition = inventory.database.get_item(shelf_item_id)
	if shelf_item_id != null and shelf_definition != null:
		var action = InteractAction.new()
		action.description = "Get " + shelf_definition.name
		action.input = "item_pickup"
		action.code = 1
		actions_shelf.append(action)
	var item_id : String = interactor.hotbar.get_selected_item()
	var definition = inventory.database.get_item(item_id)
	if item_id != "" and definition != null and (shelf_definition == null or shelf_definition == definition):
		var action = InteractAction.new()
		action.description = "Place " + definition.name
		action.input = "item_place"
		action.code = 2
		actions_shelf.append(action)
	return actions_shelf
</file>

<file path="godot-coop/addons/inventory-system-demos/fps/props/visual_inventory_3d.gd">
class_name VisualInventory
extends Node3D

@export var visual_slots_paths : Array[NodePath]
@export var visual_slots : Array[VisualSlot3D]
@export var property_name_of_visual = "visual_3d"
@onready var inventory = $"../Inventory"


func _ready():
	for path in visual_slots_paths:
		var visual_slot : VisualSlot3D = get_node(path)
		visual_slots.append(visual_slot)
	for i in visual_slots.size():
		var visual_slot = visual_slots[i]
		visual_slot.setup(inventory, i, property_name_of_visual)
</file>

<file path="godot-coop/addons/inventory-system-demos/fps/props/visual_slot_3d.gd">
class_name VisualSlot3D
extends Node3D

@export_node_path("Node3D") var default_hand_item_object_path = NodePath("DefaultItem3D")
@onready var default_hand_item_object := get_node(default_hand_item_object_path)
@export var distance_for_stack : float = 0.05

var property_name_of_visual : String
var last_item_id : String = ""
var inventory : Inventory
#var objects_per_id : Dictionary
var slot_index : int
var objects : Array


func setup(inv : Inventory, new_slot_index : int, property := "visual_3d"):
	self.property_name_of_visual = property
	self.inventory = inv
	self.inventory.updated_stack.connect(_on_updated_slot)
	self.slot_index = new_slot_index
	_on_updated_slot(slot_index)
#	objects_per_id = {}


func _on_updated_slot(changed_slot_index : int):
	if self.slot_index != changed_slot_index:
		return
	if changed_slot_index >= inventory.stacks.size():
		return
	_clear_last_visual()
	var item_id = inventory.items[slot_index].item_id
	var amount = inventory.items[slot_index].amount
	var definition = inventory.database.get_item(item_id)
	if item_id == "" or definition == null:
		return
	var item_scene = null
	if definition.properties.has(property_name_of_visual):
		var path = definition.properties[property_name_of_visual]
		item_scene = load(path)
	last_item_id = item_id

	if item_scene == null:
#		default_hand_item_object.visible = true
		return
#	if objects_per_id.has(item):
#		objects_per_id[item].visible = true
#	else:
	for i in amount:
		var item_obj = item_scene.instantiate()
		add_child(item_obj)
		item_obj.position.y = i * distance_for_stack
		objects.append(item_obj)
#		objects_per_id[item] = item_obj


func _clear_last_visual():
#	default_hand_item_object.visible = false
#	if last_item == null:
#		return
	for i in objects:
		i.queue_free()
	objects.clear()
#	if objects_per_id.has(last_item):
#		objects_per_id[last_item].visible = false
</file>

<file path="godot-coop/addons/inventory-system-demos/fps/tool_hand_item_3d.gd">
class_name ToolHandItem3D
extends HandItem3D

const Interactor = preload("../interaction_system/inventory_interactor.gd")


@export var use_action : InteractAction


func get_interact_actions(_interactor : Interactor) -> Array:
	return [use_action]


func interact(character : Node, _action_code : int = 0):
	character.get_node("UseItemsExample").use_item_selected_in_hotbar()
</file>

<file path="godot-coop/addons/inventory-system-demos/fps/use_items_example.gd">
class_name UseItemsExample3D
extends Node3D

@export var hotbar : Hotbar

func use_item_selected_in_hotbar():
	var stack : ItemStack = hotbar.get_stack_on_selection()
	if stack == null:
		return
	var stack_index = hotbar.get_inventory().stacks.find(stack)
	if stack_index == -1:
		return
	var definition = hotbar.database.get_item(stack.item_id)
	if definition != null:
		if stack.properties.has("durability"):
			stack.properties["durability"] = stack.properties["durability"] - 2.0
			if stack.properties["durability"] <= 0.0:
				hotbar.get_inventory().remove_at(stack_index, stack.item_id)
			else:
				hotbar.get_inventory().update_stack(stack_index)
			print(stack.properties["durability"])
</file>

<file path="godot-coop/addons/inventory-system-demos/fps/workbench.gd">
class_name Workbench
extends Node3D

const Interactor = preload("../interaction_system/inventory_interactor.gd")


@export var actions : Array
@onready var craft_station : CraftStation = $CraftStation
@onready var openable : Openable = $Openable
@onready var input_inventory: GridInventory = $InputInventory

var character


func get_interaction_position(_interaction_point : Vector3) -> Vector3:
	return position


func get_interact_actions(_interactor : Interactor) -> Array:
	if openable.is_open:
		return []
	return actions


func interact(_character : Node, action_index : int = 0):
	#craft_station.load_valid_recipes()
	if action_index == 0 and !openable.is_open:
		open(_character)
		_character.character_inventory_system.open_station(craft_station)
	else:
		self.rotate(Vector3.UP, 90)

func open(_character : Node):
	openable.open(_character)

func close(_character : Node):
	openable.close(_character)
</file>

<file path="godot-coop/addons/inventory-system-demos/interaction_system/interact_action.gd">
class_name InteractAction
extends Resource

@export var input : String = "interact"
@export var description : String = "to Interact"
@export var code : int = 0
</file>

<file path="godot-coop/addons/inventory-system-demos/interaction_system/inventory_interactor.gd">
@tool
@icon("res://addons/inventory-system/icons/interactor.svg")
extends NodeInventories

signal preview_interacted(actions : Array, position_screen : Vector2)
signal interacted(object : Node)

@export var node_base_to_interactions := NodePath(".");
@export var raycast : RayCast3D
@export var camera : Node

var last_interact_object : Node
var actual_hand_object : Node


## ðŸ«´ Interact System
func try_interact():
	var object = raycast.get_collider()
	last_interact_object = object
	var pos : Vector2 = Vector2.ZERO
	if object != null and object.has_method("get_interaction_position") and camera != null:
		pos = camera.unproject_position(object.get_interaction_position(raycast.get_collision_point()))

	var node = object as Node

	var total_actions : Array = []

	var object_actions : Array = []
	var hand_actions = get_actions(actual_hand_object)

	if raycast.is_colliding():
		object_actions = get_actions(node)

	total_actions.append_array(object_actions)
	total_actions.append_array(hand_actions)

	preview_interacted.emit(total_actions, pos)

	interact_object(object, object_actions)
	interact_hand_item(actual_hand_object, hand_actions)


func get_actions(node : Node) -> Array:
	var actions : Array = []
	if node != null and node.has_method("get_interact_actions"):
		actions = node.get_interact_actions(self)
	return actions


func interact_object(object : Node, actions : Array):
	for action in actions:
		if Input.is_action_just_pressed(action.input):
			object.interact(get_node(node_base_to_interactions), action.code)
			interacted.emit(object)
			return


func interact_hand_item(hand_object, hand_actions):
	for action in hand_actions:
		if Input.is_action_just_pressed(action.input):
			hand_object.interact(get_node(node_base_to_interactions), action.code)
			interacted.emit(hand_object)
			return


func set_actual_hand_object(new_actual_hand_object):
	actual_hand_object = new_actual_hand_object
</file>

<file path="godot-coop/addons/inventory-system-demos/mp/dropped_item_spawner.gd">
class_name DropItemSpawner
extends MultiplayerSpawner

## Class that customizes the way the spawner generates objects on the network,
## placing information on the [PackedScene] of the dropped item, position and rotation.

@export var database : InventoryDatabase

func _init():
	spawn_function = _spawn_custom


func _spawn_custom(data : Array):
	if data.size() != 5 and data.size() != 4:
		print("data size error!")
		return null
	if typeof(data[0]) != TYPE_VECTOR3 or typeof(data[1]) != TYPE_VECTOR3 or typeof(data[2]) != TYPE_STRING:
		print("data incompatible!")
		return null

	var obj = load(data[2]).instantiate()
	obj.position = data[0]
	obj.rotation = data[1]
	var item_id : String = obj.item_id
	if data.size() > 3 and typeof(data[3]) == TYPE_INT:
		obj.amount = data[3]
	if data.size() > 4  and typeof(data[4]) == TYPE_DICTIONARY:
		obj.item_properties = data[4]
	obj.item_id = item_id
	return obj
</file>

<file path="godot-coop/addons/inventory-system-demos/mp/lag_test.gd">
extends Node
class_name LagTest

@export var actived := false

func _process(_delta: float) -> void:
	if not actived:
		return
	if multiplayer.is_server():
		for i in 50000000:
			var _a := 2 + 2
</file>

<file path="godot-coop/addons/inventory-system-demos/mp/mp_demo.gd">
extends FPSDemo
class_name MPDemo

@export var player_scene : PackedScene

var connected_peer_ids : Array
var players : Array
var peer : ENetMultiplayerPeer

func _ready():
	multiplayer.peer_connected.connect(_player_connected)
	multiplayer.peer_disconnected.connect(_player_disconnected)


func _process(_delta: float) -> void:
	pass


func create_player(peer_id : int):
	connected_peer_ids.append(peer_id)
	var player = player_scene.instantiate()
	player.name = str(peer_id)
	players.append(player)
	player.position = Vector3(0,2,0)
	add_child(player)
	if multiplayer.get_unique_id() == peer_id:
		$"UI/Inventory System UI".setup(player.get_node("CharacterInventorySystem"))


@rpc
func add_newly_connected_player_character(new_peer_id):
	create_player(new_peer_id)


@rpc
func add_previously_connected_player_characters(peer_ids):
	for peer_id in peer_ids:
		create_player(peer_id)


func host_game():
	peer = ENetMultiplayerPeer.new()
	peer.create_server(4242)
	multiplayer.set_multiplayer_peer(peer)
	create_player(multiplayer.get_unique_id())
	$"UI/Connect Panel".visible = false
	await get_tree().create_timer(1).timeout
	make_scene_objects_to_network()


func make_scene_objects_to_network():
	var items = $Level/Items
	var spawner = get_node("DroppedItemSpawner")
	for i in items.get_child_count():
		var item_dropped = items.get_child(i) as DroppedItem3D
		var item_id : String = item_dropped.item_id
		var definition = database.get_item(item_id)
		var position = item_dropped.position
		var rotation = item_dropped.rotation
		var amount = item_dropped.amount
		item_dropped.queue_free()
		var dropped_item_path = definition.properties["dropped_item"]
		var _obj = spawner.spawn([position, rotation, dropped_item_path, amount])


func connect_to_ip(ip):
	peer = ENetMultiplayerPeer.new()
	peer.create_client(ip, 4242)
	multiplayer.set_multiplayer_peer(peer)
	$"UI/Connect Panel".visible = false
	var items = $Level/Items
	for i in items.get_child_count():
		var item = items.get_child(i) as DroppedItem3D
		item.queue_free()


func _player_connected(new_peer_id : int):
	if multiplayer.is_server():
		add_newly_connected_player_character.rpc(new_peer_id)
		add_previously_connected_player_characters.rpc_id(new_peer_id, connected_peer_ids)
		create_player(new_peer_id)


func _player_disconnected(peer_id : int):
	var pos = connected_peer_ids.find(peer_id)
	if pos > 0 and pos < connected_peer_ids.size():
		connected_peer_ids.remove_at(pos)
		var player = players[pos]
		players.remove_at(pos)
		player.queue_free()


func _on_host_button_button_down():
	host_game()


func _on_connect_button_button_down():
	connect_to_ip("localhost")
</file>

<file path="godot-coop/addons/inventory-system-demos/mp/mp_player.gd">
extends Player
class_name MPPlayer

func _enter_tree():
	set_multiplayer_authority(str(name).to_int())
	$CharacterInventorySystem/Inventory/SyncInventory.set_multiplayer_authority(1)
	$CharacterInventorySystem/EquipmentInventory/SyncInventory.set_multiplayer_authority(1)
	%SyncHotbar.set_multiplayer_authority(1)
	$CharacterInventorySystem/CraftStation/SyncCraftStation.set_multiplayer_authority(1)
	$Dropper.set_multiplayer_authority(1)


func _ready():
	super._ready()
	if is_multiplayer_authority():
		$Camera3D.make_current()
	else:
		$Camera3D.clear_current()
	$Camera3D/HandItem.visible = is_multiplayer_authority()
	$Camera3D/ThirdPersonHandItem.visible = not is_multiplayer_authority()
	if is_multiplayer_authority():
		$Mesh.visible = false


func _physics_process(delta):
	if is_multiplayer_authority():
		super._physics_process(delta)


func _input(event: InputEvent) -> void:
	if is_multiplayer_authority():
		super._input(event)
</file>

<file path="godot-coop/addons/inventory-system-demos/mp/networked_box_inventory.gd">
extends BoxInventory
class_name NetworkedBoxInventory

func interact(character : Node, _action_index : int = 0):
	if multiplayer.is_server():
		interact_rpc(character.get_path(), _action_index)
	else:
		interact_rpc.rpc_id(1, character.get_path(), _action_index)

@rpc("any_peer")
func interact_rpc(character_path : NodePath, _action_index : int = 0):
	super.interact(get_node(character_path), _action_index)
</file>

<file path="godot-coop/addons/inventory-system-demos/mp/networked_campfire.gd">
extends Campfire
class_name NetworkedCampfire

func _ready():
	super._ready()
	changed_burning_state.connect(_changed_burning_state)
	multiplayer.peer_connected.connect(_on_connected)


func check():
	if not multiplayer.is_server():
		return
	super.check()


func _on_connected(_id : int):
	_changed_burning_state(is_burning)


func _changed_burning_state(is_burning_now : bool):
	if not multiplayer.is_server():
		return
	_changed_burning_state_rpc.rpc(is_burning_now)


@rpc
func _changed_burning_state_rpc(is_burning_now : bool):
	if multiplayer.is_server():
		return
	self.is_burning = is_burning_now


@warning_ignore("shadowed_variable_base_class")
func interact(character : Node, _action_index : int = 0):
	if multiplayer.is_server():
		interact_rpc(character.get_path(), _action_index)
	else:
		interact_rpc.rpc_id(1, character.get_path(), _action_index)

@rpc("any_peer")
func interact_rpc(character_path : NodePath, _action_index : int = 0):
	super.interact(get_node(character_path), _action_index)
</file>

<file path="godot-coop/addons/inventory-system-demos/mp/networked_dropper.gd">
extends Dropper


@export_node_path var drop_item_spawner_path := NodePath("../../DroppedItemSpawner")
@onready var drop_item_spawner = get_node(drop_item_spawner_path)


func _ready():
	if is_multiplayer_authority():
		super._ready()


func _on_request_drop_obj(dropped_item : String, _item_id : String, amount : int, properties : Dictionary):
	if(drop_item_spawner == null):
		printerr("Spawner is null!")
		return
	var packed_scene : PackedScene = load(dropped_item)
	var data : Array
	data.append(global_position)
	data.append(global_rotation)
	data.append(packed_scene.resource_path)
	data.append(amount)
	data.append(properties)
	var obj = drop_item_spawner.spawn(data)
	dropped.emit(obj)
</file>

<file path="godot-coop/addons/inventory-system-demos/mp/networked_object_placer.gd">
extends "../character/object_placer.gd"
class_name NetworkedObjectPlacer


@export_node_path var spawner_path : NodePath = NodePath("../../../../PlaceableItemSpawner")
@onready var spawner : PlaceableItemSpawner = get_node(spawner_path)


func place_item(item_id : String, position : Vector3, rotation : Vector3):
	if item_id.is_empty():
		return
	if not multiplayer.is_server():
		place_item_rpc.rpc_id(1, item_id, position, rotation)
	else:
		place_item_rpc(item_id, position, rotation)
	return


@rpc("any_peer")
func place_item_rpc(item_id : String, position : Vector3, rotation : Vector3):
	if not multiplayer.is_server():
		return
	super.place_item(item_id, position, rotation)


func _instantiate_object(dropped_item : PackedScene, position : Vector3, rotation : Vector3):
	var obj = spawner.spawn([position, rotation, dropped_item.resource_path])
#	dropped.emit(obj)
</file>

<file path="godot-coop/addons/inventory-system-demos/mp/networked_shelf.gd">
extends Shelf
class_name NetworkedShelf


func interact(character : Node, action_index : int = 0):
	if not multiplayer.is_server():
		interact_rpc.rpc_id(1, character.get_path(), action_index, slot_index)
	else:
		interact_rpc(character.get_path(), action_index, slot_index)

@rpc("any_peer")
@warning_ignore("shadowed_variable_base_class")
func interact_rpc(character_node_path : NodePath, action_index : int, slot_index):
	if not multiplayer.is_server():
		return
	var node = get_node(character_node_path)
	if node == null:
		return
	super.interact_with_slot(node, action_index, slot_index)
</file>

<file path="godot-coop/addons/inventory-system-demos/mp/networked_use_items_example_3d.gd">
class_name NetworkedUseItemsExample3D
extends UseItemsExample3D


func use_item_selected_in_hotbar():
	if not multiplayer.is_server():
		use_item_selected_in_hotbar_rpc.rpc_id(1)
	else:
		use_item_selected_in_hotbar_rpc()


@rpc
func use_item_selected_in_hotbar_rpc():
	if not multiplayer.is_server():
		return
	super.use_item_selected_in_hotbar()
</file>

<file path="godot-coop/addons/inventory-system-demos/mp/networked_workbench.gd">
extends Workbench


@warning_ignore("shadowed_variable_base_class")
func interact(character : Node, _action_index : int = 0):
	if multiplayer.is_server():
		interact_rpc(character.get_path(), _action_index)
	else:
		interact_rpc.rpc_id(1, character.get_path(), _action_index)

@rpc("any_peer")
func interact_rpc(character_path : NodePath, _action_index : int = 0):
	super.interact(get_node(character_path), _action_index)
</file>

<file path="godot-coop/addons/inventory-system-demos/mp/placeable_item_spawner.gd">
class_name PlaceableItemSpawner
extends MultiplayerSpawner

## Class that customizes the way the spawner generates objects on the network,
## placing information on the [PackedScene] of the dropped item, position and rotation.

func _init():
	spawn_function = _spawn_custom


func _spawn_custom(data : Array):
	if data.size() != 3:
		print("data size error!")
		return null
	if typeof(data[0]) != TYPE_VECTOR3 or typeof(data[1]) != TYPE_VECTOR3 or typeof(data[2]) != TYPE_STRING:
		print("data incompatible!")
		return null

	var obj = load(data[2]).instantiate()
	obj.position = data[0]
	obj.rotation = data[1]
	return obj
</file>

<file path="godot-coop/addons/inventory-system-demos/mp/sync_craft_station.gd">
extends Node
class_name SyncCraftStation

@export var craft_station : CraftStation
@export var sync_input_inventories : bool
var craftings_data : Array


func _ready() -> void:
	craft_station.can_finish_craftings = is_multiplayer_authority()
	multiplayer.peer_connected.connect(_on_connected)
	craft_station.crafting_added.connect(_on_crafting_added)
	craft_station.crafting_removed.connect(_on_crafting_removed)
	if sync_input_inventories:
		craft_station.input_inventory_added.connect(_on_input_inventory_added)
		craft_station.input_inventory_removed.connect(_on_input_inventory_removed)


func _on_connected(peer_id : int):
	craft_station.can_finish_craftings = is_multiplayer_authority()
	if not multiplayer.is_server():
		return
	_update_craftings_rpc.rpc_id(peer_id, craftings_data)


func _on_crafting_added(crafting_index : int):
	if not multiplayer.is_server():
		return
	var crafting = craft_station.craftings[crafting_index]
	crafting_added_rpc.rpc(crafting.recipe_index)
	craftings_data.append(crafting.serialize())



func _on_crafting_removed(crafting_index : int):
	if not multiplayer.is_server():
		return
	crafting_removed_rpc.rpc(crafting_index)
	craftings_data.remove_at(crafting_index)


func _on_input_inventory_added(inventory_path : NodePath):
	if not multiplayer.is_server():
		return
	input_inventory_added_rpc.rpc(inventory_path)


func _on_input_inventory_removed(inventory_path : NodePath):
	if not multiplayer.is_server():
		return
	input_inventory_removed_rpc.rpc(inventory_path)


@rpc
func crafting_added_rpc(recipe_index : int):
	if multiplayer.is_server():
		return
	var recipe = craft_station.database.recipes[recipe_index]
	craft_station.add_crafting(recipe_index, recipe)

@rpc
func crafting_removed_rpc(crafting_index : int):
	if multiplayer.is_server():
		return
	craft_station.remove_crafting(crafting_index)

@rpc
@warning_ignore("shadowed_variable")
func _update_craftings_rpc(craftings_data : Array):
	craft_station.can_finish_craftings = is_multiplayer_authority()
	for data in craftings_data:
		var crafting = Crafting.new()
		crafting.deserialize(data)
		craft_station.craftings.append(crafting)

@rpc
func input_inventory_added_rpc(inventory_path : NodePath):
	craft_station.add_input_inventory(craft_station.get_node(inventory_path))

@rpc
func input_inventory_removed_rpc(inventory_path : NodePath):
	craft_station.remove_input_inventory(craft_station.get_node(inventory_path))
</file>

<file path="godot-coop/addons/inventory-system-demos/mp/sync_hotbar.gd">
extends Node
class_name	SyncHotbar

@export var hotbar : Hotbar

func _ready() -> void:
	multiplayer.peer_connected.connect(_on_connected)
	hotbar.equipped.connect(_on_equipped_stack_changed)
	hotbar.unequipped.connect(_on_unequipped_stack_changed)
	hotbar.on_change_selection.connect(_on_change_selection)



func _on_equipped_stack_changed(slot_index: int):
	if not multiplayer.is_server():
		return
	var stack = hotbar.get_stack_on_slot(slot_index)
	var stack_index = hotbar.get_inventory().stacks.find(stack)
	equipped_stack_changed_rpc.rpc(stack_index, slot_index)


func _on_unequipped_stack_changed(slot_index: int):
	if not multiplayer.is_server():
		return
	unequipped_stack_changed_rpc.rpc(slot_index)


func _on_connected(peer_id : int):
	if not multiplayer.is_server():
		return
	change_selection_rpc.rpc_id(peer_id, hotbar.selection_index)
	for i in hotbar.max_slots:
		var stack = hotbar.get_stack_on_slot(i)
		if stack == null:
			continue
		var stack_index = hotbar.get_inventory().stacks.find(stack)
		equipped_stack_changed_rpc.rpc_id(peer_id,stack_index, i)


func _on_change_selection(selection_index : int):
	if not multiplayer.is_server():
		return
	change_selection_rpc.rpc(selection_index)


@rpc
func equipped_stack_changed_rpc(stack_index : int, slot_index: int):
	var stack: ItemStack = null
	if stack_index >= 0 and stack_index < hotbar.get_inventory().stacks.size():
		stack = hotbar.get_inventory().stacks[stack_index]
	hotbar.equip(stack, slot_index)


@rpc
func unequipped_stack_changed_rpc(slot_index: int):
	hotbar.unequip(slot_index)


@rpc
func change_selection_rpc(selection_index: int):
	hotbar.selection_index = selection_index
</file>

<file path="godot-coop/addons/inventory-system-demos/ui/craft/craft_station_ui.gd">
class_name CraftStationUI
extends Control

## Represents a [CraftStation] in the interface.
## It uses instanced scenes from [RecipeUI] to represent every possible station recipe.
## Use the [CraftingsUI] to represent each active crafting in the station.

signal on_craft(craft_station : CraftStation, recipe_index : int)

## It uses instanced scenes from [RecipeUI] to represent every possible station recipe.
@export var recipe_ui_scene : PackedScene

## [InventoryUI] which represents the input inventory.
@onready var input_inventory_ui : GridInventoryUI = %InputGridInventoryUI

## [InventoryUI] which represents the output inventory.
@onready var output_inventory_ui : GridInventoryUI = %OutputGridInventoryUI

## Show input inventory when open [CraftStationUI].
@export var view_input_inventory := true

## Show output inventory when open [CraftStationUI].
@export var view_output_inventory := true

@onready var _recipes_container : VBoxContainer = %RecipesContent
@onready var _craftings_ui : CraftingsUI = %CraftingsUI

var craft_station : CraftStation

var _recipe_uis : Array[RecipeUI]


## Configure a craftstation for the [Recipe] list and [CraftingsUI] list
func open(_craft_station : CraftStation):
	
	if(self.craft_station != null):
		for i in self.craft_station.input_inventories.size():
			if self.craft_station.get_input_inventory(i).contents_changed.is_connected(_on_input_inventory_contents_changed):
				self.craft_station.get_input_inventory(i).contents_changed.disconnect(_on_input_inventory_contents_changed)
	
	self.craft_station = _craft_station
	_clear()
	_craftings_ui.set_craft_station(craft_station)
	var recipes = craft_station.database.recipes
	for i in craft_station.valid_recipes.size():
		var recipe_index = craft_station.valid_recipes[i]
		var recipe = craft_station.database.recipes[recipe_index]
		var recipe_ui : RecipeUI = recipe_ui_scene.instantiate()
		_recipe_uis.append(recipe_ui)
		_recipes_container.add_child(recipe_ui)
		recipe_ui.set_recipe(craft_station, recipe, recipe_index)
		recipe_ui.craft_button.button_down.connect(_on_craft_button_button_down.bind(craft_station, recipe_index))
	visible = true
	var valid_input = view_input_inventory and craft_station.input_inventories.size() > 0 and craft_station.input_inventories[0] != null
	var valid_output = view_output_inventory and craft_station.output_inventories.size() > 0 and craft_station.output_inventories[0] != null
	if valid_input: 
		input_inventory_ui.inventory = craft_station.get_input_inventory(0)
	if valid_output: 
		input_inventory_ui.inventory = craft_station.get_input_inventory(0)
	input_inventory_ui.visible = valid_input
	output_inventory_ui.visible = valid_output
	
	for i in craft_station.input_inventories.size():
		craft_station.get_input_inventory(i).contents_changed.connect(_on_input_inventory_contents_changed)


func _on_input_inventory_contents_changed():
	for recipe_ui in _recipe_uis:
		recipe_ui.check_if_has_ingredients()


## Hidden this UI
func close():
	visible = false


func _clear():
	for recipe_ui in _recipe_uis:
		recipe_ui.queue_free()
	_recipe_uis.clear()


func _on_craft_button_button_down(_craft_station : CraftStation, _recipe_index : int):
	on_craft.emit(_craft_station, _recipe_index)
</file>

<file path="godot-coop/addons/inventory-system-demos/ui/craft/crafting_ui.gd">
class_name CraftingUI
extends Control

## Interface that represents a crafting that is in a craft station list.

## What station is this crafting from
var station : CraftStation

## Crafting information (Time and recipe)
var crafting : Crafting 

@onready var _icon : TextureRect = %Icon
@onready var _progress_bar : ProgressBar = %ProgressBar


## Set crafting based on [CraftStation] crafting index
func set_crafting(_station : CraftStation, crafting_index : int):
	self.station = _station
	crafting = station.craftings[crafting_index]
	var recipe_index = crafting.recipe_index
	var recipe = station.database.recipes[recipe_index]
	var definition = station.database.get_item(recipe.products[0].item_id)
	_icon.texture = definition.icon
	_progress_bar.max_value = recipe.time_to_craft


func _process(_delta : float):
	_progress_bar.value =  _progress_bar.max_value - crafting.time
</file>

<file path="godot-coop/addons/inventory-system-demos/ui/craft/craftings_ui.gd">
class_name CraftingsUI
extends VBoxContainer

## Represents the active craftings of [CraftStation] with a user interface.

## Scene to be instantiated that represents a crafting from the [CraftStation]'s crafting list
@export var crafting_ui_scene : PackedScene


var _craft_station : CraftStation
var _craftings : Array[CraftingUI]


## Configure crafting list for this interface
func set_craft_station(craft_station : CraftStation):
	_clear()
	if _craft_station != null and _craft_station != craft_station:
		_craft_station.crafting_added.disconnect(_on_add_crafting_at)
		_craft_station.crafting_removed.disconnect(_on_remove_crafting_at)
	if _craft_station != craft_station:
		craft_station.crafting_added.connect(_on_add_crafting_at)
		craft_station.crafting_removed.connect(_on_remove_crafting_at)
	_craft_station = craft_station
	
	for i in craft_station.craftings.size():
		_on_add_crafting_at(i)


func _clear():
	for crafting in _craftings:
		crafting.queue_free()	
	_craftings.clear()


func _on_add_crafting_at(crafting_index : int):
	var crafting_obj = crafting_ui_scene.instantiate()
	add_child(crafting_obj)
	move_child(crafting_obj, 0)
	_craftings.insert(crafting_index, crafting_obj)
	crafting_obj.set_crafting(_craft_station, crafting_index)


func _on_remove_crafting_at(crafting_index : int):
	_craftings[crafting_index].queue_free()
	_craftings.remove_at(crafting_index)
</file>

<file path="godot-coop/addons/inventory-system-demos/ui/craft/ingredient_ui.gd">
class_name IngredientUI
extends Control

## Interface represents Ingredient in [RecipeUI].

@onready var icon : TextureRect = get_node("Icon")
@onready var amount : Label = get_node("Amount")
var database : InventoryDatabase

## Setup ingredient
func setup(_database : InventoryDatabase, item_stack : ItemStack):
	self.database = _database
	var definition = database.get_item(item_stack.item_id)
	self.icon.texture = definition.icon
	self.amount.text = "X "+str(item_stack.amount)
</file>

<file path="godot-coop/addons/inventory-system-demos/ui/drop_area.gd">
extends Control
class_name DropArea

signal request_drop(stack: ItemStack, inventory: Inventory)

@onready var player_grid_inventory_ui: GridInventoryPanel = %PlayerGridInventoryUI


func _can_drop_data(_at_position: Vector2, _data: Variant) -> bool:
	return true


func _drop_data(_at_position: Vector2, data: Variant) -> void:
	request_drop.emit(data.stack, data.inventory)
</file>

<file path="godot-coop/addons/inventory-system-demos/ui/grid/grid_draggable_element_ui.gd">
@tool
extends Panel
class_name GridDraggableElementUI

# Somewhat hacky way to do static signals:
# https://stackoverflow.com/questions/77026156/how-to-write-a-static-event-emitter-in-gdscript/77026952#77026952

static var dragable_grabbed: Signal = (func():
	if (GridDraggableElementUI as Object).has_user_signal("dragable_grabbed"):
		return (GridDraggableElementUI as Object).dragable_grabbed
	(GridDraggableElementUI as Object).add_user_signal("dragable_grabbed")
	return Signal(GridDraggableElementUI, "dragable_grabbed")
).call()

static var dragable_dropped: Signal = (func():
	if (GridDraggableElementUI as Object).has_user_signal("dragable_dropped"):
		return (GridDraggableElementUI as Object).dragable_dropped
	(GridDraggableElementUI as Object).add_user_signal("dragable_dropped")
	return Signal(GridDraggableElementUI, "dragable_dropped")
).call()

signal grabbed(position)
#signal dropped(zone, position)

static var _grabbed_dragable: GridDraggableElementUI = null
static var _grab_offset: Vector2

var _enabled: bool = true


static func get_grabbed_dragable() -> GridDraggableElementUI:
	if !is_instance_valid(_grabbed_dragable):
		return null
	return _grabbed_dragable


static func get_grab_offset() -> Vector2:
	return _grab_offset


static func get_grab_offset_local_to(control: Control) -> Vector2:
	return GridDraggableElementUI.get_grab_offset() / control.get_global_transform().get_scale()


func _get_drag_data(at_position: Vector2):
	if !_enabled:
		return null

	_grabbed_dragable = self
	_grab_offset = at_position * get_global_transform().get_scale()
	dragable_grabbed.emit(_grabbed_dragable, _grab_offset)
	grabbed.emit(_grab_offset)

	var preview = Control.new()
	var sub_preview = create_preview()
	sub_preview.position = -get_grab_offset()
	preview.add_child(sub_preview)
	set_drag_preview(preview)
	return self


func _notification(what: int) -> void:
	if what == NOTIFICATION_DRAG_END:
		_grabbed_dragable = null


func create_preview() -> Control:
	return null


func activate() -> void:
	_enabled = true


func deactivate() -> void:
	_enabled = false


func is_active() -> bool:
	return _enabled


func is_dragged() -> bool:
	return _grabbed_dragable == self
</file>

<file path="godot-coop/addons/inventory-system-demos/ui/grid/grid_drop_zone_ui.gd">
@tool
extends Control
class_name GridDropZoneUI

signal dragable_dropped(dragable, position)


func activate() -> void:
	mouse_filter = Control.MOUSE_FILTER_PASS


func deactivate() -> void:
	mouse_filter = Control.MOUSE_FILTER_IGNORE


func is_active() -> bool:
	return (mouse_filter != Control.MOUSE_FILTER_IGNORE)


func _can_drop_data(_at_position: Vector2, data) -> bool:
	if data == null:
		return false
	return data is GridDraggableElementUI


func _drop_data(at_position: Vector2, data) -> void:
	var local_offset := GridDraggableElementUI.get_grab_offset_local_to(self)
	dragable_dropped.emit(data, at_position - local_offset)
	GridDraggableElementUI.dragable_dropped.emit(data, self, at_position - local_offset)
</file>

<file path="godot-coop/addons/inventory-system-demos/ui/grid/grid_inventory_panel.gd">
extends PanelContainer
class_name GridInventoryPanel


signal request_split(inventory : Inventory, stack_index : int, amount : int)
signal request_transfer_to(origin_inventory: GridInventory, origin_position: Vector2i, inventory: GridInventory, destination_position : Vector2i, amount : int, is_rotated: bool)
signal request_fast_transfer(origin_inventory: GridInventory, origin_position: Vector2i, inventory: GridInventory, amount : int)
#signal request_sort
signal inventory_stack_context_activated(event: InputEvent, inventory : Inventory, stack: ItemStack)

@export var inventory: GridInventory:
	set(new_Inventory):
		inventory = new_Inventory
		if inventory != null:
			if title_label != null:
				title_label.text = inventory.name
			grid_inventory_ui.inventory_path = grid_inventory_ui.get_path_to(inventory)

@export var grid_inventory_ui: GridInventoryUI
@export var title_label: Label
#@onready var sort_button: Button = %SortButton


func _ready() -> void:
	#sort_button.pressed.connect(func():
		#request_sort.emit(inventory)
	#)
	grid_inventory_ui.request_split.connect(func(_inventory: GridInventory, stack_index: int, amount : int):
		request_split.emit(_inventory, stack_index, amount)
	)
	grid_inventory_ui.request_transfer_to.connect(func(origin_inventory: GridInventory, origin_position: Vector2i, destination_inventory : GridInventory, destination_position: Vector2i, amount: int, is_rotated: bool):
		request_transfer_to.emit(origin_inventory, origin_position, destination_inventory, destination_position, amount, is_rotated)
	)
	grid_inventory_ui.request_fast_transfer.connect(func(origin_inventory: GridInventory, origin_position: Vector2i, amount: int):
		request_fast_transfer.emit(origin_inventory, origin_position, amount)
	)
	grid_inventory_ui.inventory_stack_context_activated.connect(func(event: InputEvent,  _inventory: Inventory, stack: ItemStack):
		inventory_stack_context_activated.emit(event, _inventory, stack)
	)

# TODO Console mode (Code from old inventory_ui
#for stack_index in ui_stacks.size():
		#var ui_stack = ui_stacks[stack_index]
		#for neighbor in ["left", "top", "right", "bottom"]:
			#var neighbor_idx: int
			#match neighbor:
				#"left":
					#neighbor_idx = stack_index - 1
					#if stack_index % slots_container.columns == 0:
						#neighbor_idx = -1
				#"top":
					#neighbor_idx = stack_index - slots_container.columns
				#"right":
					#neighbor_idx = stack_index + 1
					#if (stack_index + 1) % slots_container.columns == 0:
						#neighbor_idx = -1
				#"bottom":
					#neighbor_idx = stack_index + slots_container.columns
			#if neighbor_idx >= 0 and neighbor_idx < ui_stacks.size():
				#ui_stack.set("focus_neighbor_"+neighbor, ui_stacks[neighbor_idx].get_path())
</file>

<file path="godot-coop/addons/inventory-system-demos/ui/grid/grid_inventory_ui.gd">
extends Control
class_name GridInventoryUI

#region Signals

## Emitted when a grabbed [ItemStack] is dropped.
signal item_dropped(item: ItemStack, offset)
## Emitted when the selection has changed. Use [method get_selected_inventory_item]
## to obtain the currently selected item.
signal selection_changed
## Emitted when an [InventoryItem] is activated (i.e. double clicked).
signal inventory_item_activated(item)
## Emitted when the context menu of an [ItemStack] is activated
## (i.e. right clicked).
signal inventory_stack_context_activated(event: InputEvent,  inventory: Inventory, item: ItemStack)
## Emitted when the mouse enters the [Rect2] area of the control representing
## the given [InventoryItem].
signal item_mouse_entered(item)
## Emitted when the mouse leaves the [Rect2] area of the control representing
## the given [InventoryItem].
signal item_mouse_exited(item)

signal request_split(inventory : Inventory, stack_index : int, amount : int)
signal request_transfer_to(origin_inventory: GridInventory, origin_position: Vector2i, inventory: GridInventory, destination_position: Vector2i, amount: int, is_rotated: bool)
signal request_fast_transfer(origin_inventory: GridInventory, origin_position: Vector2i, amount: int)

#endregion

enum SelectMode {SELECT_SINGLE = 0, SELECT_MULTI = 1}

#region Variables
@export var grid_slot_ui_scene: PackedScene
@export var grid_item_stack_ui_scene: PackedScene

## Path to an [Inventory] node.
@export var inventory_path: NodePath:
	set(new_inv_path):
		if new_inv_path == inventory_path:
			return
		inventory_path = new_inv_path
		var node: Node = get_node_or_null(inventory_path)

		if node == null:
			return

		if is_inside_tree():
			assert(node is GridInventory)
			
		inventory = node
		update_configuration_warnings()

## The size of each inventory gird slot in pixels.
@export var grid_slot_size: Vector2 = Vector2(32, 32)

## The spacing between items in pixels.
@export var item_spacing: int = 0

## Single or multi select mode (hold CTRL to select multiple items).
@export_enum("Single", "Multi") var select_mode: int = SelectMode.SELECT_SINGLE:
	set(new_select_mode):
		if select_mode == new_select_mode:
			return
		select_mode = new_select_mode
		_clear_selection()


@export_group("Custom Styles")
## Style of a rectangle that will be drawn on top of the selected item.
@export var selection_style: StyleBox:
	set(new_selection_style):
		selection_style = new_selection_style
		_queue_refresh()


## The [Inventory] node linked to this control.
var inventory: GridInventory = null:
	set(new_inventory):
		
		if inventory == new_inventory:
			return
		
		_clear_selection()
		_disconnect_inventory_signals()
		inventory = new_inventory
		_connect_inventory_signals()

		_queue_refresh()
		_update_stacks()

var _grid_inventory_content_ui: Control = null
var _grid_slots_container: Control = null
var _grid_slots: Array = []
var _refresh_queued: bool = false
var _stack_uis: Array = []
var _selected_stacks: Array[GridItemStackUI] = []
var _ctrl_item_container: Control = null
var _grid_drop_zone_ui: GridDropZoneUI = null
#endregion


#region Default Functions
func _ready() -> void:
	if Engine.is_editor_hint():
		# Clean up, in case it is duplicated in the editor
		if is_instance_valid(_grid_inventory_content_ui):
			_grid_inventory_content_ui.queue_free()
			_grid_slots_container.queue_free()

	if has_node(inventory_path):
		inventory = get_node_or_null(inventory_path)
		
	_grid_slots_container = Control.new()
	_grid_slots_container.name = "GridSlotsContainer"
	add_child(_grid_slots_container)

	_grid_inventory_content_ui = Control.new()
	_grid_inventory_content_ui.name = "GridInventoryContentUI"
	_grid_inventory_content_ui.resized.connect(_update_size)
	_grid_inventory_content_ui.mouse_filter = Control.MOUSE_FILTER_IGNORE
	add_child(_grid_inventory_content_ui)
	
	_ctrl_item_container = Control.new()
	_ctrl_item_container.size = size
	_ctrl_item_container.mouse_filter = Control.MOUSE_FILTER_IGNORE
	_grid_inventory_content_ui.resized.connect(func(): _ctrl_item_container.size = size)
	_grid_inventory_content_ui.add_child(_ctrl_item_container)

	_grid_drop_zone_ui = GridDropZoneUI.new()
	_grid_drop_zone_ui.dragable_dropped.connect(_on_dragable_dropped)
	_grid_drop_zone_ui.size = size
	resized.connect(func(): _grid_drop_zone_ui.size = size)
	GridDraggableElementUI.dragable_grabbed.connect(func(_dragable: GridDraggableElementUI, _grab_position: Vector2):
		_grid_drop_zone_ui.activate()
	)
	GridDraggableElementUI.dragable_dropped.connect(func(_dragable: GridDraggableElementUI, _zone: GridDropZoneUI, _drop_position: Vector2):
		_grid_drop_zone_ui.deactivate()
	)
	_grid_inventory_content_ui.add_child(_grid_drop_zone_ui)

	_update_size()
	_queue_refresh()
	
func _process(_delta) -> void:
	if _refresh_queued:
		_refresh()
		_refresh_queued = false


func _get_configuration_warnings() -> PackedStringArray:
	if inventory_path.is_empty():
		return PackedStringArray([
				"This node is not linked to an inventory and it can't display any content.\n" + \
				"Set the inventory_path property to point to an InventoryGrid node."])
	return PackedStringArray()
	

func _notification(what: int) -> void:
	if what == NOTIFICATION_DRAG_END:
		_grid_drop_zone_ui.deactivate()
		


func _input(event) -> void:
	if !(event is InputEventMouseMotion):
		return
	if !is_instance_valid(inventory):
		return
	_highlight_grabbed_item()
#endregion


func _connect_inventory_signals() -> void:
	if !is_instance_valid(inventory):
		return
	if !inventory.stack_added.is_connected(_on_inventory_stack_added):
		inventory.stack_added.connect(_on_inventory_stack_added)
	if !inventory.stack_removed.is_connected(_on_inventory_stack_removed):
		inventory.stack_removed.connect(_on_inventory_stack_removed)
	if !inventory.size_changed.is_connected(_on_inventory_resized):
		inventory.size_changed.connect(_on_inventory_resized)


func _disconnect_inventory_signals() -> void:
	if !is_instance_valid(inventory):
		return
	if inventory.stack_added.is_connected(_on_inventory_stack_added):
		inventory.stack_added.disconnect(_on_inventory_stack_added)
	if inventory.stack_removed.is_connected(_on_inventory_stack_removed):
		inventory.stack_removed.disconnect(_on_inventory_stack_removed)
	if inventory.size_changed.is_connected(_on_inventory_resized):
		inventory.size_changed.disconnect(_on_inventory_resized)


func _on_stack_added(_stack_index : int):
	_queue_refresh()


func _update_stacks():
	for stack_ui in _stack_uis:
		stack_ui.queue_free()
	_stack_uis.clear()
	for stack_index in inventory.stacks.size():
		_on_inventory_stack_added(stack_index)
	

func _on_inventory_stack_added(stack_index: int):
	var stack = inventory.stacks[stack_index]
	add_grid_item_stack_ui(stack)


func _on_inventory_stack_removed(stack_index: int):
	var _stack_ui = _stack_uis[stack_index]
	_stack_ui.queue_free()
	_stack_uis.remove_at(stack_index)


func _refresh() -> void:
	_refresh_grid_slots()
	size = custom_minimum_size
	
	if is_instance_valid(_grid_drop_zone_ui):
		_grid_drop_zone_ui.deactivate()
	if is_instance_valid(_grid_inventory_content_ui):
		_grid_inventory_content_ui.custom_minimum_size = _get_inventory_size_pixels()


func _queue_refresh() -> void:
	_refresh_queued = true
		

#region Grid Slots
func get_grid_slot_coords(local_pos: Vector2) -> Vector2i:
	# We have to consider the item spacing when calculating grid slot coordinates, thus we expand the
	# size of each field by Vector2(item_spacing, item_spacing).
	var grid_slot_dimensions_ex = grid_slot_size + Vector2(item_spacing, item_spacing)

	# We also don't want the item spacing to disturb snapping to the closest field, so we add half
	# the spacing to the local coordinates.
	var local_pos_ex = local_pos + (Vector2(item_spacing, item_spacing) / 2)

	var x: int = local_pos_ex.x / (grid_slot_dimensions_ex.x)
	var y: int = local_pos_ex.y / (grid_slot_dimensions_ex.y)
	return Vector2i(x, y)


func _refresh_grid_slots() -> void:
	if is_instance_valid(_grid_slots_container):
		while _grid_slots_container.get_child_count() > 0:
			_grid_slots_container.get_children()[0].queue_free()
			_grid_slots_container.remove_child(_grid_slots_container.get_children()[0])
	_grid_slots = []

	if !is_instance_valid(inventory):
		return
	
	for i in range(inventory.size.x):
		_grid_slots.append([])
		for j in range(inventory.size.y):
			var grid_slot_ui: GridSlotUI = grid_slot_ui_scene.instantiate()
			grid_slot_ui.size = grid_slot_size
			grid_slot_ui.position = _get_grid_slot_position(Vector2i(i, j))
			grid_slot_ui.setup(Vector2i(i, j), inventory)
			_grid_slots_container.add_child(grid_slot_ui)
			_grid_slots[i].append(grid_slot_ui)
			
			
func _set_selected_grid_slots(rect: Rect2i, selected: bool) -> void:
	var h_range = min(rect.size.x + rect.position.x, inventory.size.x)
	for i in range(rect.position.x, h_range):
		var v_range = min(rect.size.y + rect.position.y, inventory.size.y)
		for j in range(rect.position.y, v_range):
			if selected:
				_grid_slots[i][j].select()
			else:
				_grid_slots[i][j].unselect()


func _set_dragged_grid_slots(rect: Rect2i, dragged: bool) -> void:
	var h_range = min(rect.size.x + rect.position.x, inventory.size.x)
	for i in range(rect.position.x, h_range):
		var v_range = min(rect.size.y + rect.position.y, inventory.size.y)
		for j in range(rect.position.y, v_range):
			_grid_slots[i][j].item_dragged = dragged


func _fill_background(style: StyleBox, priority: int) -> void:
	for panel in _grid_slots_container.get_children():
		panel.set_style(style, priority)
#endregion


func _update_size() -> void:
	custom_minimum_size = _grid_inventory_content_ui.size
	size = _grid_inventory_content_ui.size


func _on_inventory_resized() -> void:
	_queue_refresh()
	_refresh_grid_slots()


func _highlight_grabbed_item():
	var grabbed_item: ItemStack = _get_global_grabbed_item()
	if !grabbed_item:
		return

	var global_grabbed_item_pos: Vector2 = _get_global_grabbed_item_local_pos()
	if !_is_hovering(global_grabbed_item_pos):
		#_set_dragged_grid_slots(rect, false)
		return

	#_set_dragged_grid_slots(rect, false)

	var grabbed_item_coords := get_grid_slot_coords(global_grabbed_item_pos + (grid_slot_size / 2))
	var definition : ItemDefinition = inventory.database.get_item(grabbed_item.item_id)
	var item_size := definition.size
	var rect := Rect2i(grabbed_item_coords, item_size)
	if !Rect2i(Vector2i.ZERO, inventory.size).encloses(rect):
		return
	#_set_dragged_grid_slots(rect, true)


func _is_hovering(local_pos: Vector2) -> bool:
	return Rect2(Vector2.ZERO, size).has_point(local_pos)


func _get_global_grabbed_item() -> ItemStack:
	if GridDraggableElementUI.get_grabbed_dragable() == null:
		return null
	return (GridDraggableElementUI.get_grabbed_dragable() as GridItemStackUI).stack


func _get_global_grabbed_item_local_pos() -> Vector2:
	if GridDraggableElementUI.get_grabbed_dragable():
		return get_local_mouse_position() - GridDraggableElementUI.get_grab_offset_local_to(self)
	return Vector2(-1, -1)


## Returns the currently selected item. In case multiple items are selected,
## the first one is returned.
func get_selected_inventory_item() -> GridItemStackUI:
	if !is_instance_valid(_grid_inventory_content_ui):
		return null
	return _selected_stacks[0]


## Returns all the currently selected items.
func get_selected_stacks() -> Array[GridItemStackUI]:
	return _selected_stacks.duplicate()

	
#region ContentUI
func _on_item_drop(zone: GridDropZoneUI, drop_position: Vector2, grid_item_stack_ui: GridItemStackUI) -> void:
	var stack: ItemStack = grid_item_stack_ui.item
	# The item might have been freed in case the item stack has been moved and merged with another
	# stack.
	if is_instance_valid(stack) and inventory.has_stack(stack):
		if zone == null:
			item_dropped.emit(stack, drop_position + grid_item_stack_ui.position)


func add_grid_item_stack_ui(stack: ItemStack):
	var grid_item_stack_ui : GridItemStackUI = grid_item_stack_ui_scene.instantiate()
	grid_item_stack_ui.size = _get_stack_sprite_size(stack)
	grid_item_stack_ui.setup(inventory, stack)
	grid_item_stack_ui.grabbed.connect(_on_item_grab.bind(grid_item_stack_ui))
	#grid_item_stack_ui.dropped.connect(_on_item_drop.bind(grid_item_stack_ui))
	grid_item_stack_ui.activated.connect(_on_item_activated.bind(grid_item_stack_ui))
	grid_item_stack_ui.context_activated.connect(_on_item_context_activated.bind(grid_item_stack_ui))
	grid_item_stack_ui.mouse_entered.connect(func():
		item_mouse_entered.emit(grid_item_stack_ui.stack)
	)
	grid_item_stack_ui.mouse_exited.connect(func():
		item_mouse_exited.emit(grid_item_stack_ui.stack)
	)
	grid_item_stack_ui.clicked.connect(_on_item_clicked.bind(grid_item_stack_ui))
	grid_item_stack_ui.middle_clicked.connect(_on_item_middle_clicked.bind(grid_item_stack_ui))
	grid_item_stack_ui.position = _get_grid_slot_position(inventory.get_stack_position(stack))

	_ctrl_item_container.add_child(grid_item_stack_ui)
	_stack_uis.append(grid_item_stack_ui)
	
		
func _on_item_middle_clicked(grid_item_stack_ui) -> void:
	var stack = grid_item_stack_ui.stack
	if !is_instance_valid(stack):
		return
	
	var stack_size : int = stack.amount
	var stack_index = inventory.stacks.find(stack)

	# All this floor/float jazz just to do integer division without warnings
	var new_stack_size: int = floor(float(stack_size) / 2)
	request_split.emit(inventory, stack_index, new_stack_size)


func _on_item_clicked(grid_item_stack_ui) -> void:
	var stack = grid_item_stack_ui.stack
	if !is_instance_valid(stack):
			return
	
	if Input.is_action_pressed("ui_inventory_transfer"):
		var stack_position : Vector2i = inventory.get_stack_position(stack)
		#TODO make rotation with R key or mouse wheel
		var _is_rotated: bool = inventory.is_stack_rotated(stack)
		
		request_fast_transfer.emit(inventory, stack_position, stack.amount)
	else:
		
		if select_mode == SelectMode.SELECT_MULTI && Input.is_key_pressed(KEY_CTRL):
			if !_is_item_selected(stack):
				_select(grid_item_stack_ui)
			else:
				_deselect(grid_item_stack_ui)
		else:
			_clear_selection()
			_select(grid_item_stack_ui)


func _on_item_grab(_offset: Vector2, _grid_item_stack_ui: GridItemStackUI) -> void:
	_clear_selection()


func _on_item_context_activated(event: InputEvent, grid_item_stack_ui: GridItemStackUI) -> void:
	var stack = grid_item_stack_ui.stack
	if !stack:
		return

	inventory_stack_context_activated.emit(event, inventory, stack)


func _on_dragable_dropped(dragable: GridDraggableElementUI, drop_position: Vector2) -> void:
	var stack: ItemStack = dragable.stack
	if stack == null:
		return

	if !is_instance_valid(inventory):
		return

	_handle_stack_transfer(stack, drop_position, dragable.inventory)


func _handle_stack_transfer(stack: ItemStack, drop_position: Vector2, source_inventory : Inventory) -> void:
	var grid_slot_coords = get_grid_slot_coords(drop_position + (grid_slot_size / 2))
	
	if source_inventory == null:
		printerr("source_inventory is null?")
		return
	
	if source_inventory.database != inventory.database:
		return
		
	var stack_position : Vector2i = source_inventory.get_stack_position(stack)
	#TODO make rotation with R key or mouse wheel
	var is_rotated: bool = source_inventory.is_stack_rotated(stack)
	request_transfer_to.emit(source_inventory, stack_position, inventory, grid_slot_coords, stack.amount, is_rotated)


#region Stack UI Utils
func get_stack_rect(stack: ItemStack) -> Rect2:
	if !is_instance_valid(stack):
		return Rect2()
	return Rect2(
		_get_grid_slot_position(inventory.get_stack_position(stack)),
		_get_stack_sprite_size(stack)
	)


func _get_stack_sprite_size(stack: ItemStack) -> Vector2:
	var item_size: Vector2i = inventory.get_stack_size(stack)
	var sprite_size := Vector2(item_size) * grid_slot_size
	# Also take item spacing into consideration
	sprite_size += (Vector2(item_size) - Vector2.ONE) * item_spacing
	return sprite_size


func _get_grid_slot_position(grid_slot_coords: Vector2i) -> Vector2:
	var grid_slot_position = Vector2(grid_slot_coords.x * grid_slot_size.x, \
		grid_slot_coords.y * grid_slot_size.y)
	grid_slot_position += Vector2(item_spacing * grid_slot_coords)
	return grid_slot_position


func _get_inventory_size_pixels() -> Vector2:
	if !is_instance_valid(inventory):
		return Vector2.ZERO

	var result := Vector2(inventory.size.x * grid_slot_size.x, \
		inventory.size.y * grid_slot_size.y)

	# Also take item spacing into consideration
	result += Vector2(inventory.size - Vector2i.ONE) * item_spacing

	return result
#endregion

#region Selected Stacks
func _on_selection_changed() -> void:
	_handle_selection_change()
	selection_changed.emit()


func _handle_selection_change() -> void:
	if !is_instance_valid(inventory):
		return

	for stack_ui in _stack_uis:
		if stack_ui:
			_set_selected_grid_slots(inventory.get_stack_rect(stack_ui.stack), stack_ui in get_selected_stacks())


func _is_item_selected(stack: ItemStack) -> bool:
	return stack in _selected_stacks


func _select(stack_ui: GridItemStackUI) -> void:
	var stack = stack_ui.stack
	if stack in _selected_stacks:
		return

	if stack != null && !inventory.has_stack(stack):
		return

	_selected_stacks.append(stack_ui)
	_on_selection_changed()
	stack_ui.select()
	
	
func _deselect(stack_ui: GridItemStackUI) -> void:
	var stack = stack_ui.stack
	if !(stack in _selected_stacks):
		return
	var idx := _selected_stacks.find(stack_ui)
	if idx < 0:
		return
	_selected_stacks.remove_at(idx)
	_on_selection_changed()
	stack_ui.unselect()


func _clear_selection() -> void:
	if _selected_stacks.is_empty():
		return
	for selected_stack in _selected_stacks:
		if is_instance_valid(selected_stack):
			selected_stack.unselect()
	_selected_stacks.clear()
	selection_changed.emit()
	
	
func _on_item_activated(grid_item_stack_ui: GridItemStackUI) -> void:
	var stack = grid_item_stack_ui.stack
	if !stack:
		return

	inventory_item_activated.emit(stack)
#endregion
#endregion
</file>

<file path="godot-coop/addons/inventory-system-demos/ui/grid/grid_selection_panel.gd">
extends Panel
class_name GridSelectionPanel

func set_style(style: StyleBox) -> void:
	remove_theme_stylebox_override("panel")
	if style != null:
		add_theme_stylebox_override("panel", style)
</file>

<file path="godot-coop/addons/inventory-system-demos/ui/grid/grid_slot_ui.gd">
@tool
extends Panel
class_name GridSlotUI

enum StylePriority {HIGH = 0, MEDIUM = 1, LOW = 2}

@export var regular_style: StyleBox
@export var hover_style: StyleBox
@export var selected_style: StyleBox
var _styles: Array[StyleBox] = [null, null, null]
@onready var audio_stream_player: AudioStreamPlayer = $AudioStreamPlayer

@onready var category_icon: TextureRect = %CategoryIcon
var _grid_position: Vector2i
var inventory: GridInventory


var item_dragged: bool = false:
	set(value):
		pass
		#print("item_grabbed",value)
		
		
func setup(grid_position: Vector2i, new_inventory: GridInventory):
	self._grid_position = grid_position
	self.inventory = new_inventory


func select():
	if is_instance_valid(selected_style):
		_set_panel_style(selected_style)


func unselect():
	_set_panel_style(regular_style)


func _ready() -> void:
	_set_panel_style(regular_style)
	mouse_entered.connect(func():
		_set_panel_style(hover_style)
		audio_stream_player.play()
	)
	mouse_exited.connect(func():
		_set_panel_style(regular_style)
	)
	if inventory == null:
		return
	for i in inventory.grid_constraints:
		if i is CategoryGridInventoryConstraint:
			var category: String = i.get_category(_grid_position)
			if category != "" and inventory.database != null:
				var cat: ItemCategory = inventory.database.get_category_from_id(category)
				if cat != null:
					category_icon.visible = true
					category_icon.texture = cat.icon
					self_modulate = cat.color
					return
	self_modulate = Color.WHITE
	category_icon.visible = false


func set_style(style: StyleBox, priority: int = StylePriority.LOW) -> void:
	if priority > 2 || priority < 0:
		return
	if _styles[priority] == style:
		return

	#_styles[priority] = style
#
	#for i in range(0, 3):
		#if _styles[i] != null or i == 2:
			#_set_panel_style(_styles[i])
			#return


func _set_panel_style(style: StyleBox) -> void:
	remove_theme_stylebox_override("panel")
	if style != null:
		add_theme_stylebox_override("panel", style)
</file>

<file path="godot-coop/addons/inventory-system-demos/ui/hotbar/hotbar_slot_ui.gd">
extends Panel
class_name HotbarSlotUI

@onready var icon: TextureRect = %Icon
@onready var slot_index_label: Label = $SlotIndexLabel
@onready var selection_panel: Panel = $SelectionPanel
var stack: ItemStack
var database: InventoryDatabase
var inventory: Inventory
var default_size: Vector2


@export var texture_rect: Array[TextureRect]

func _ready() -> void:
	default_size = size


func set_selection(is_selected: bool):
	selection_panel.visible = is_selected


func _process(_delta: float) -> void:
	if database == null or stack == null:
		return
	var def = database.get_item(stack.item_id)
	if def == null:
		return

func update_info_with_stack(_database: InventoryDatabase, _stack: ItemStack, _inventory: Inventory, slot_indexes: PackedInt32Array):
	self.database = _database
	self.stack = _stack
	self.inventory = _inventory
	for i in texture_rect.size():
		texture_rect[i].visible = i == slot_indexes[0]
	var slot_text = ""
	for i in slot_indexes:
		slot_text += str(i + 1)
		if slot_indexes.size() != i + 1:
			slot_text += " "
	slot_index_label.text = slot_text
	
	if stack == null:
		icon.visible = false
		return
		
	var def = database.get_item(stack.item_id)
	if def == null:
		icon.visible = false
		size = default_size
		custom_minimum_size = default_size
		return
		
	size = Vector2(def.size.x * default_size.x, def.size.y * default_size.y)
	custom_minimum_size = Vector2(def.size.x * default_size.x, def.size.y * default_size.y)
		
	icon.visible = true
	icon.texture = def.icon
	icon.size = Vector2(def.size.x * default_size.x, def.size.y * default_size.y)
</file>

<file path="godot-coop/addons/inventory-system-demos/ui/hotbar/hotbar_ui.gd">
class_name HotbarUI
extends Control

## [PackedScene] which is used to instantiate [SlotUI] for each slot added in [Hotbar]
@export var slot_ui_scene: PackedScene

## Parent [Control] for the [SlotUI] instances
@export var slots_container: Container

var hotbar: Hotbar

var ui_stacks: Array[Panel]
# Group of slot indices for each UI (same order as ui_stacks)
var ui_stack_groups: Array[PackedInt32Array] = []


## Defines an [Hotbar] linked to this hotbar UI.
## This function disconnects signals from the previous [Inventory] and connects signals with new [Inventory]
func set_hotbar(new_hotbar: Hotbar):
	if new_hotbar != self.hotbar:
		if self.hotbar != null:
			self.hotbar.on_change_selection.disconnect(_on_changed_selection)
		self.hotbar = new_hotbar
		self.hotbar.on_change_selection.connect(_on_changed_selection)
		self.hotbar.equipped.connect(_on_equipped_stack)
		self.hotbar.unequipped.connect(_on_equipped_stack)
		_update_slots()
		_on_changed_selection(hotbar.selection_index)


func _on_changed_selection(_selection_index):
	_update_selection()


func _update_selection():
	if hotbar == null:
		return
	# Highlight only the grouped UI that contains the current selection index
	for i in ui_stacks.size():
		var ui_stack: Panel = ui_stacks[i]
		var group: PackedInt32Array = ui_stack_groups[i]
		var selected := group.has(hotbar.selection_index)
		if ui_stack.has_method("set_selection"):
			ui_stack.set_selection(selected)


func _on_equipped_stack(_slot_index: int):
	_update_slots()


func _update_slots():
	# Clear previous UI
	for ui_stack in ui_stacks:
		ui_stack.queue_free()
	ui_stacks.clear()
	ui_stack_groups.clear()

	if hotbar == null:
		return

	# Map stacks to all slot indices they occupy (group duplicates)
	var stack_groups := { }  # key: instance_id (int) or "empty:<slot>" string; value: PackedInt32Array
	for i in hotbar.max_slots:
		var stack := hotbar.get_stack_on_slot(i)
		if stack != null and stack.has_valid():
			var key := str(stack.get_instance_id())
			if not stack_groups.has(key):
				stack_groups[key] = PackedInt32Array()
			stack_groups[key].append(i)
		else:
			# Keep empty/inactive slots as unique entries so UI still shows them
			var key_empty := "empty:%d" % i
			stack_groups[key_empty] = PackedInt32Array([i])

	# Create one UI per group (first slot is the primary index)
	for key in stack_groups.keys():
		var indices: PackedInt32Array = stack_groups[key]
		var primary_index := indices[0]
		var stack := hotbar.get_stack_on_slot(primary_index)

		var stack_ui: HotbarSlotUI = slot_ui_scene.instantiate()
		slots_container.add_child(stack_ui)

		stack_ui.update_info_with_stack(hotbar.database, stack, hotbar.get_inventory(), indices)

		# Visible if any covered slot is active (or at least the primary is active)
		var any_active := false
		for idx in indices:
			if hotbar.is_active_slot(idx):
				any_active = true
				break
		stack_ui.visible = any_active

		ui_stacks.append(stack_ui)
		ui_stack_groups.append(indices)

	_update_selection()
</file>

<file path="godot-coop/addons/inventory-system-demos/ui/interactor/action_message_ui.gd">
class_name ActionMessageUI
extends HBoxContainer

@export var input_helper : InputHelper
@export var input_icons : InputIcons
@export var texture_rect : TextureRect
@export var interact_message : Label
@export var action_input : String:
	set(value):
		action_input = value
		setup_icon(value)
@export var description : String:
	set(value):
		description = value
		setup_description(value)
		


func setup_icon(input_text : String):
	var action_0_events : Array[InputEvent] = InputMap.action_get_events(input_text)
	if action_0_events.is_empty():
		return
	var action_0_event_0 : InputEvent = action_0_events[0]
	var texture = input_helper.get_event_as_icon(action_0_event_0, input_icons)
	texture_rect.visible = true
	texture_rect.texture = texture


func setup_description(new_description : String):
	interact_message.text = new_description


func hide_message():
	visible = false


func show_message(new_action_input : String, new_description : String):
	self.action_input = new_action_input
	self.description = new_description
	visible = true
</file>

<file path="godot-coop/addons/inventory-system-demos/ui/interactor/input_icons.gd">
################################################################################
# MIT License
# Copyright (c) 2021 PunchablePlushie
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

@tool
class_name InputIcons
extends Resource

var property_map: Dictionary = {
	"keycodes": {
		67: "c",
		69: "e",
		73: "i",
		70: "l",
		82: "r",
		84: "t",
		4194332: "f1",
		4194333: "f2",
		4194334: "f3",
		4194335: "f4",
		4194336: "f5",
		4194337: "f6",
		4194338: "f7",
		4194339: "f8",
		4194340: "f9",
		4194341: "f10",
		4194342: "f11",
		4194343: "f12",
	},
	
	"mouse_button": [
		"lmb", "rmb", "mmb", "mw_up", "mw_down", "mw_left", "mw_right", "mb1", "mb2"
	],
	
	"gp_button": [
		"bot", "right", "left", "top",
		"back", "guide", "start",
		"left_stick", "right_stick",
		"left_shoulder", "right_shoulder",
		"dup", "ddown", "dleft", "dright",
		"misc", "pad1", "pad2", "pad3", "pad4",
		"touch"
	],
	
	"gp_motion": [
		{"-": "ls_left", "+": "ls_right"},
		{"-": "ls_down", "+": "ls_up"},
		{"-": "rs_left", "+": "rs_right"},
		{"-": "rs_down", "+": "rs_up"},
		{"+": "left_trigger"},
		{"+": "right_trigger"},
	],
}


@export_category("Icon Database")
@export_group("Keyboard", "keyboard_")
@export var keyboard_c: Texture2D  # 67
@export var keyboard_e: Texture2D  # 69
@export var keyboard_i: Texture2D  # 73
@export var keyboard_r: Texture2D  # 82
@export var keyboard_t: Texture2D  # 84
@export var keyboard_f1: Texture2D  # 4194332
@export var keyboard_f2: Texture2D  # 4194333
@export var keyboard_f3: Texture2D  # 4194334
@export var keyboard_f4: Texture2D  # 4194335
@export var keyboard_f5: Texture2D  # 4194336
@export var keyboard_f6: Texture2D  # 4194337
@export var keyboard_f7: Texture2D  # 4194338
@export var keyboard_f8: Texture2D  # 4194339
@export var keyboard_f9: Texture2D  # 4194340
@export var keyboard_f10: Texture2D  # 4194341
@export var keyboard_f11: Texture2D  # 4194342
@export var keyboard_f12: Texture2D  # 4194343



@export_group("Mouse", "mouse_")
@export var mouse_lmb: Texture2D
@export var mouse_rmb: Texture2D
@export var mouse_mmb: Texture2D
@export var mouse_mw_up: Texture2D
@export var mouse_mw_down: Texture2D
@export var mouse_mw_left: Texture2D
@export var mouse_mw_right: Texture2D
@export var mouse_mb1: Texture2D
@export var mouse_mb2: Texture2D


@export_group("XBox", "xbox_")
@export_subgroup("XBox Motions", "xbox_")
@export var xbox_ls_left: Texture2D
@export var xbox_ls_right: Texture2D
@export var xbox_ls_up: Texture2D
@export var xbox_ls_down: Texture2D
@export var xbox_rs_left: Texture2D
@export var xbox_rs_right: Texture2D
@export var xbox_rs_up: Texture2D
@export var xbox_rs_down: Texture2D
@export var xbox_left_trigger: Texture2D
@export var xbox_right_trigger: Texture2D
@export_subgroup("XBox Buttons", "xbox_")
@export var xbox_bot: Texture2D
@export var xbox_right: Texture2D
@export var xbox_left: Texture2D
@export var xbox_top: Texture2D
@export var xbox_back: Texture2D
@export var xbox_guide: Texture2D
@export var xbox_start: Texture2D
@export var xbox_left_stick: Texture2D
@export var xbox_right_stick: Texture2D
@export var xbox_left_shoulder: Texture2D
@export var xbox_right_shoulder: Texture2D
@export var xbox_dup: Texture2D
@export var xbox_ddown: Texture2D
@export var xbox_dleft: Texture2D
@export var xbox_dright: Texture2D
@export var xbox_misc: Texture2D
@export var xbox_pad1: Texture2D
@export var xbox_pad2: Texture2D
@export var xbox_pad3: Texture2D
@export var xbox_pad4: Texture2D
@export var xbox_touch: Texture2D

@export_group("Playstation", "ps_")
@export_subgroup("PS Motions", "ps_")
@export var ps_ls_left: Texture2D
@export var ps_ls_right: Texture2D
@export var ps_ls_up: Texture2D
@export var ps_ls_down: Texture2D
@export var ps_rs_left: Texture2D
@export var ps_rs_right: Texture2D
@export var ps_rs_up: Texture2D
@export var ps_rs_down: Texture2D
@export var ps_left_trigger: Texture2D
@export var ps_right_trigger: Texture2D
@export_subgroup("PS Buttons", "ps_")
@export var ps_bot: Texture2D
@export var ps_right: Texture2D
@export var ps_left: Texture2D
@export var ps_top: Texture2D
@export var ps_back: Texture2D
@export var ps_guide: Texture2D
@export var ps_start: Texture2D
@export var ps_left_stick: Texture2D
@export var ps_right_stick: Texture2D
@export var ps_left_shoulder: Texture2D
@export var ps_right_shoulder: Texture2D
@export var ps_dup: Texture2D
@export var ps_ddown: Texture2D
@export var ps_dleft: Texture2D
@export var ps_dright: Texture2D
@export var ps_misc: Texture2D
@export var ps_pad1: Texture2D
@export var ps_pad2: Texture2D
@export var ps_pad3: Texture2D
@export var ps_pad4: Texture2D
@export var ps_touch: Texture2D

@export_group("Switch", "switch_")
@export_subgroup("Switch Motions", "switch_")
@export var switch_ls_left: Texture2D
@export var switch_ls_right: Texture2D
@export var switch_ls_up: Texture2D
@export var switch_ls_down: Texture2D
@export var switch_rs_left: Texture2D
@export var switch_rs_right: Texture2D
@export var switch_rs_up: Texture2D
@export var switch_rs_down: Texture2D
@export var switch_left_trigger: Texture2D
@export var switch_right_trigger: Texture2D
@export_subgroup("Switch Buttons", "switch_")
@export var switch_bot: Texture2D
@export var switch_right: Texture2D
@export var switch_left: Texture2D
@export var switch_top: Texture2D
@export var switch_back: Texture2D
@export var switch_guide: Texture2D
@export var switch_start: Texture2D
@export var switch_left_stick: Texture2D
@export var switch_right_stick: Texture2D
@export var switch_left_shoulder: Texture2D
@export var switch_right_shoulder: Texture2D
@export var switch_dup: Texture2D
@export var switch_ddown: Texture2D
@export var switch_dleft: Texture2D
@export var switch_dright: Texture2D
@export var switch_misc: Texture2D
@export var switch_pad1: Texture2D
@export var switch_pad2: Texture2D
@export var switch_pad3: Texture2D
@export var switch_pad4: Texture2D
@export var switch_touch: Texture2D

@export_group("Other", "other_")
@export_subgroup("Other Motions", "other_")
@export var other_ls_left: Texture2D
@export var other_ls_right: Texture2D
@export var other_ls_up: Texture2D
@export var other_ls_down: Texture2D
@export var other_rs_left: Texture2D
@export var other_rs_right: Texture2D
@export var other_rs_up: Texture2D
@export var other_rs_down: Texture2D
@export var other_left_trigger: Texture2D
@export var other_right_trigger: Texture2D
@export_subgroup("Other Buttons", "other_")
@export var other_bot: Texture2D
@export var other_right: Texture2D
@export var other_left: Texture2D
@export var other_top: Texture2D
@export var other_back: Texture2D
@export var other_guide: Texture2D
@export var other_start: Texture2D
@export var other_left_stick: Texture2D
@export var other_right_stick: Texture2D
@export var other_left_shoulder: Texture2D
@export var other_right_shoulder: Texture2D
@export var other_dup: Texture2D
@export var other_ddown: Texture2D
@export var other_dleft: Texture2D
@export var other_dright: Texture2D
@export var other_misc: Texture2D
@export var other_pad1: Texture2D
@export var other_pad2: Texture2D
@export var other_pad3: Texture2D
@export var other_pad4: Texture2D
@export var other_touch: Texture2D


func get_keyboard_button_texture(keycode: int) -> Texture2D:
	return get("keyboard_%s"%property_map["keycodes"][keycode])


func get_mouse_button_texture(button_index: int) -> Texture2D:
	return get("mouse_%s"%property_map["mouse_button"][button_index - 1])


func get_gp_button_texture(category: String, button_index: int) -> Texture2D:
	return get("%s_%s"%[category, property_map["gp_button"][button_index]])


func get_gp_motion_texture(category: String, axis: int, axis_dir: String) -> Texture2D:
	return get("%s_%s"%[category, property_map["gp_motion"][axis][axis_dir]])
</file>

<file path="godot-coop/addons/inventory-system-demos/ui/interactor/interactor_ui.gd">
class_name InteractorUI
extends Control

const Interactor = preload("../../interaction_system/inventory_interactor.gd")

@export var interact_messages : Array[ActionMessageUI]
@onready var interact_position : Control = $InteractPosition
var default_interact_message_position : Vector2
@export var interactor : Interactor
@export var input_icons : InputIcons

var interact_object
var interact_hand_object

func setup(_interactor : Interactor):
	if self.interactor != null:
		interactor.preview_interacted.disconnect(_on_preview_interacted)
	self.interactor = _interactor
	interactor.preview_interacted.connect(_on_preview_interacted)


func _ready():
	for i in interact_messages:
		i.input_icons = input_icons
		i.hide_message()
	default_interact_message_position = interact_position.position


func _on_preview_interacted(actions : Array, position_on_screen : Vector2):
	preview_interact(actions, position_on_screen)


func preview_interact(actions : Array, position_on_screen : Vector2):
	for i in interact_messages:
		i.visible = true
	if position_on_screen == Vector2.ZERO:
		interact_position.position = default_interact_message_position
	else:
		interact_position.position = position_on_screen
	for i in interact_messages.size():
		var interact_message = interact_messages[i]
		if i < actions.size():
			interact_message.show_message(actions[i].input, actions[i].description)
			
		else:
			interact_message.hide_message()
</file>

<file path="godot-coop/characters/common_components/gas/tag_container.gd">
class_name TagContainer
extends Node

signal tag_added(tag: StringName)
signal tag_removed(tag: StringName)

var active_tags: Dictionary = {}


func add_tag(tag: StringName) -> void:
	if multiplayer.is_server():
		_add_tag_logic(tag)
		_add_tag_rpc.rpc(tag)


func remove_tag(tag: StringName) -> void:
	if multiplayer.is_server():
		_remove_tag_logic(tag)
		_remove_tag_rpc.rpc(tag)


func has_tag(tag: StringName) -> bool:
	return active_tags.get(tag, 0) > 0


func _add_tag_logic(tag: StringName) -> void:
	var current_count = active_tags.get(tag, 0)
	active_tags[tag] = current_count + 1
	GlobalLogger.log("[TagContainer] Tag count for '", tag, "': ", current_count + 1)
	
	if current_count == 0:
		GlobalLogger.log("[TagContainer] Gained Tag: ", tag)
		tag_added.emit(tag)


func _remove_tag_logic(tag: StringName) -> void:
	var current_count = active_tags.get(tag, 0)
	
	if current_count > 0:
		active_tags[tag] = current_count - 1
		GlobalLogger.log("[TagContainer] Tag count for '", tag, "': ", current_count - 1)
		
		if active_tags[tag] == 0:
			active_tags.erase(tag)
			GlobalLogger.log("[TagContainer] Lost Tag: ", tag)
			tag_removed.emit(tag)


@rpc("authority", "call_remote", "reliable")
func _add_tag_rpc(tag: StringName) -> void:
	if not multiplayer.is_server():
		_add_tag_logic(tag)


@rpc("authority", "call_remote", "reliable")
func _remove_tag_rpc(tag: StringName) -> void:
	if not multiplayer.is_server():
		_remove_tag_logic(tag)
</file>

<file path="godot-coop/characters/npcs/human_dummy/human_npc.gd">
extends CharacterBase
</file>

<file path="godot-coop/characters/player/components/camera_follow.gd">
extends Camera3D
@export var lerp_speed := 5
@export var target_node : Node3D
@export var camera_x_offset: float = 0.5 # Offset lateral (derecha positivo, izquierda negativo)

func _ready() -> void:
	if is_multiplayer_authority():
		current = true
	else:
		current = false
		set_process(false)

func _process(delta: float) -> void:
	var target_pos = target_node.position
	
	target_pos.x += camera_x_offset
	
	position = lerp(position, target_pos, delta * lerp_speed)
</file>

<file path="godot-coop/characters/player/components/camera_spring_arm.gd">
extends Node3D

@export var mouse_sensivity := 0.0025
@onready var spring_arm_3d: SpringArm3D = $SpringArm3D


func _ready() -> void:
	if is_multiplayer_authority():
		Input.mouse_mode = Input.MOUSE_MODE_CAPTURED
	else: set_process(false)
	

func _input(event: InputEvent) -> void:
	if is_multiplayer_authority():
		if event is InputEventMouseMotion and Input.get_mouse_mode() == Input.MOUSE_MODE_CAPTURED:
			rotation.y -= event.relative.x * mouse_sensivity
			rotation.y = wrapf(rotation.y, 0.0, TAU)
			
			rotation.x -= event.relative.y * mouse_sensivity
			rotation.x = clamp(rotation.x, deg_to_rad(-90), deg_to_rad(30))
</file>

<file path="godot-coop/characters/player/components/coop_character_inventory_system_ui.gd">
extends Control
class_name CoopInventorySystemUI

var coop_character_inventory_system : CoopCharacterInventorySystem
@onready var player_inventory_ui: GridInventoryPanel = %GridInventoryPanel



func _ready() -> void:
	player_inventory_ui.visible = false


func setup(characterInventorySystem : CoopCharacterInventorySystem) -> void:
	self.coop_character_inventory_system = characterInventorySystem
	
	set_player_inventory(coop_character_inventory_system.main_inventory)
	coop_character_inventory_system.opened_inventory.connect(_on_open_inventory)

## Setup player inventories
func set_player_inventory(player_inventory : GridInventory):
	player_inventory_ui.inventory = player_inventory
	
# Open Inventory of player	
func _on_open_inventory(inventory : Inventory):
	#if character.main_inventory != inventory:
		#loot_inventory_ui.inventory = inventory
		#loot_inventory_ui.visible = true
		#alternative_inventory = loot_inventory_ui.inventory
	#else:
		_open_player_inventory()
func _open_player_inventory():
	player_inventory_ui.visible = true
</file>

<file path="godot-coop/characters/player/components/coop_character_inventory_system.gd">
@tool
@icon("res://addons/inventory-system-demos/icons/character_inventory_system.svg")
extends NodeInventories
class_name CoopCharacterInventorySystem

#region Signals
signal opened_inventory(inventory : Inventory)
#endregion
const Interactor = preload("res://addons/inventory-system-demos/interaction_system/inventory_interactor.gd")

var opened_inventories : Array[Inventory]

@export_group("ðŸ—ƒï¸ Inventory Nodes")

@onready var main_inventory: GridInventory = $Inventory
@onready var drop_parent: CharacterBody3D = $".."
@export_node_path var interactor_path := NodePath("Interactor")
@onready var interactor : Interactor = get_node(interactor_path)



@export_group("âŒ¨ï¸ Inputs")
## Change mouse state based on inventory status
@export var change_mouse_state : bool = true
@export var check_inputs : bool = true
@export var toggle_inventory_input : String = "toggle_inventory"

@export_group("ðŸ«´ Interact")
@export var can_interact : bool = true
@export var raycast : RayCast3D:
	set(value):
		raycast = value
		var _interactor = get_node(interactor_path)
		if _interactor != null and value != null:
			_interactor.raycast = value
@export var camera_3d : Camera3D:
	set(value):
		camera_3d = value
		var _interactor = get_node(interactor_path)
		if _interactor != null and value != null:
			_interactor.camera = value

func _ready():
	if Engine.is_editor_hint():
		return

func _physics_process(_delta : float):
	if Engine.is_editor_hint():
		return
	if not can_interact:
		return
	interactor.try_interact()



func _input(_event : InputEvent) -> void:
	if Engine.is_editor_hint():
		return
	if check_inputs:
		inventory_inputs()


func inventory_inputs() -> void:
	if Input.is_action_just_released(toggle_inventory_input):
		# Check if any inventory or craft statis is already open
		if not is_any_station_or_inventory_opened():
			open_main_inventory()
			pass

func open_main_inventory():
	open_inventory(main_inventory)

func is_any_station_or_inventory_opened() -> bool:
	return is_open_any_station() or is_open_main_inventory()

func pick_to_inventory(node : Node):
	if main_inventory == null:
		return

	if node == null:
		return

	if !node.get("is_pickable"):
		return

	var item_id = node.item_id
	var item_properties = node.item_properties
	var amount = node.amount

	if main_inventory.add(item_id, amount, item_properties, true) == 0:
		node.queue_free();
		return

	printerr("pick_to_inventory return false");


#region Open Inventories

func is_open_inventory(inventory : Inventory):
	return opened_inventories.find(inventory) != -1


func open_inventory(inventory: Inventory) -> void:
	if is_open_inventory(inventory):
		return
	add_open_inventory(inventory)


func add_open_inventory(inventory: Inventory) -> void:
	opened_inventories.append(inventory)
	opened_inventory.emit(inventory)
	if not is_open_main_inventory():
		#inventory.request_drop_obj.connect(_on_request_drop_obj)
		open_main_inventory()


func _check_inputs():
	if is_any_station_or_inventory_opened():
		Input.mouse_mode = Input.MOUSE_MODE_VISIBLE
	else:
		Input.mouse_mode = Input.MOUSE_MODE_CAPTURED

func is_open_main_inventory():
	return is_open_inventory(main_inventory)
#endregion
	
#region Open Craft Stations
func is_open_station(_station : CraftStation):
	# TODO: Add craft station logic
	return false
func is_open_any_station() -> bool:
	return false
	#return !opened_stations.is_empty()
#endregion
</file>

<file path="godot-coop/interactables/harvest_nodes/harvestable_data.gd">
class_name HarvestableData
extends Resource

@export_group("General")
@export var tier_name: String = "Common Resource"
@export var harvest_duration: float = 2.0

@export_group("Loot")
@export var loot_table_id: String = ""
@export var destroy_on_harvest: bool = true
@export var respawn_time: float = -1.0
</file>

<file path="godot-coop/interactables/items/ingredients/ingredient_base.gd">
extends ItemBase
</file>

<file path="godot-coop/interactables/loot_container/loot_container_data.gd">
class_name LootContainerData
extends Resource

@export_group("Loot Settings")
@export var loot_table_id: String = ""
@export var min_rolls: int = 2
@export var max_rolls: int = 5

@export_group("Search Mechanics")
@export var seconds_to_reveal_per_item: float = 1.5 # Tiempo por cada slot
@export var auto_search_on_open: bool = true # Si empieza a buscar solo al abrir
</file>

<file path="godot-coop/items/definitions/ability_grant.gd">
class_name AbilityGrant
extends Resource

@export var ability: GameplayAbility
# We use a string enum hint to make it easy to select in the inspector
@export_enum("None", "ability.primary", "ability.secondary", "ability.interact") var input_tag: String = "ability.primary"
</file>

<file path="godot-coop/items/definitions/ability_spec_handle.gd">
class_name AbilitySpecHandle
extends Resource

# Static counter for unique IDs across the session
static var _id_counter: int = 0

# Unique ID for this specific grant of an ability
var id: int
var ability_name: String

func _init(p_name: String = "UnknownAbility"):
	id = _id_counter
	_id_counter += 1
	ability_name = p_name

func _to_string() -> String:
	return "AbilityHandle[%s:%s]" % [id, ability_name]
</file>

<file path="godot-coop/items/definitions/effect_spec_handle.gd">
extends Resource
class_name EffectSpecHandle

static var _id_counter : int = 0

var id : int

var effect_name : String

func _init(p_effect_name : String) -> void:
	id = _id_counter
	_id_counter += 1
	effect_name = p_effect_name


func _to_string() -> String:
	return "Handle[%s:%s]" % [id, effect_name]
</file>

<file path="godot-coop/items/definitions/projectiles/fire_potion_projectile.gd">
extends ProjectileBase

class_name PotionProjectile
var has_exploded: bool = false
var hit_targets: Array = []

func on_impact(body: Node) -> void:
	if has_exploded:
		return
	if multiplayer.is_server():
		trigger_explosion_sequence()
		pass
	

func trigger_explosion_sequence() -> void:
	has_exploded = true
	freeze = true
	area_effect.monitoring = true
	
	### GAME LOGIC
	apply_area_effects()
	
	### VFX/SFX
	play_impact_effects.rpc()
	
	get_tree().create_timer(data.area_effect_duration).timeout.connect(on_effect_finished)
	

		
		

func apply_area_effects() -> void:

	var radius = data.blast_radius
	var shape = $AreaEffect/ExplosionShape.shape as SphereShape3D
	if shape:
		shape.radius = radius


func _apply_specific_effect(target: Node) -> void:
	if target.has_method("receive_gameplay_effects"):
		target.receive_gameplay_effects(data.effects)


func _on_timer_timeout() -> void:
	contact_monitor = true

@rpc("authority", "call_local", "reliable")
func play_impact_effects() -> void:
	visuals.visible = false
	$PhysicsShape.disabled = true
	impact_particles.emitting = true
	impact_sound.play()


func _on_area_effect_area_entered(area: Area3D) -> void:
	if not multiplayer.is_server(): return
	var target = area.get_parent()
	if target in hit_targets:
		return
	if not target.has_method("receive_gameplay_effects"): return
	hit_targets.append(target)
	
	_apply_specific_effect(target)

func on_effect_finished() -> void:
	area_effect.monitoring = false
	queue_free()
</file>

<file path="godot-coop/systems/log_helper/Logger.gd">
extends Node

# Al usar la anotaciÃ³n @vararg (en Godot 4) o simplemente 
# pasando un Array si prefieres, pero la forma mÃ¡s limpia es esta:
func log(arg1 = "", arg2 = "", arg3 = "", arg4 = "", arg5 = "") -> void:
	var id = multiplayer.get_unique_id()
	var prefijo = ""
	
	if id == 1:
		prefijo = "[SERVER]"
	else:
		prefijo = "[CLIENT %s]" % id
	
	# Metemos todos los argumentos en un array para procesarlos
	var parametros = [arg1, arg2, arg3, arg4, arg5]
	var mensaje_final = ""
	
	for p in parametros:
		if str(p) != "":
			mensaje_final += str(p) + " " # Espacio simple, o "\t" para estilo printt()
			
	print("%s %s" % [prefijo, mensaje_final.strip_edges()])
</file>

<file path="godot-coop/systems/network_manager.gd">
extends Node

const PORT := 4000
const IP_ADDRESS := "localhost"
var peer : ENetMultiplayerPeer

func start_server() -> void:
	peer = ENetMultiplayerPeer.new()
	peer.create_server(PORT)
	multiplayer.multiplayer_peer = peer
	multiplayer.peer_connected.connect(on_peer_connected)
	multiplayer.peer_disconnected.connect(on_peer_disconnected)
	
	
func connect_client() -> void:
	peer = ENetMultiplayerPeer.new()
	peer.create_client(IP_ADDRESS, PORT)
	multiplayer.multiplayer_peer = peer
	
func on_peer_connected(_client_id : int) -> void:
	print("client conected")

func on_peer_disconnected(_client_id : int) -> void:
	print("client disconnected")
</file>

<file path="godot-coop/test/unit-test/test_ability_manager.gd">
extends GutTest
## Tests for AbilityManager - handles granting, clearing, and activating GameplayAbilities

var _ability_manager: AbilityManager
var _effect_manager: EffectManager
var _tag_container: TagContainer
var _cast_manager: CastManager
var _attribute_set: GASAttributeSet
var _mock_actor: Node


func before_each() -> void:
	_tag_container = TagContainer.new()
	_attribute_set = GASAttributeSet.new()
	_effect_manager = EffectManager.new()
	_cast_manager = CastManager.new()
	_ability_manager = AbilityManager.new()
	_mock_actor = Node.new()
	
	add_child(_tag_container)
	add_child(_attribute_set)
	add_child(_effect_manager)
	add_child(_cast_manager)
	add_child(_ability_manager)
	add_child(_mock_actor)
	
	# Initialize components
	_effect_manager._ready()
	_effect_manager.setup(_attribute_set, _tag_container)
	_ability_manager.setup(_mock_actor, _effect_manager, _tag_container, _cast_manager)


func after_each() -> void:
	_ability_manager.queue_free()
	_cast_manager.queue_free()
	_effect_manager.queue_free()
	_attribute_set.queue_free()
	_tag_container.queue_free()
	_mock_actor.queue_free()


# Helper to create a test GameplayAbility
func _create_ability(ability_name: String, required_tags: PackedStringArray = [], 
		blocked_tags: PackedStringArray = []) -> GameplayAbility:
	var ability = GameplayAbility.new()
	ability.ability_name = ability_name
	ability.activation_required_tags = required_tags
	ability.activation_blocked_tags = blocked_tags
	return ability


func test_grant_ability() -> void:
	# Granting an ability should register it and return a handle
	var test_ability = _create_ability("Test Ability")
	
	var handle = _ability_manager._grant_ability_logic(test_ability, "ability.primary")
	
	assert_not_null(handle, "Should return a valid handle")
	assert_true(_ability_manager.granted_abilities.has(handle), "Ability should be registered")
	
	var spec = _ability_manager.granted_abilities[handle]
	assert_eq(spec.ability, test_ability, "Stored ability should match")
	assert_eq(spec.input_tag, "ability.primary", "Input tag should match")


func test_clear_ability() -> void:
	# Clearing an ability should remove it from granted_abilities
	var test_ability = _create_ability("Test Ability")
	var handle = _ability_manager._grant_ability_logic(test_ability, "ability.primary")
	
	assert_eq(_ability_manager.granted_abilities.size(), 1, "Should have one ability")
	
	_ability_manager._clear_ability_logic(handle)
	
	assert_eq(_ability_manager.granted_abilities.size(), 0, "Should have no abilities after clear")
	assert_false(_ability_manager.granted_abilities.has(handle), "Handle should be removed")


func test_can_activate_with_required_tags() -> void:
	# Ability with required tags should only activate when tags are present
	var ability_with_requirements = _create_ability(
		"Grounded Attack",
		PackedStringArray(["state.grounded"]),  # Requires grounded tag
		PackedStringArray()
	)
	
	# Without required tag - should NOT be able to activate
	assert_false(
		_ability_manager.can_activate_ability(ability_with_requirements),
		"Should not activate without required tag"
	)
	
	# Add the required tag
	_tag_container._add_tag_logic(&"state.grounded")
	
	# With required tag - should be able to activate
	assert_true(
		_ability_manager.can_activate_ability(ability_with_requirements),
		"Should activate with required tag"
	)


func test_can_activate_with_blocked_tags() -> void:
	# Ability with blocked tags should NOT activate when those tags are present
	var ability_blocked_by_stun = _create_ability(
		"Attack",
		PackedStringArray(),
		PackedStringArray(["state.stunned"])  # Blocked by stunned
	)
	
	# Without blocking tag - should be able to activate
	assert_true(
		_ability_manager.can_activate_ability(ability_blocked_by_stun),
		"Should activate without blocking tag"
	)
	
	# Add the blocking tag
	_tag_container._add_tag_logic(&"state.stunned")
	
	# With blocking tag - should NOT be able to activate
	assert_false(
		_ability_manager.can_activate_ability(ability_blocked_by_stun),
		"Should not activate with blocking tag"
	)


func test_ability_source_tracking() -> void:
	# get_ability_source should return the inventory and slot info
	var test_ability = _create_ability("Item Ability")
	
	# Create a mock inventory (just a Node for testing)
	var mock_inventory = Inventory.new()
	add_child(mock_inventory)
	
	var handle = _ability_manager._grant_ability_logic(
		test_ability, 
		"ability.primary",
		mock_inventory,
		2  # slot index
	)
	
	var source = _ability_manager.get_ability_source(handle)
	
	assert_eq(source["inventory"], mock_inventory, "Should return correct inventory")
	assert_eq(source["slot"], 2, "Should return correct slot index")
	
	# Test with non-existent handle
	var fake_handle = AbilitySpecHandle.new("Fake")
	var empty_source = _ability_manager.get_ability_source(fake_handle)
	assert_true(empty_source.is_empty(), "Should return empty dict for invalid handle")
	
	mock_inventory.queue_free()
</file>

<file path="godot-coop/test/unit-test/test_cast_manager.gd">
extends GutTest
## Tests for CastManager - handles channeled/casted abilities with duration

var _cast_manager: CastManager

# Tracking variables for callbacks (class-level to avoid lambda capture issues)
var _cancel_called: bool = false
var _complete_called: bool = false


func before_each() -> void:
	_cast_manager = CastManager.new()
	_cancel_called = false
	_complete_called = false
	add_child(_cast_manager)


func after_each() -> void:
	_cast_manager.queue_free()


func _on_cancel() -> void:
	_cancel_called = true


func _on_complete() -> void:
	_complete_called = true


func test_start_cast() -> void:
	# Starting a cast should register it in active_casts
	var handle = AbilitySpecHandle.new("Test Cast")
	
	_cast_manager._start_cast_logic(handle, 2.0, _on_complete)
	
	assert_true(_cast_manager.active_casts.has(handle), "Cast should be registered")
	assert_eq(_cast_manager.active_casts[handle].duration, 2.0, "Duration should match")
	assert_eq(_cast_manager.active_casts[handle].elapsed, 0.0, "Elapsed should start at 0")


func test_cancel_cast() -> void:
	# Cancelling a cast should call on_cancel and remove it
	var handle = AbilitySpecHandle.new("Cancelable Cast")
	
	_cast_manager._start_cast_logic(handle, 5.0, _on_complete, _on_cancel)
	assert_true(_cast_manager.has_active_cast(handle), "Cast should be active")
	
	_cast_manager._cancel_cast_logic(handle)
	
	assert_true(_cancel_called, "on_cancel callback should be called")
	assert_false(_cast_manager.has_active_cast(handle), "Cast should be removed after cancel")


func test_cast_completes() -> void:
	# Cast should call on_complete when duration is reached
	var handle = AbilitySpecHandle.new("Completing Cast")
	
	_cast_manager._start_cast_logic(handle, 2.0, _on_complete)
	
	# Simulate time passing (not enough to complete)
	_cast_manager._process_logic(1.0)
	assert_false(_complete_called, "on_complete should not be called yet")
	assert_true(_cast_manager.has_active_cast(handle), "Cast should still be active")
	
	# Simulate more time (enough to complete)
	_cast_manager._process_logic(1.5)
	assert_true(_complete_called, "on_complete should be called after duration")
	assert_false(_cast_manager.has_active_cast(handle), "Cast should be removed after completion")


func test_has_active_cast() -> void:
	# has_active_cast should correctly report cast status
	var handle = AbilitySpecHandle.new("Status Check Cast")
	
	assert_false(_cast_manager.has_active_cast(handle), "Should not have cast initially")
	
	_cast_manager._start_cast_logic(handle, 3.0, _on_complete)
	assert_true(_cast_manager.has_active_cast(handle), "Should have cast after starting")
	
	_cast_manager._cancel_cast_logic(handle)
	assert_false(_cast_manager.has_active_cast(handle), "Should not have cast after cancel")
</file>

<file path="godot-coop/test/unit-test/test_data_equipment.gd">
extends GutTest
## Tests for EquipmentData Resource structure and data integrity


func test_equipment_slot_types_enum() -> void:
	# Verify SlotType enum has all expected values
	assert_eq(EquipmentData.SlotType.HEAD, 0, "HEAD should be 0")
	assert_eq(EquipmentData.SlotType.CHEST, 1, "CHEST should be 1")
	assert_eq(EquipmentData.SlotType.HAND, 2, "HAND should be 2")
	assert_eq(EquipmentData.SlotType.BELT, 3, "BELT should be 3")
	
	# Test that equipment can use each slot type
	var equipment = EquipmentData.new()
	
	equipment.allowed_slots.clear()
	equipment.allowed_slots.append(EquipmentData.SlotType.HEAD)
	assert_true(EquipmentData.SlotType.HEAD in equipment.allowed_slots, "Should accept HEAD slot")
	
	equipment.allowed_slots.clear()
	equipment.allowed_slots.append(EquipmentData.SlotType.CHEST)
	assert_true(EquipmentData.SlotType.CHEST in equipment.allowed_slots, "Should accept CHEST slot")
	
	equipment.allowed_slots.clear()
	equipment.allowed_slots.append(EquipmentData.SlotType.HAND)
	assert_true(EquipmentData.SlotType.HAND in equipment.allowed_slots, "Should accept HAND slot")
	
	equipment.allowed_slots.clear()
	equipment.allowed_slots.append(EquipmentData.SlotType.BELT)
	assert_true(EquipmentData.SlotType.BELT in equipment.allowed_slots, "Should accept BELT slot")


func test_equipment_default_values() -> void:
	# Verify default values are correct for a new EquipmentData
	var equipment = EquipmentData.new()
	
	assert_true(equipment.allowed_slots is Array, "allowed_slots should be an Array")
	assert_eq(equipment.allowed_slots.size(), 0, "Default allowed_slots should be empty")
	assert_null(equipment.visual_scene, "Default visual_scene should be null")
	assert_eq(equipment.bone_name, "", "Default bone_name should be empty string")
	assert_true(equipment.passive_effects is Array, "passive_effects should be an Array")
	assert_eq(equipment.passive_effects.size(), 0, "Default passive_effects should be empty")
	assert_true(equipment.granted_abilities is Array, "granted_abilities should be an Array")
	assert_eq(equipment.granted_abilities.size(), 0, "Default granted_abilities should be empty")


func test_equipment_arrays_typed() -> void:
	# Verify arrays accept correct types
	var equipment = EquipmentData.new()
	
	# Test passive_effects accepts GameplayEffect
	var effect = GameplayEffect.new()
	effect.effect_name = "Armor Buff"
	effect.mode = GameplayEffect.ApplicationMode.INFINITE
	effect.target_attribute = "max_health"
	effect.operation = GameplayEffect.ModifierOp.ADD
	effect.value = 50.0
	
	equipment.passive_effects.append(effect)
	assert_eq(equipment.passive_effects.size(), 1, "Should have 1 passive effect")
	assert_eq(equipment.passive_effects[0].effect_name, "Armor Buff", "Effect should be Armor Buff")
	
	# Test granted_abilities accepts AbilityGrant
	var ability = GameplayAbility.new()
	ability.ability_name = "Sword Slash"
	
	var grant = AbilityGrant.new()
	grant.ability = ability
	grant.input_tag = "ability.primary"
	
	equipment.granted_abilities.append(grant)
	assert_eq(equipment.granted_abilities.size(), 1, "Should have 1 granted ability")
	assert_eq(equipment.granted_abilities[0].ability.ability_name, "Sword Slash", "Ability should be Sword Slash")
	assert_eq(equipment.granted_abilities[0].input_tag, "ability.primary", "Input tag should be ability.primary")


func test_equipment_can_have_multiple_slots() -> void:
	# Verify equipment can be assigned to multiple slot types (e.g., potion can go in HAND or BELT)
	var equipment = EquipmentData.new()
	
	# Single slot
	equipment.allowed_slots.append(EquipmentData.SlotType.HEAD)
	assert_eq(equipment.allowed_slots.size(), 1, "Should have 1 allowed slot")
	
	# Multiple slots (like a potion that can go in hand or belt)
	equipment.allowed_slots.clear()
	equipment.allowed_slots.append(EquipmentData.SlotType.HAND)
	equipment.allowed_slots.append(EquipmentData.SlotType.BELT)
	assert_eq(equipment.allowed_slots.size(), 2, "Should have 2 allowed slots")
	assert_true(EquipmentData.SlotType.HAND in equipment.allowed_slots, "Should allow HAND slot")
	assert_true(EquipmentData.SlotType.BELT in equipment.allowed_slots, "Should allow BELT slot")
	
	# All slots (hypothetical universal item)
	equipment.allowed_slots.clear()
	equipment.allowed_slots.append(EquipmentData.SlotType.HEAD)
	equipment.allowed_slots.append(EquipmentData.SlotType.CHEST)
	equipment.allowed_slots.append(EquipmentData.SlotType.HAND)
	equipment.allowed_slots.append(EquipmentData.SlotType.BELT)
	assert_eq(equipment.allowed_slots.size(), 4, "Should have 4 allowed slots")
</file>

<file path="godot-coop/test/unit-test/test_data_gameplay_ability.gd">
extends GutTest
## Tests for GameplayAbility Resource structure and data integrity


func test_ability_default_values() -> void:
	# Verify default values are correct for a new GameplayAbility
	var ability = GameplayAbility.new()
	
	assert_eq(ability.ability_name, "Base Ability", "Default ability_name should be 'Base Ability'")
	assert_true(ability.activation_required_tags is PackedStringArray, "activation_required_tags should be PackedStringArray")
	assert_eq(ability.activation_required_tags.size(), 0, "Default activation_required_tags should be empty")
	assert_true(ability.activation_blocked_tags is PackedStringArray, "activation_blocked_tags should be PackedStringArray")
	assert_eq(ability.activation_blocked_tags.size(), 0, "Default activation_blocked_tags should be empty")


func test_ability_tags_are_arrays() -> void:
	# Verify tags can be set and are proper PackedStringArray
	var ability = GameplayAbility.new()
	
	# Set required tags
	ability.activation_required_tags = PackedStringArray(["state.grounded", "state.alive"])
	assert_eq(ability.activation_required_tags.size(), 2, "Should have 2 required tags")
	assert_true("state.grounded" in ability.activation_required_tags, "Should contain grounded tag")
	assert_true("state.alive" in ability.activation_required_tags, "Should contain alive tag")
	
	# Set blocked tags
	ability.activation_blocked_tags = PackedStringArray(["state.stunned", "state.dead", "state.casting"])
	assert_eq(ability.activation_blocked_tags.size(), 3, "Should have 3 blocked tags")
	assert_true("state.stunned" in ability.activation_blocked_tags, "Should contain stunned tag")
	assert_true("state.dead" in ability.activation_blocked_tags, "Should contain dead tag")
	assert_true("state.casting" in ability.activation_blocked_tags, "Should contain casting tag")


func test_ability_ongoing_effects_type() -> void:
	# Verify ongoing_effects is properly typed array
	var ability = GameplayAbility.new()
	
	# Default should be empty array
	assert_true(ability.ongoing_effects is Array, "ongoing_effects should be an Array")
	assert_eq(ability.ongoing_effects.size(), 0, "Default ongoing_effects should be empty")
	
	# Create and add effects
	var effect1 = GameplayEffect.new()
	effect1.effect_name = "Ongoing Buff"
	effect1.mode = GameplayEffect.ApplicationMode.INFINITE
	effect1.target_attribute = "speed"
	effect1.operation = GameplayEffect.ModifierOp.ADD
	effect1.value = 2.0
	
	var effect2 = GameplayEffect.new()
	effect2.effect_name = "Ongoing Tag"
	effect2.mode = GameplayEffect.ApplicationMode.INFINITE
	effect2.target_attribute = "none"
	effect2.granted_tags = PackedStringArray(["state.aiming"])
	
	ability.ongoing_effects.append(effect1)
	ability.ongoing_effects.append(effect2)
	
	assert_eq(ability.ongoing_effects.size(), 2, "Should have 2 ongoing effects")
	assert_eq(ability.ongoing_effects[0].effect_name, "Ongoing Buff", "First effect should be Ongoing Buff")
	assert_eq(ability.ongoing_effects[1].effect_name, "Ongoing Tag", "Second effect should be Ongoing Tag")


func test_ability_virtual_methods_exist() -> void:
	# Verify that virtual methods exist and can be called
	var ability = GameplayAbility.new()
	
	# Check methods exist
	assert_true(ability.has_method("can_activate"), "Should have can_activate method")
	assert_true(ability.has_method("activate"), "Should have activate method")
	assert_true(ability.has_method("input_released"), "Should have input_released method")
	assert_true(ability.has_method("end_ability"), "Should have end_ability method")
	
	# Create a mock actor node for testing
	var mock_actor = Node.new()
	add_child(mock_actor)
	
	# Test that methods can be called without crashing
	# Note: can_activate needs an AbilitySystemComponent, so it will return false
	var can_activate_result = ability.can_activate(mock_actor)
	assert_false(can_activate_result, "can_activate should return false without ASC")
	
	# Create a mock handle
	var mock_handle = AbilitySpecHandle.new("TestAbility")
	
	# These should not crash when called (they are virtual/base implementations)
	ability.activate(mock_actor, mock_handle, {})
	ability.input_released(mock_actor, mock_handle)
	ability.end_ability(mock_actor, mock_handle)
	
	# If we got here without crashing, the methods work
	assert_true(true, "Virtual methods can be called without crashing")
	
	mock_actor.queue_free()
</file>

<file path="godot-coop/test/unit-test/test_data_gameplay_effect.gd">
extends GutTest
## Tests for GameplayEffect Resource structure and data integrity


func test_effect_default_values() -> void:
	# Verify default values are correct for a new GameplayEffect
	var effect = GameplayEffect.new()
	
	assert_eq(effect.target_attribute, "", "Default target_attribute should be empty string")
	assert_eq(effect.operation, GameplayEffect.ModifierOp.SUBTRACT, "Default operation should be SUBTRACT")
	assert_eq(effect.value, 10.0, "Default value should be 10.0")
	assert_eq(effect.mode, GameplayEffect.ApplicationMode.INSTANT, "Default mode should be INSTANT")
	assert_eq(effect.duration, 0.0, "Default duration should be 0.0")
	assert_eq(effect.tick_rate, 1.0, "Default tick_rate should be 1.0")
	assert_eq(effect.effect_name, "Generic Effect", "Default effect_name should be 'Generic Effect'")
	assert_eq(effect.vfx_tag, "", "Default vfx_tag should be empty")
	assert_true(effect.granted_tags is PackedStringArray, "granted_tags should be PackedStringArray")
	assert_eq(effect.granted_tags.size(), 0, "Default granted_tags should be empty")


func test_effect_modes_enum() -> void:
	# Verify ApplicationMode enum has all expected values
	assert_eq(GameplayEffect.ApplicationMode.INSTANT, 0, "INSTANT should be 0")
	assert_eq(GameplayEffect.ApplicationMode.PERIODIC, 1, "PERIODIC should be 1")
	assert_eq(GameplayEffect.ApplicationMode.DURATION, 2, "DURATION should be 2")
	assert_eq(GameplayEffect.ApplicationMode.INFINITE, 3, "INFINITE should be 3")
	
	# Test that we can create effects with each mode
	var effect = GameplayEffect.new()
	
	effect.mode = GameplayEffect.ApplicationMode.INSTANT
	assert_eq(effect.mode, GameplayEffect.ApplicationMode.INSTANT, "Should accept INSTANT mode")
	
	effect.mode = GameplayEffect.ApplicationMode.PERIODIC
	assert_eq(effect.mode, GameplayEffect.ApplicationMode.PERIODIC, "Should accept PERIODIC mode")
	
	effect.mode = GameplayEffect.ApplicationMode.DURATION
	assert_eq(effect.mode, GameplayEffect.ApplicationMode.DURATION, "Should accept DURATION mode")
	
	effect.mode = GameplayEffect.ApplicationMode.INFINITE
	assert_eq(effect.mode, GameplayEffect.ApplicationMode.INFINITE, "Should accept INFINITE mode")


func test_effect_operations_enum() -> void:
	# Verify ModifierOp enum has all expected values
	assert_eq(GameplayEffect.ModifierOp.ADD, 0, "ADD should be 0")
	assert_eq(GameplayEffect.ModifierOp.SUBTRACT, 1, "SUBTRACT should be 1")
	assert_eq(GameplayEffect.ModifierOp.MULTIPLY, 2, "MULTIPLY should be 2")
	assert_eq(GameplayEffect.ModifierOp.DIVIDE, 3, "DIVIDE should be 3")
	
	# Test that we can create effects with each operation
	var effect = GameplayEffect.new()
	
	effect.operation = GameplayEffect.ModifierOp.ADD
	assert_eq(effect.operation, GameplayEffect.ModifierOp.ADD, "Should accept ADD operation")
	
	effect.operation = GameplayEffect.ModifierOp.SUBTRACT
	assert_eq(effect.operation, GameplayEffect.ModifierOp.SUBTRACT, "Should accept SUBTRACT operation")
	
	effect.operation = GameplayEffect.ModifierOp.MULTIPLY
	assert_eq(effect.operation, GameplayEffect.ModifierOp.MULTIPLY, "Should accept MULTIPLY operation")
	
	effect.operation = GameplayEffect.ModifierOp.DIVIDE
	assert_eq(effect.operation, GameplayEffect.ModifierOp.DIVIDE, "Should accept DIVIDE operation")


func test_effect_valid_attributes() -> void:
	# Verify that valid attributes are defined in GASAttributeSet
	var valid_attrs = GASAttributeSet.VALID_ATTRIBUTES
	
	assert_true(valid_attrs is PackedStringArray, "VALID_ATTRIBUTES should be PackedStringArray")
	assert_true(valid_attrs.size() > 0, "Should have at least one valid attribute")
	
	# Check expected attributes exist
	assert_true("health" in valid_attrs, "health should be a valid attribute")
	assert_true("max_health" in valid_attrs, "max_health should be a valid attribute")
	assert_true("speed" in valid_attrs, "speed should be a valid attribute")
	
	# Test setting target_attribute to valid values
	var effect = GameplayEffect.new()
	
	effect.target_attribute = "health"
	assert_eq(effect.target_attribute, "health", "Should accept 'health' as target")
	
	effect.target_attribute = "none"
	assert_eq(effect.target_attribute, "none", "Should accept 'none' for tag-only effects")
	
	effect.target_attribute = ""
	assert_eq(effect.target_attribute, "", "Should accept empty string for tag-only effects")


func test_effect_tag_only_mode() -> void:
	# Verify effects can work without targeting an attribute (tag-only)
	var tag_effect = GameplayEffect.new()
	tag_effect.effect_name = "Burning Status"
	tag_effect.target_attribute = "none"
	tag_effect.mode = GameplayEffect.ApplicationMode.DURATION
	tag_effect.duration = 5.0
	tag_effect.granted_tags = PackedStringArray(["state.burning", "debuff.fire"])
	
	assert_eq(tag_effect.target_attribute, "none", "Tag-only effect should have 'none' as target")
	assert_eq(tag_effect.granted_tags.size(), 2, "Should have 2 granted tags")
	assert_true("state.burning" in tag_effect.granted_tags, "Should contain burning tag")
	assert_true("debuff.fire" in tag_effect.granted_tags, "Should contain fire debuff tag")
	
	# Also test with empty string
	var tag_effect2 = GameplayEffect.new()
	tag_effect2.target_attribute = ""
	tag_effect2.granted_tags = PackedStringArray(["state.stunned"])
	
	assert_eq(tag_effect2.target_attribute, "", "Tag-only effect can use empty string")
	assert_eq(tag_effect2.granted_tags.size(), 1, "Should have 1 granted tag")
</file>

<file path="godot-coop/test/unit-test/test_data_integrity.gd">
extends GutTest
## Tests for data integrity - verifies all .tres files load correctly
## These tests catch breaking changes in Resource structure


func test_load_all_gameplay_effects() -> void:
	# Verify all GameplayEffect .tres files load without errors
	var effect_paths = [
		"res://items/definitions/gameplay_effects/GE_HealOverTime.tres",
		"res://items/definitions/gameplay_effects/GE_InstantDamage_10.tres",
	]
	
	for path in effect_paths:
		var effect = load(path)
		assert_not_null(effect, "Should load effect: " + path)
		if effect:
			assert_true(effect is GameplayEffect, path + " should be GameplayEffect")
			assert_ne(effect.effect_name, "", path + " should have effect_name")


func test_load_all_equipment_data() -> void:
	# Verify all EquipmentData .tres files load without errors
	var equipment_paths = [
		"res://items/definitions/equipment/EqData_FirePotion.tres",
		"res://items/definitions/equipment/EqData_HealPotion.tres",
		"res://items/definitions/equipment/EqData_PoisonPotion.tres",
	]
	
	for path in equipment_paths:
		var equipment = load(path)
		assert_not_null(equipment, "Should load equipment: " + path)
		if equipment:
			assert_true(equipment is EquipmentData, path + " should be EquipmentData")
			assert_gt(equipment.allowed_slots.size(), 0, path + " should have at least one allowed slot")


func test_load_all_potion_data() -> void:
	# Verify all PotionData .tres files load without errors
	var potion_paths = [
		"res://items/definitions/potion/FirePotionStats.tres",
		"res://items/definitions/potion/HealPotionStats.tres",
	]
	
	for path in potion_paths:
		var potion = load(path)
		assert_not_null(potion, "Should load potion: " + path)
		if potion:
			assert_true(potion is PotionData, path + " should be PotionData")
			assert_gt(potion.throw_force, 0.0, path + " should have positive throw_force")


func test_equipment_references_valid() -> void:
	# Verify that EquipmentData references (abilities, effects) are valid
	var equipment_paths = [
		"res://items/definitions/equipment/EqData_FirePotion.tres",
		"res://items/definitions/equipment/EqData_HealPotion.tres",
		"res://items/definitions/equipment/EqData_PoisonPotion.tres",
	]
	
	for path in equipment_paths:
		var equipment = load(path) as EquipmentData
		if not equipment:
			continue
		
		# Check passive_effects are valid GameplayEffect
		for i in range(equipment.passive_effects.size()):
			var effect = equipment.passive_effects[i]
			assert_not_null(effect, path + " passive_effects[" + str(i) + "] should not be null")
			if effect:
				assert_true(effect is GameplayEffect, path + " passive_effects[" + str(i) + "] should be GameplayEffect")
		
		# Check granted_abilities are valid AbilityGrant with valid ability
		for i in range(equipment.granted_abilities.size()):
			var grant = equipment.granted_abilities[i]
			assert_not_null(grant, path + " granted_abilities[" + str(i) + "] should not be null")
			if grant:
				assert_true(grant is AbilityGrant, path + " granted_abilities[" + str(i) + "] should be AbilityGrant")
				assert_not_null(grant.ability, path + " granted_abilities[" + str(i) + "].ability should not be null")
				if grant.ability:
					assert_true(grant.ability is GameplayAbility, path + " ability should be GameplayAbility")
					assert_ne(grant.input_tag, "", path + " should have input_tag")
</file>

<file path="godot-coop/test/unit-test/test_data_potion.gd">
extends GutTest
## Tests for PotionData Resource structure and data integrity


func test_potion_default_values() -> void:
	# Verify default values are correct for a new PotionData
	var potion = PotionData.new()
	
	# Physics & Visuals
	assert_null(potion.projectile_scene, "Default projectile_scene should be null")
	assert_eq(potion.throw_force, 15.0, "Default throw_force should be 15.0")
	
	# Explosion Settings
	assert_eq(potion.blast_radius, 3.0, "Default blast_radius should be 3.0")
	assert_eq(potion.area_effect_duration, 0.5, "Default area_effect_duration should be 0.5")
	
	# Gameplay Effects
	assert_true(potion.effects is Array, "effects should be an Array")
	assert_eq(potion.effects.size(), 0, "Default effects should be empty")
	
	# Inventory Item Settings
	assert_true(potion.consume_on_use, "Default consume_on_use should be true")
	
	# Drink Properties
	assert_eq(potion.drink_animation_name, "drink_potion", "Default drink_animation_name should be 'drink_potion'")
	assert_true(potion.consumed_effects is Array, "consumed_effects should be an Array")
	assert_eq(potion.consumed_effects.size(), 0, "Default consumed_effects should be empty")
	assert_eq(potion.drink_duration, 1.5, "Default drink_duration should be 1.5")


func test_potion_effects_arrays() -> void:
	# Verify effects and consumed_effects accept GameplayEffect
	var potion = PotionData.new()
	
	# Create throw/splash effects (applied to targets hit)
	var fire_effect = GameplayEffect.new()
	fire_effect.effect_name = "Fire Damage"
	fire_effect.mode = GameplayEffect.ApplicationMode.PERIODIC
	fire_effect.target_attribute = "health"
	fire_effect.operation = GameplayEffect.ModifierOp.SUBTRACT
	fire_effect.value = 5.0
	fire_effect.duration = 3.0
	fire_effect.tick_rate = 1.0
	fire_effect.granted_tags = PackedStringArray(["state.burning"])
	
	var burn_tag = GameplayEffect.new()
	burn_tag.effect_name = "Burning Status"
	burn_tag.mode = GameplayEffect.ApplicationMode.DURATION
	burn_tag.target_attribute = "none"
	burn_tag.duration = 5.0
	burn_tag.granted_tags = PackedStringArray(["state.fire", "debuff.dot"])
	
	potion.effects.append(fire_effect)
	potion.effects.append(burn_tag)
	assert_eq(potion.effects.size(), 2, "Should have 2 throw effects")
	assert_eq(potion.effects[0].effect_name, "Fire Damage", "First effect should be Fire Damage")
	assert_eq(potion.effects[1].effect_name, "Burning Status", "Second effect should be Burning Status")
	
	# Create drink/consumed effects (applied to self)
	var heal_effect = GameplayEffect.new()
	heal_effect.effect_name = "Heal"
	heal_effect.mode = GameplayEffect.ApplicationMode.INSTANT
	heal_effect.target_attribute = "health"
	heal_effect.operation = GameplayEffect.ModifierOp.ADD
	heal_effect.value = 50.0
	
	potion.consumed_effects.append(heal_effect)
	assert_eq(potion.consumed_effects.size(), 1, "Should have 1 consumed effect")
	assert_eq(potion.consumed_effects[0].effect_name, "Heal", "Consumed effect should be Heal")


func test_potion_physics_properties() -> void:
	# Verify physics properties are valid positive values
	var potion = PotionData.new()
	
	# Test default values are positive
	assert_gt(potion.throw_force, 0.0, "throw_force should be positive")
	assert_gt(potion.blast_radius, 0.0, "blast_radius should be positive")
	assert_gt(potion.area_effect_duration, 0.0, "area_effect_duration should be positive")
	
	# Test custom values can be set
	potion.throw_force = 25.0
	assert_eq(potion.throw_force, 25.0, "Should accept custom throw_force")
	
	potion.blast_radius = 5.0
	assert_eq(potion.blast_radius, 5.0, "Should accept custom blast_radius")
	
	potion.area_effect_duration = 2.0
	assert_eq(potion.area_effect_duration, 2.0, "Should accept custom area_effect_duration")


func test_potion_drink_properties() -> void:
	# Verify drink properties are valid
	var potion = PotionData.new()
	
	# Test default drink_duration is positive
	assert_gt(potion.drink_duration, 0.0, "drink_duration should be positive")
	
	# Test custom drink duration
	potion.drink_duration = 3.0
	assert_eq(potion.drink_duration, 3.0, "Should accept custom drink_duration")
	
	# Test drink animation name
	potion.drink_animation_name = "custom_drink"
	assert_eq(potion.drink_animation_name, "custom_drink", "Should accept custom drink_animation_name")
	
	# Test consume_on_use can be toggled
	potion.consume_on_use = false
	assert_false(potion.consume_on_use, "consume_on_use should be false")
	
	potion.consume_on_use = true
	assert_true(potion.consume_on_use, "consume_on_use should be true")
</file>

<file path="godot-coop/test/unit-test/test_effect_manager.gd">
extends GutTest
## Tests for EffectManager - handles GameplayEffects (instant, duration, periodic)

var _effect_manager: EffectManager
var _attribute_set: GASAttributeSet
var _tag_container: TagContainer


func before_each() -> void:
	_tag_container = TagContainer.new()
	_attribute_set = GASAttributeSet.new()
	_effect_manager = EffectManager.new()
	
	add_child(_tag_container)
	add_child(_attribute_set)
	add_child(_effect_manager)
	
	# Initialize the effect manager's modifiers dictionary
	_effect_manager._ready()
	# Setup connections between components
	_effect_manager.setup(_attribute_set, _tag_container)


func after_each() -> void:
	_effect_manager.queue_free()
	_attribute_set.queue_free()
	_tag_container.queue_free()


# Helper to create a GameplayEffect for testing
func _create_effect(effect_name: String, mode: int, target_attr: String = "health", 
		operation: int = GameplayEffect.ModifierOp.SUBTRACT, value: float = 10.0,
		duration: float = 5.0, tick_rate: float = 1.0, tags: PackedStringArray = []) -> GameplayEffect:
	var effect = GameplayEffect.new()
	effect.effect_name = effect_name
	effect.mode = mode
	effect.target_attribute = target_attr
	effect.operation = operation
	effect.value = value
	effect.duration = duration
	effect.tick_rate = tick_rate
	effect.granted_tags = tags
	return effect


func test_apply_instant_effect() -> void:
	# INSTANT effect should immediately modify health
	var initial_health = _attribute_set.health
	
	var damage_effect = _create_effect(
		"Damage",
		GameplayEffect.ApplicationMode.INSTANT,
		"health",
		GameplayEffect.ModifierOp.SUBTRACT,
		25.0
	)
	
	var effects: Array[GameplayEffect] = [damage_effect]
	_effect_manager._apply_effects_logic(effects)
	
	assert_eq(_attribute_set.health, initial_health - 25.0, "Health should be reduced by 25")


func test_apply_duration_effect() -> void:
	# DURATION effect should modify stat while active
	var base_speed = _attribute_set.base_speed
	
	var speed_buff = _create_effect(
		"Speed Boost",
		GameplayEffect.ApplicationMode.DURATION,
		"speed",
		GameplayEffect.ModifierOp.ADD,
		5.0,
		10.0  # 10 second duration
	)
	
	var effects: Array[GameplayEffect] = [speed_buff]
	var handles = _effect_manager._apply_effects_logic(effects)
	
	assert_eq(handles.size(), 1, "Should return one handle")
	assert_eq(_attribute_set.speed, base_speed + 5.0, "Speed should be increased by 5")
	
	# Remove the effect
	_effect_manager._remove_effect_logic(handles[0])
	assert_eq(_attribute_set.speed, base_speed, "Speed should return to base after removal")


func test_apply_periodic_effect() -> void:
	# PERIODIC effect should apply damage each tick
	var initial_health = _attribute_set.health
	
	var dot_effect = _create_effect(
		"Poison",
		GameplayEffect.ApplicationMode.PERIODIC,
		"health",
		GameplayEffect.ModifierOp.SUBTRACT,
		5.0,
		3.0,  # 3 second duration
		1.0   # tick every 1 second
	)
	
	var effects: Array[GameplayEffect] = [dot_effect]
	_effect_manager._apply_effects_logic(effects)
	
	# Simulate 1 second passing - should trigger one tick
	_effect_manager._process_logic(1.0)
	assert_eq(_attribute_set.health, initial_health - 5.0, "Health should be reduced by one tick")
	
	# Simulate another second
	_effect_manager._process_logic(1.0)
	assert_eq(_attribute_set.health, initial_health - 10.0, "Health should be reduced by two ticks")


func test_remove_effect() -> void:
	# Removing an effect should clean up modifiers and tags
	var speed_buff = _create_effect(
		"Speed Boost",
		GameplayEffect.ApplicationMode.DURATION,
		"speed",
		GameplayEffect.ModifierOp.ADD,
		10.0,
		60.0,
		1.0,
		PackedStringArray(["buff.speed"])
	)
	
	var effects: Array[GameplayEffect] = [speed_buff]
	var handles = _effect_manager._apply_effects_logic(effects)
	
	assert_true(_tag_container.has_tag(&"buff.speed"), "Tag should be granted")
	assert_eq(_effect_manager.active_effect_registry.size(), 1, "Effect should be registered")
	
	_effect_manager._remove_effect_logic(handles[0])
	
	assert_false(_tag_container.has_tag(&"buff.speed"), "Tag should be removed")
	assert_eq(_effect_manager.active_effect_registry.size(), 0, "Effect should be unregistered")


func test_effect_grants_tags() -> void:
	# Effects should grant their tags when applied
	var tag_effect = _create_effect(
		"Burning",
		GameplayEffect.ApplicationMode.DURATION,
		"none",  # Tag-only effect
		GameplayEffect.ModifierOp.ADD,
		0.0,
		5.0,
		1.0,
		PackedStringArray(["state.burning", "debuff.fire"])
	)
	
	var effects: Array[GameplayEffect] = [tag_effect]
	_effect_manager._apply_effects_logic(effects)
	
	assert_true(_tag_container.has_tag(&"state.burning"), "Should have burning tag")
	assert_true(_tag_container.has_tag(&"debuff.fire"), "Should have fire debuff tag")


func test_compute_stat_modifiers() -> void:
	# Test all modifier operations: ADD, SUBTRACT, MULTIPLY, DIVIDE
	var base_speed = _attribute_set.base_speed  # 5.0
	
	# ADD modifier
	var add_effect = _create_effect("Add", GameplayEffect.ApplicationMode.INFINITE, "speed", 
		GameplayEffect.ModifierOp.ADD, 3.0)
	var effects: Array[GameplayEffect] = [add_effect]
	var handles = _effect_manager._apply_effects_logic(effects)
	assert_eq(_attribute_set.speed, base_speed + 3.0, "ADD should increase speed")
	_effect_manager._remove_effect_logic(handles[0])
	
	# MULTIPLY modifier
	var mult_effect = _create_effect("Multiply", GameplayEffect.ApplicationMode.INFINITE, "speed",
		GameplayEffect.ModifierOp.MULTIPLY, 2.0)
	effects = [mult_effect]
	handles = _effect_manager._apply_effects_logic(effects)
	assert_eq(_attribute_set.speed, base_speed * 2.0, "MULTIPLY should double speed")
	_effect_manager._remove_effect_logic(handles[0])
	
	# DIVIDE modifier
	var div_effect = _create_effect("Divide", GameplayEffect.ApplicationMode.INFINITE, "speed",
		GameplayEffect.ModifierOp.DIVIDE, 2.0)
	effects = [div_effect]
	handles = _effect_manager._apply_effects_logic(effects)
	assert_eq(_attribute_set.speed, base_speed / 2.0, "DIVIDE should halve speed")
	_effect_manager._remove_effect_logic(handles[0])


func test_duration_effect_expires() -> void:
	# DURATION effects should expire after their duration
	var buff = _create_effect(
		"Temp Buff",
		GameplayEffect.ApplicationMode.DURATION,
		"speed",
		GameplayEffect.ModifierOp.ADD,
		10.0,
		2.0  # 2 second duration
	)
	
	var effects: Array[GameplayEffect] = [buff]
	_effect_manager._apply_effects_logic(effects)
	
	var base_speed = _attribute_set.base_speed
	assert_eq(_attribute_set.speed, base_speed + 10.0, "Speed should be buffed initially")
	
	# Simulate time passing (not enough to expire)
	_effect_manager._process_logic(1.0)
	assert_eq(_attribute_set.speed, base_speed + 10.0, "Speed should still be buffed")
	
	# Simulate more time (effect should expire)
	_effect_manager._process_logic(1.5)
	assert_eq(_attribute_set.speed, base_speed, "Speed should return to base after expiration")
	assert_eq(_effect_manager.active_effect_registry.size(), 0, "Effect should be removed from registry")
</file>

<file path="godot-coop/test/unit-test/test_tag_container.gd">
extends GutTest
## Tests for TagContainer - the GameplayTag system with reference counting

var _tag_container: TagContainer


func before_each() -> void:
	_tag_container = TagContainer.new()
	add_child(_tag_container)


func after_each() -> void:
	_tag_container.queue_free()


func test_add_tag() -> void:
	# Adding a tag should register it in active_tags
	_tag_container._add_tag_logic(&"state.burning")
	
	assert_true(_tag_container.active_tags.has(&"state.burning"), "Tag should be in active_tags")
	assert_eq(_tag_container.active_tags[&"state.burning"], 1, "Tag count should be 1")


func test_remove_tag() -> void:
	# Removing a tag should decrement and eventually remove it
	_tag_container._add_tag_logic(&"state.burning")
	_tag_container._remove_tag_logic(&"state.burning")
	
	assert_false(_tag_container.active_tags.has(&"state.burning"), "Tag should be removed from active_tags")


func test_tag_reference_counting() -> void:
	# Multiple adds require multiple removes (stacking)
	_tag_container._add_tag_logic(&"buff.speed")
	_tag_container._add_tag_logic(&"buff.speed")
	_tag_container._add_tag_logic(&"buff.speed")
	
	assert_eq(_tag_container.active_tags[&"buff.speed"], 3, "Tag count should be 3 after 3 adds")
	
	_tag_container._remove_tag_logic(&"buff.speed")
	assert_eq(_tag_container.active_tags[&"buff.speed"], 2, "Tag count should be 2 after 1 remove")
	assert_true(_tag_container.has_tag(&"buff.speed"), "Tag should still be active")
	
	_tag_container._remove_tag_logic(&"buff.speed")
	_tag_container._remove_tag_logic(&"buff.speed")
	assert_false(_tag_container.has_tag(&"buff.speed"), "Tag should be gone after all removes")


func test_has_tag() -> void:
	# has_tag should return correct boolean
	assert_false(_tag_container.has_tag(&"state.stunned"), "Should not have tag initially")
	
	_tag_container._add_tag_logic(&"state.stunned")
	assert_true(_tag_container.has_tag(&"state.stunned"), "Should have tag after adding")
	
	_tag_container._remove_tag_logic(&"state.stunned")
	assert_false(_tag_container.has_tag(&"state.stunned"), "Should not have tag after removing")


func test_tag_signals() -> void:
	# Signals should emit on first add and last remove
	watch_signals(_tag_container)
	
	# First add should emit tag_added
	_tag_container._add_tag_logic(&"effect.poison")
	assert_signal_emitted(_tag_container, "tag_added", "tag_added should emit on first add")
	
	# Second add should NOT emit again (tag already exists, just increments count)
	_tag_container._add_tag_logic(&"effect.poison")
	assert_signal_emit_count(_tag_container, "tag_added", 1, "tag_added should only emit once for same tag")
	
	# First remove should NOT emit (tag still has count > 0)
	_tag_container._remove_tag_logic(&"effect.poison")
	assert_signal_not_emitted(_tag_container, "tag_removed", "tag_removed should NOT emit while count > 0")
	
	# Last remove should emit tag_removed
	_tag_container._remove_tag_logic(&"effect.poison")
	assert_signal_emitted(_tag_container, "tag_removed", "tag_removed should emit when count reaches 0")
</file>

<file path="godot-coop/addons/inventory-system-demos/character/character_inventory_system.gd">
@tool
@icon("res://addons/inventory-system-demos/icons/character_inventory_system.svg")
class_name CharacterInventorySystem
extends NodeInventories

signal opened_station(station : CraftStation)
signal closed_station(station : CraftStation)
signal opened_inventory(inventory : Inventory)
signal closed_inventory(inventory : Inventory)
signal picked(obj : Node)

const Interactor = preload("../interaction_system/inventory_interactor.gd")

@export_group("ðŸ—ƒï¸ Inventory Nodes")
@export_node_path var main_inventory_path := NodePath("InventoryHandler/Inventory")
@onready var main_inventory : GridInventory = get_node(main_inventory_path)
@export_node_path var equipment_inventory_path := NodePath("InventoryHandler/EquipmentInventory")
#@onready var equipment_inventory : GridInventory = get_node(equipment_inventory_path)
#@export_node_path("Hotbar") var hotbar_path := NodePath("Hotbar")
#@onready var hotbar : Hotbar = get_node(hotbar_path)
@export_node_path("CraftStation") var main_station_path := NodePath("CraftStation")
@onready var main_station : CraftStation = get_node(main_station_path)
@export_node_path var interactor_path := NodePath("Interactor")
@onready var interactor : Interactor = get_node(interactor_path)
@export_node_path var drop_parent_path := NodePath("../..");
@onready var drop_parent : Node = get_node(drop_parent_path)
@export_node_path var drop_parent_position_path := NodePath("..");
@onready var drop_parent_position : Node = get_node(drop_parent_position_path)

var opened_stations : Array[CraftStation]
var opened_inventories : Array[Inventory]

@export_group("âŒ¨ï¸ Inputs")
## Change mouse state based on inventory status
@export var change_mouse_state : bool = true
@export var check_inputs : bool = true
@export var toggle_inventory_input : String = "toggle_inventory"
@export var exit_inventory_and_craft_panel_input : String = "escape"
@export var toggle_craft_panel_input : String = "toggle_craft_panel"


@export_group("ðŸ«´ Interact")
@export var can_interact : bool = true
@export var raycast : RayCast3D:
	set(value):
		raycast = value
		var _interactor = get_node(interactor_path)
		if _interactor != null and value != null:
			_interactor.raycast = value
@export var camera_3d : Camera3D:
	set(value):
		camera_3d = value
		var _interactor = get_node(interactor_path)
		if _interactor != null and value != null:
			_interactor.camera = value


func _ready():
	if Engine.is_editor_hint():
		return
	#hotbar.active_slot(0)
	#hotbar.active_slot(1)
	#hotbar.active_slot(2)
	#hotbar.active_slot(3)
	#hotbar.active_slot(4)
	#hotbar.active_slot(5)
	#hotbar.active_slot(6)
	#hotbar.active_slot(7)
	## Setup for enabled/disabled mouse ðŸ–±ï¸ðŸ˜€
	if change_mouse_state:
		opened_inventory.connect(_update_opened_inventories)
		closed_inventory.connect(_update_opened_inventories)
		opened_station.connect(_update_opened_stations)
		closed_station.connect(_update_opened_stations)
		_update_opened_inventories(main_inventory)


func _input(event : InputEvent) -> void:
	if Engine.is_editor_hint():
		return
	if check_inputs:
		#hot_bar_inputs(event)
		inventory_inputs()


func _physics_process(_delta : float):
	if Engine.is_editor_hint():
		return
	if not can_interact:
		return
	interactor.try_interact()


func is_any_station_or_inventory_opened() -> bool:
	return is_open_any_station() or is_open_main_inventory()


func _update_opened_inventories(_inventory : Inventory):
	_check_inputs()


func _update_opened_stations(_craft_station : CraftStation):
	_craft_station.load_valid_recipes()
	_check_inputs()


func _check_inputs():
	if is_any_station_or_inventory_opened():
		Input.mouse_mode = Input.MOUSE_MODE_VISIBLE
	else:
		Input.mouse_mode = Input.MOUSE_MODE_CAPTURED


func inventory_inputs():
	if Input.is_action_just_released(toggle_inventory_input):
		if not is_any_station_or_inventory_opened():
			open_main_inventory()

	if Input.is_action_just_released(exit_inventory_and_craft_panel_input):
		close_inventories()
		close_craft_stations()

	if Input.is_action_just_released(toggle_craft_panel_input):
		if not is_any_station_or_inventory_opened():
			open_main_craft_station()

func pick_to_inventory(node : Node):
	if main_inventory == null:
		return

	if node == null:
		return

	if !node.get("is_pickable"):
		return

	var item_id = node.item_id
	var item_properties = node.item_properties
	var amount = node.amount

	if main_inventory.add(item_id, amount, item_properties, true) == 0:
		picked.emit(node)
		node.queue_free();
		return

	printerr("pick_to_inventory return false");

func transfer(inventory: GridInventory, origin_pos: Vector2i, destination: GridInventory, amount: int):
	var stack_index = inventory.get_stack_index_at(origin_pos)
	if stack_index == -1:
		return
	inventory.transfer(stack_index, destination, amount)


func transfer_to(inventory: GridInventory, origin_pos: Vector2i, destination: GridInventory, destination_pos: Vector2i, amount: int, is_rotated: bool):
	inventory.transfer_to(origin_pos, destination, destination_pos, amount, is_rotated)


func split(inventory : Inventory, stack_index : int, amount : int):
	inventory.split(stack_index, amount)


#func equip(stack: ItemStack, _inventory : Inventory, slot_index: int):
	#hotbar.equip(stack, slot_index)


func rotate(stack: ItemStack, inventory : Inventory):
	inventory.rotate(stack)


func sort(inventory : Inventory):
	inventory.sort()


func drop(stack: ItemStack, inventory: Inventory):
	var stack_index = inventory.stacks.find(stack)
	if stack_index == -1:
		return

	inventory.drop_from_inventory(stack_index, stack.amount, stack.properties)


func drop_all_items():
	main_inventory.drop_all_stacks()
	#equipment_inventory.drop_all_stacks()

#endregion

#region Crafter
func craft(craft_station : CraftStation, recipe_index : int):
	craft_station.craft(recipe_index)

#endregion

#region Hotbar
#func hot_bar_inputs(event : InputEvent):
	#if event is InputEventMouseButton:
		#if event.is_pressed():
			#if event.button_index == MOUSE_BUTTON_WHEEL_UP:
				#hotbar_previous_item()
			#if event.button_index == MOUSE_BUTTON_WHEEL_DOWN:
				#hotbar_next_item()
	#if event is InputEventKey:
		#var input_key_event = event as InputEventKey
		#if event.is_pressed() and not event.is_echo():
			#if input_key_event.keycode > KEY_0 and input_key_event.keycode < KEY_9:
				#hotbar_change_selection(input_key_event.keycode - KEY_1)


#func hotbar_change_selection(index : int):
	#if hotbar.selection_index == index:
		#index = -1
	#hotbar.selection_index = index
#
#
#func hotbar_previous_item():
	#hotbar.previous_item()
#
#
#func hotbar_next_item():
	#hotbar.next_item()

#endregion

#region Open Inventories
func is_open_inventory(inventory : Inventory):
	return opened_inventories.find(inventory) != -1

func open_inventory(inventory : Inventory):
	if is_open_inventory(inventory):
		return
	add_open_inventory(inventory)


func add_open_inventory(inventory : Inventory):
	opened_inventories.append(inventory)
	opened_inventory.emit(inventory)
	if not is_open_main_inventory():
		#inventory.request_drop_obj.connect(_on_request_drop_obj)
		open_main_inventory()

func open_main_inventory():
	open_inventory(main_inventory)


func close_inventory(inventory : Inventory):
	if main_inventory != inventory:
		inventory.get_parent().close(get_parent())
	remove_open_inventory(inventory)


func remove_open_inventory(inventory : Inventory):
	var index = opened_inventories.find(inventory)
	opened_inventories.remove_at(index)
	closed_inventory.emit(inventory)
	#if main_inventory != inventory:
		#inventory.request_drop_obj.disconnect(_on_request_drop_obj)


func close_inventories():
	for index in range(opened_inventories.size() - 1, -1, -1):
		close_inventory(opened_inventories[index])


func is_open_any_inventory():
	return !opened_inventories.is_empty()

func is_open_main_inventory():
	return is_open_inventory(main_inventory)
#endregion

#region Open Craft Stations
func is_open_station(station : CraftStation):
	return opened_stations.find(station) != -1


func open_station(station : CraftStation):
	if is_open_station(station):
		return
	add_open_station(station)


func add_open_station(station : CraftStation):
	opened_stations.append(station)
	opened_station.emit(station)


func close_station(station : CraftStation):
	if not is_open_station(station):
		return
	remove_open_station(station)


func remove_open_station(station : CraftStation):
	var index = opened_stations.find(station)
	opened_stations.remove_at(index)
	closed_station.emit(station)
	if main_station != station:
		station.get_parent().close(get_parent())


func open_main_craft_station():
	open_station(main_station)


func close_craft_stations():
	for index in range(opened_stations.size() - 1, -1, -1):
		close_station(opened_stations[index])

func is_open_any_station():
	return !opened_stations.is_empty()
#endregion
</file>

<file path="godot-coop/addons/inventory-system-demos/fps/loot_box_inventory.gd">
extends BoxInventory
class_name LootBoxInventory

@onready var loot_generator: LootGenerator = $LootGenerator

func _on_open():
	print("generate loot")
	loot_generator.generate_loot()
	super._on_open()


func _on_close():
	inventory.clear()
	super._on_close()
</file>

<file path="godot-coop/addons/inventory-system-demos/mp/sync_grid_inventory.gd">
class_name SyncGridInventory
extends Node

#@export var sync_item_added_signal := true
#@export var sync_item_removed_signal := true
@export var sync_when_content_update_only := false

@export var inventory : GridInventory

## Networked version of inventory where server sends rpcs to client for
## slot update, add and remove signals
##
## Why not use [MultiplayerSyncronizer]?
## The idea of using rpc signals only when changed saves a lot of bandwidth,
## but at the cost of being sure which signals will be called, ie calling
## slot[i] = new Dictionary is not replicated across the network.
## Also keep in mind that signals need to be handled if switching to a use of
## MultiplayerSyncronizer
##
## Note: Slot categories are not synced

func _ready():
	if Engine.is_editor_hint():
		return
	multiplayer.peer_connected.connect(_on_connected)
	if(inventory != null):
		setup()


func setup():
	if sync_when_content_update_only:
		inventory.contents_changed.connect(_on_contents_changed)
	else:
		inventory.stack_added.connect(_on_stack_added)
		inventory.updated_stack.connect(_on_updated_stack)
		inventory.stack_removed.connect(_on_stack_removed)



func _on_contents_changed():
	if not multiplayer.is_server():
		return
	var inv_data = inventory.serialize()
	_update_inventory_rpc.rpc(inv_data)


func _on_connected(id):
	if not multiplayer.is_server():
		return
	var inv_data = inventory.serialize()
	_update_inventory_rpc.rpc_id(id, inv_data)


func _on_stack_added(stack_index : int):
	if not multiplayer.is_server():
		return

	var item_id = inventory.stacks[stack_index].item_id
	var amount = inventory.stacks[stack_index].amount
	var properties = inventory.stacks[stack_index].properties
	var position = inventory.stack_positions[stack_index]
	var rotation = inventory.stack_rotations[stack_index]
	_stack_added_rpc.rpc(stack_index, item_id, amount, properties, position, rotation)


func _on_updated_stack(stack_index : int):
	if not multiplayer.is_server():
		return
	_updated_slot_rpc.rpc(stack_index, inventory.stacks[stack_index].serialize())


func _on_stack_removed(stack_index : int):
	if not multiplayer.is_server():
		return

	_stack_removed_rpc.rpc(stack_index)


@rpc
func _update_inventory_rpc(inv_data : Dictionary):
	if not multiplayer.is_server():
		inventory.deserialize(inv_data)
		inventory.contents_changed.emit()


@rpc
func _stack_added_rpc(_stack_index: int, item_id: String, amount: int, properties: Dictionary, position: Vector2i, rotation: bool):
	if multiplayer.is_server():
		return
	inventory.add_at_position(position, item_id, amount, properties, rotation)


@rpc
func _updated_slot_rpc(stack_index : int, slot_data : Array):
	if multiplayer.is_server():
		return
	if stack_index < 0 or stack_index >= inventory.stacks.size(): return
	var stack : ItemStack = inventory.stacks[stack_index]
	stack.deserialize(slot_data)
	inventory.updated_stack.emit(stack_index)

@rpc
func _stack_removed_rpc(stack_index : int):
	if multiplayer.is_server():
		return
	inventory.remove_stack(stack_index)
</file>

<file path="godot-coop/addons/inventory-system-demos/ui/craft/recipe_ui.gd">
class_name RecipeUI
extends Control

## Represents a [Recipe] in the interface. It is instantiated by [CraftStationUI]

# Scene to instantiate the [IngredientUI]
@export var ingredient_scene : PackedScene

@onready var icon : TextureRect = get_node("Control/ItemIcon")
@onready var item_name : Label = get_node("ItemName")
@onready var time_to_craft : Label = get_node("TimeToCraft")
@onready var craft_button : Button = get_node("CraftButton")
@onready var ingredients_container : HBoxContainer = get_node("IngredientsItemsList")
@onready var required_items_list = %RequiredItemsList


var recipe_index : int
var craft_station : CraftStation
var _ingredients : Array[IngredientUI]

## Configures the recipe with index values from [Recipe] from [InventoryDatabase].
## Called by [CraftStationUI].
func set_recipe(_craft_station : CraftStation, _recipe : Recipe, _recipe_index : int):
	self.craft_station = _craft_station
	self.recipe_index = _recipe_index
	var product_item : ItemDefinition = craft_station.database.get_item(_recipe.products[0].item_id)
	icon.texture = product_item.icon
	item_name.text = product_item.name
	time_to_craft.text = str(_recipe.time_to_craft) + " Seconds"
	_clear_ingredients()
	for ingredient in _recipe.ingredients:
		var ingredient_obj : IngredientUI = ingredient_scene.instantiate()
		ingredients_container.add_child(ingredient_obj)
		ingredient_obj.setup(craft_station.database, ingredient)
		_ingredients.append(ingredient_obj)
	for ingredient in _recipe.required_items:
		var ingredient_obj : IngredientUI = ingredient_scene.instantiate()
		ingredients_container.add_child(ingredient_obj)
		ingredient_obj.setup(craft_station.database, ingredient)
		_ingredients.append(ingredient_obj)
	check_if_has_ingredients()


func _clear_ingredients():
	for ingredient_ui in _ingredients:
		ingredient_ui.queue_free()
		_ingredients.clear()


func check_if_has_ingredients():
	var recipe = craft_station.database.recipes[recipe_index]
	craft_button.disabled = not craft_station.can_craft(recipe)
</file>

<file path="godot-coop/addons/inventory-system-demos/ui/interactor/input_helper.gd">
################################################################################
# MIT License
# Copyright (c) 2021 PunchablePlushie
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
@tool
class_name InputHelper
extends Resource

enum InputType {INVALID, KEYBOARD, MOUSE, GP_BTN, GP_MOTION}

@export var joy_name_abbr: Dictionary = {
	"XInput Gamepad": "xbox",
	"Xbox Series Controller": "xbox",
	"Sony DualSense": "ps",
	"PS5 Controller": "ps",
	"PS4 Controller": "ps",
	"Switch": "switch",
} 

@export var labels: Dictionary = {
	"mouse": [
		"LMB", "RMB", "MMB", "MW Up", "MW Down", "MW Left", "MW Right", "MB1", "MB2"
	],
	
	"xbox": [
		"A", "B", "X", "Y", "Back", "Home", "Start", "L", "R", "LB", "RB",
		"DPad Up", "DPad Down", "DPad Left", "DPad Right", "Share"
	],
	
	"ps": [
		"Cross", "Circle", "Square", "Triangle", "Select", "PS", "Start",
		"L3", "R3", "L1", "R1", "DPad Up", "DPad Down", "DPad Left",
		"DPad Right", "Microphone"
	],
	
	"switch": [
		"B", "A", "Y", "X", "Minus", "", "Plus", "", "", "", "",
		"DPad Up", "DPad Down", "DPad Left", "DPad Right", "Capture"
	],
	
	"other": [
		"A", "B", "X", "Y", "Back", "Home", "Start", "L", "R", "LB", "RB",
		"DPad Up", "DPad Down", "DPad Left", "DPad Right", "Share",
		"Paddle 1", "Paddle 2", "Paddle 3", "Paddle 4", "Touch"
	],
	
	"motion": [
		{"-": "LStick Left", "+": "LStick Right"},
		{"-": "LStick Up", "+": "LStick Down"},
		{"-": "RStick Left", "+": "RStick Right"},
		{"-": "RStick Up", "+": "RStick Down"},
		{"+": "Left Trigger"},
		{"+": "Right Trigger"}
	],
}


func get_event_id(event: InputEvent) -> int:
	if event is InputEventKey:
		if event.physical_keycode == 0:
			return -1
		
		return event.physical_keycode | event.get_modifiers_mask()
	
	if event is InputEventMouseButton:
		return event.button_index | event.get_modifiers_mask()
	
	if event is InputEventJoypadButton:
		return event.button_index
	
	if event is InputEventJoypadMotion:
		return event.axis
	
	return -1


func set_event_id(event: InputEvent, id: int) -> void:
	if event is InputEventKey:
		event.physical_keycode = id & ~(KEY_MASK_SHIFT | KEY_MASK_CTRL | KEY_MASK_ALT)
		_set_event_modifiers(event, id)
	
	if event is InputEventMouseButton:
		event.button_index = id & ~(KEY_MASK_SHIFT | KEY_MASK_CTRL | KEY_MASK_ALT)
		_set_event_modifiers(event, id)
	
	if event is InputEventJoypadButton:
		event.button_index = id
	
	if event is InputEventJoypadMotion:
		event.axis = id


func get_event_type(event: InputEvent) -> InputType:
	if event is InputEventKey:
		return InputType.KEYBOARD
	
	if event is InputEventMouseButton:
		return InputType.MOUSE
	
	if event is InputEventJoypadButton:
		return InputType.GP_BTN
	
	if event is InputEventJoypadMotion:
		return InputType.GP_MOTION
	
	return InputType.INVALID


func create_event_from_type(type: InputType) -> InputEvent:
	match type:
		InputType.KEYBOARD:
			return InputEventKey.new()
		InputType.MOUSE:
			return InputEventMouseButton.new()
		InputType.GP_BTN:
			return InputEventJoypadButton.new()
		InputType.GP_MOTION:
			return InputEventJoypadMotion.new()
		_:
			return null


func input_already_exists(event: InputEvent, self_action: String) -> Array:
	for action in InputMap.get_actions():
		if action.begins_with("ui_"):
			continue
		
		if action == self_action:
			continue
		
		if InputMap.action_has_event(action, event):
			return [true, action]
	
	return [false, ""]

 
func _set_event_modifiers(event: InputEventWithModifiers, modifier_mask: int) -> void:
	event.shift_pressed = bool(modifier_mask & KEY_MASK_SHIFT)
	event.ctrl_pressed = bool(modifier_mask & KEY_MASK_CTRL)
	event.alt_pressed = bool(modifier_mask & KEY_MASK_ALT)


### Events as Text

func get_event_as_text(event: InputEvent) -> String:
	if get_event_id(event) == -1:
		return "INVALID"
	
	if event is InputEventKey:
		return OS.get_keycode_string(event.get_physical_keycode_with_modifiers())
	
	if event is InputEventMouseButton:
		return _get_mouse_event_as_text(event)
	
	if event is InputEventJoypadButton:
		return _get_gp_btn_event_as_text(event)
	
	if event is InputEventJoypadMotion:
		return _get_gp_motion_event_as_text(event)
	
	return ""


func _get_modifiers_as_string(event: InputEventWithModifiers) -> String:
	var modifiers: PackedStringArray
	if event.shift_pressed:
		modifiers.append("Shift")
	
	if event.ctrl_pressed:
		modifiers.append("Ctrl")
	
	if event.alt_pressed:
		modifiers.append("Alt")
	
	var modifiers_string: String = "+".join(modifiers) 
	return modifiers_string


func _get_joy_name_abbr(name: String) -> String:
	if joy_name_abbr.has(name):
		return joy_name_abbr[name]
	else:
		return "other"


func _get_mouse_event_as_text(event: InputEventMouseButton) -> String:
	var modifiers: String = _get_modifiers_as_string(event)
	var btn: String = labels["mouse"][event.button_index - 1]
	var result: String = "%s"%btn if modifiers.is_empty() else "%s+%s"%[modifiers, btn]
	return result


func _get_gp_btn_event_as_text(event: InputEventJoypadButton) -> String:
	var device_name: String = Input.get_joy_name(event.device)
	device_name = _get_joy_name_abbr(device_name)
	return labels[device_name][event.button_index]


func _get_gp_motion_event_as_text(event: InputEventJoypadMotion) -> String:
	var axis_value: String = "-" if event.axis_value < 0 else "+"
	return labels["motion"][event.axis][axis_value]


### Events as Icons

func get_event_as_icon(event: InputEvent, icon_db: InputIcons) -> Texture2D:
	if event is InputEventKey:
		return _get_keyboard_event_as_icon(event, icon_db)
		
	if event is InputEventMouseButton:
		return _get_mouse_event_as_icon(event, icon_db)
	
	if event is InputEventJoypadButton:
		return _get_gp_btn_event_as_icon(event, icon_db)
	
	if event is InputEventJoypadMotion:
		return _get_gp_motion_event_as_icon(event, icon_db)
	
	return null


func _get_keyboard_event_as_icon(event: InputEventKey, icon_db: InputIcons) -> Texture2D:
	var keycode: int = event.physical_keycode
	var icon: Texture2D = icon_db.get_keyboard_button_texture(keycode)
	
	return icon


func _get_mouse_event_as_icon(event: InputEventMouse, icon_db: InputIcons) -> Texture2D:
	var button_index: int = event.button_index
	var icon: Texture2D = icon_db.get_mouse_button_texture(button_index)
	
	return icon


func _get_gp_btn_event_as_icon(event: InputEventJoypadButton, icon_db: InputIcons) -> Texture2D:
	var device_name: String = Input.get_joy_name(event.device)
	device_name = _get_joy_name_abbr(device_name)
	
	var button_index: int = event.button_index
	var icon: Texture2D = icon_db.get_gp_button_texture(device_name, button_index)
	
	return icon


func _get_gp_motion_event_as_icon(event: InputEventJoypadMotion, icon_db: InputIcons) -> Texture2D:
	var device_name: String = Input.get_joy_name(event.device)
	device_name = _get_joy_name_abbr(device_name)
	
	var axis: int = event.axis
	var axis_dir: String = "-" if event.axis_value < 1 else "+"
	var icon: Texture2D = icon_db.get_gp_motion_texture(device_name, axis, axis_dir)
	
	return icon
</file>

<file path="godot-coop/characters/common_components/gas/ability_manager.gd">
class_name AbilityManager
extends Node

const INPUT_PRIMARY = "ability.primary"
const INPUT_SECONDARY = "ability.secondary"
const INPUT_RELOAD = "ability.reload"
const INPUT_JUMP = "ability.jump"

class AbilitySpec:
	var handle: AbilitySpecHandle
	var ability: GameplayAbility
	var input_tag: String
	var is_active: bool = false
	var source_inventory: Inventory = null
	var source_slot_index: int = -1
	var active_effect_handles: Array[EffectSpecHandle] = []
	
	func _init(p_handle: AbilitySpecHandle, p_ability: GameplayAbility, p_input: String, p_inv: Inventory, p_slot: int):
		handle = p_handle
		ability = p_ability
		input_tag = p_input
		source_inventory = p_inv
		source_slot_index = p_slot

@export var default_abilities: Array[AbilityGrant]

var _effect_manager: EffectManager
var _tag_container: TagContainer
var _cast_manager: CastManager
var _actor: Node

var granted_abilities: Dictionary = {}


func _ready() -> void:
	if multiplayer.is_server():
		_ready_logic()


## Testable ready logic - call directly in tests
func _ready_logic() -> void:
	for grant in default_abilities:
		if grant and grant.ability:
			_grant_ability_logic(grant.ability, grant.input_tag)


func setup(actor: Node, effect_manager: EffectManager, tag_container: TagContainer, cast_manager: CastManager) -> void:
	_actor = actor
	_effect_manager = effect_manager
	_tag_container = tag_container
	_cast_manager = cast_manager


func grant_ability(ability_res: GameplayAbility, input_tag: String = "", source_inventory: Inventory = null, source_slot_index: int = -1) -> AbilitySpecHandle:
	if not multiplayer.is_server(): return null
	return _grant_ability_logic(ability_res, input_tag, source_inventory, source_slot_index)


## Testable grant ability logic - call directly in tests
func _grant_ability_logic(ability_res: GameplayAbility, input_tag: String = "", source_inventory: Inventory = null, source_slot_index: int = -1) -> AbilitySpecHandle:
	if ability_res == null: return null
	
	var handle = AbilitySpecHandle.new(ability_res.ability_name)
	var spec = AbilitySpec.new(handle, ability_res, input_tag, source_inventory, source_slot_index)
	granted_abilities[handle] = spec
	
	print("[AbilityManager] Granted Ability: '", ability_res.ability_name, "' | Handle: ", handle, " | Input: ", input_tag)
	
	return handle


func clear_ability(handle: AbilitySpecHandle) -> void:
	if not multiplayer.is_server(): return
	_clear_ability_logic(handle)


## Testable clear ability logic - call directly in tests
func _clear_ability_logic(handle: AbilitySpecHandle) -> void:
	if not granted_abilities.has(handle):
		print("[AbilityManager] Warning: Ability not found: ", handle)
		return
		
	var spec = granted_abilities[handle]
	
	if spec.is_active:
		spec.ability.end_ability(_actor, handle)
	
	granted_abilities.erase(handle)
	print("[AbilityManager] Cleared Ability: ", handle)


func get_ability_source(handle: AbilitySpecHandle) -> Dictionary:
	if granted_abilities.has(handle):
		var spec = granted_abilities[handle]
		return {
			"inventory": spec.source_inventory,
			"slot": spec.source_slot_index
		}
	return {}


func can_activate_ability(ability: GameplayAbility) -> bool:
	for tag in ability.activation_required_tags:
		if not _tag_container.has_tag(tag):
			return false
			
	for tag in ability.activation_blocked_tags:
		if _tag_container.has_tag(tag):
			return false
			
	return true


@rpc("any_peer", "call_local", "reliable")
func server_ability_input_pressed(input_tag: String, activation_data: Dictionary = {}) -> void:
	if not multiplayer.is_server(): return
	_ability_input_pressed_logic(input_tag, activation_data)


## Testable ability input pressed logic - call directly in tests
func _ability_input_pressed_logic(input_tag: String, activation_data: Dictionary = {}) -> void:
	for handle in granted_abilities:
		var spec = granted_abilities[handle]
		if spec.input_tag == input_tag:
			if can_activate_ability(spec.ability):
				spec.ability.activate(_actor, handle, activation_data)
				spec.is_active = true
				if spec.ability.ongoing_effects.size() > 0:
					var handles = _effect_manager._apply_effects_logic(spec.ability.ongoing_effects)
					spec.active_effect_handles.append_array(handles)
			else:
				print("[AbilityManager] Ability blocked: ", spec.ability.ability_name)


@rpc("any_peer", "call_local", "reliable")
func server_ability_input_released(input_tag: String) -> void:
	if not multiplayer.is_server(): return
	_ability_input_released_logic(input_tag)


## Testable ability input released logic - call directly in tests
func _ability_input_released_logic(input_tag: String) -> void:
	for handle in granted_abilities:
		var spec: AbilitySpec = granted_abilities[handle]
		
		if spec.input_tag == input_tag:
			spec.is_active = false
			
			for effect_handle in spec.active_effect_handles:
				_effect_manager._remove_effect_logic(effect_handle)
			spec.active_effect_handles.clear()
			
			if _cast_manager.has_active_cast(handle):
				_cast_manager._cancel_cast_logic(handle)
			
			spec.ability.input_released(_actor, handle)
</file>

<file path="godot-coop/characters/common_components/gas/ability_system_component.gd">
class_name AbilitySystemComponent
extends Node

signal health_changed(new_value: float, max_value: float)
signal died()
signal tag_added(tag: StringName)
signal tag_removed(tag: StringName)

@onready var attribute_set: GASAttributeSet = $AttributeSet
@onready var effect_manager: EffectManager = $EffectManager
@onready var ability_manager: AbilityManager = $AbilityManager
@onready var cast_manager: CastManager = $CastManager
@onready var tag_container: TagContainer = $TagContainer

@export var is_strafing: bool:
	get:
		return attribute_set.is_strafing if attribute_set else false
	set(value):
		if attribute_set:
			attribute_set.is_strafing = value

var health: float:
	get:
		return attribute_set.health if attribute_set else 0.0
	set(value):
		if attribute_set:
			attribute_set.health = value

var speed: float:
	get:
		return attribute_set.speed if attribute_set else 0.0


func _ready() -> void:
	_setup_components()
	_connect_signals()


func _setup_components() -> void:
	var actor = get_parent()
	
	effect_manager.setup(attribute_set, tag_container)
	ability_manager.setup(actor, effect_manager, tag_container, cast_manager)


func _connect_signals() -> void:
	attribute_set.health_changed.connect(func(new_val, max_val): health_changed.emit(new_val, max_val))
	attribute_set.died.connect(func(): died.emit())
	tag_container.tag_added.connect(func(tag): tag_added.emit(tag))
	tag_container.tag_removed.connect(func(tag): tag_removed.emit(tag))


func apply_gameplay_effects(effects: Array[GameplayEffect]) -> Array[EffectSpecHandle]:
	return effect_manager.apply_effects(effects)


func remove_effect(handle: EffectSpecHandle) -> void:
	effect_manager.remove_effect(handle)


func grant_ability(ability_res: GameplayAbility, input_tag: String = "", source_inventory: Inventory = null, source_slot_index: int = -1) -> AbilitySpecHandle:
	return ability_manager.grant_ability(ability_res, input_tag, source_inventory, source_slot_index)


func clear_ability(handle: AbilitySpecHandle) -> void:
	ability_manager.clear_ability(handle)


func get_ability_source(handle: AbilitySpecHandle) -> Dictionary:
	return ability_manager.get_ability_source(handle)


func start_cast(handle: AbilitySpecHandle, duration: float, on_complete: Callable, on_cancel: Callable = Callable()) -> void:
	cast_manager.start_cast(handle, duration, on_complete, on_cancel)


func cancel_cast(handle: AbilitySpecHandle) -> void:
	cast_manager.cancel_cast(handle)


func add_tag(tag: StringName) -> void:
	tag_container.add_tag(tag)


func remove_tag(tag: StringName) -> void:
	tag_container.remove_tag(tag)


func has_tag(tag: StringName) -> bool:
	return tag_container.has_tag(tag)


func get_total_stat(stat_name: String) -> float:
	return attribute_set.get_computed_stat(stat_name)


func server_ability_input_pressed(input_tag: String, activation_data: Dictionary = {}) -> void:
	ability_manager.server_ability_input_pressed.rpc(input_tag, activation_data)


func server_ability_input_released(input_tag: String) -> void:
	ability_manager.server_ability_input_released.rpc(input_tag)
</file>

<file path="godot-coop/characters/common_components/gas/attribute_set.gd">
class_name GASAttributeSet
extends Node

signal health_changed(new_value: float, max_value: float)
signal died()

const VALID_ATTRIBUTES: PackedStringArray = ["health", "max_health", "speed", "stamina", "mana", "swap_time"]

@export_group("Base Stats")
@export var base_max_health: float = 100.0
@export var base_speed: float = 5.0
@export var base_stamina: float = 50.0
@export var base_swap_time: float = 0.5  ## Time in seconds to swap items between hand and belt

var is_strafing: bool = false

var _health: float
var health: float:
	set(value):
		var current_max = get_max_health()
		var old_health = _health
		_health = clamp(value, 0.0, current_max)
		
		if _health != old_health:
			print("[GASAttributeSet] HEALTH UPDATE: ", _health, " / ", current_max)
			health_changed.emit(_health, current_max)
			if _health == 0.0:
				print("[GASAttributeSet] CHARACTER DIED!")
				died.emit()
	get:
		return _health

var speed: float:
	get:
		return get_computed_stat("speed")

var swap_time: float:
	get:
		return get_computed_stat("swap_time")

var _effect_manager: EffectManager


func _ready() -> void:
	_health = base_max_health


func set_effect_manager(effect_manager: EffectManager) -> void:
	_effect_manager = effect_manager


func get_max_health() -> float:
	return get_computed_stat("max_health")


func get_computed_stat(stat_name: String) -> float:
	if stat_name == "health": 
		return _health
	
	var base_val = get("base_" + stat_name)
	if base_val == null: 
		return 0.0
	
	if not _effect_manager:
		return base_val
	
	return _effect_manager.compute_stat_with_modifiers(stat_name, base_val)


func apply_instant_change(attribute: String, value: float, operation: int) -> void:
	var final_value = value
	if operation == GameplayEffect.ModifierOp.SUBTRACT:
		final_value = -value
	
	if attribute == "health":
		self.health += final_value
	else:
		printerr("[GASAttributeSet] WARNING: INSTANT effects are usually for 'health' or 'mana'. Check attribute: ", attribute)


func on_max_health_changed() -> void:
	self.health = self.health
</file>

<file path="godot-coop/characters/common_components/gas/cast_manager.gd">
class_name CastManager
extends Node

class ActiveCast:
	var handle: AbilitySpecHandle
	var duration: float
	var elapsed: float = 0.0
	var on_complete: Callable
	var on_cancel: Callable
	
	func _init(p_handle: AbilitySpecHandle, p_duration: float, p_on_complete: Callable, p_on_cancel: Callable = Callable()):
		handle = p_handle
		duration = p_duration
		on_complete = p_on_complete
		on_cancel = p_on_cancel

var active_casts: Dictionary = {}


func _process(delta: float) -> void:
	if not multiplayer.is_server(): return
	_process_logic(delta)


## Testable process logic - call directly in tests
func _process_logic(delta: float) -> void:
	_process_active_casts(delta)


func start_cast(handle: AbilitySpecHandle, duration: float, on_complete: Callable, on_cancel: Callable = Callable()) -> void:
	if not multiplayer.is_server(): return
	_start_cast_logic(handle, duration, on_complete, on_cancel)


## Testable start cast logic - call directly in tests
func _start_cast_logic(handle: AbilitySpecHandle, duration: float, on_complete: Callable, on_cancel: Callable = Callable()) -> void:
	if active_casts.has(handle):
		GlobalLogger.log("[CastManager] Warning: Cast already in progress for: ", handle)
		return
	
	var cast = ActiveCast.new(handle, duration, on_complete, on_cancel)
	active_casts[handle] = cast
	GlobalLogger.log("[CastManager] Started cast for ", handle, " | Duration: ", duration, "s")


func cancel_cast(handle: AbilitySpecHandle) -> void:
	if not multiplayer.is_server(): return
	_cancel_cast_logic(handle)


## Testable cancel cast logic - call directly in tests
func _cancel_cast_logic(handle: AbilitySpecHandle) -> void:
	if not active_casts.has(handle): return
	
	var cast: ActiveCast = active_casts[handle]
	GlobalLogger.log("[CastManager] Cast CANCELLED for ", handle)
	
	if cast.on_cancel.is_valid():
		cast.on_cancel.call()
	
	active_casts.erase(handle)


func has_active_cast(handle: AbilitySpecHandle) -> bool:
	return active_casts.has(handle)


func _process_active_casts(delta: float) -> void:
	var completed_casts: Array[AbilitySpecHandle] = []
	
	for handle in active_casts:
		var cast: ActiveCast = active_casts[handle]
		cast.elapsed += delta
		
		if cast.elapsed >= cast.duration:
			completed_casts.append(handle)
	
	for handle in completed_casts:
		var cast: ActiveCast = active_casts[handle]
		GlobalLogger.log("[CastManager] Cast COMPLETED for ", handle)
		
		if cast.on_complete.is_valid():
			cast.on_complete.call()
		
		active_casts.erase(handle)
</file>

<file path="godot-coop/characters/common_components/tag_reaction_component.gd">
class_name TagReactionComponent
extends Node

@export var target_tag: StringName
@export var ability_system: AbilitySystemComponent


func _ready() -> void:
	if ability_system:
		ability_system.tag_added.connect(_on_tag_added)
		ability_system.tag_removed.connect(_on_tag_removed)


func _on_tag_added(tag: StringName) -> void:
	if tag == target_tag:
		activate_reaction()


func _on_tag_removed(tag: StringName) -> void:
	if tag == target_tag:
		deactivate_reaction()


func activate_reaction() -> void:
	pass


func deactivate_reaction() -> void:
	pass
</file>

<file path="godot-coop/characters/test_tag_reaction_component.gd">
class_name FireTagReactionComponent
extends Node

@export var target_tag: StringName
@export var ability_system: AbilitySystemComponent
@onready var mesh_instance_3d: MeshInstance3D = $"../MeshInstance3D"
@export var texture_burn: Texture2D
@export var texture_normal: Texture2D


func _ready() -> void:
	if ability_system:
		ability_system.tag_added.connect(_on_tag_added)
		ability_system.tag_removed.connect(_on_tag_removed)


func _on_tag_added(tag: StringName) -> void:
	if tag == target_tag:
		activate_reaction()


func _on_tag_removed(tag: StringName) -> void:
	if tag == target_tag:
		deactivate_reaction()


func activate_reaction() -> void:
	var mat = mesh_instance_3d.get_active_material(0)
	if mat is StandardMaterial3D:
		mat.albedo_texture = texture_burn


func deactivate_reaction() -> void:
	var mat = mesh_instance_3d.get_active_material(0)
	if mat is StandardMaterial3D:
		mat.albedo_texture = texture_normal
</file>

<file path="godot-coop/interactables/items/item_base.gd">
@icon("res://addons/inventory-system-demos/icons/dropped_item_3d.svg")
extends RigidBody3D
class_name ItemBase


const Interactor = preload("res://addons/inventory-system-demos/interaction_system/inventory_interactor.gd")

@export var item_id : String
@export var amount : int = 1
@export var item_properties : Dictionary
@export var is_pickable := true
@export var actions : Array
@export var default_description : String = "Get Item"


func get_interaction_position(_interaction_point : Vector3) -> Vector3:
	return position


func get_interact_actions(_interactor : Interactor) -> Array:
	var text = str(amount) + " X "
	var item = _interactor.database.get_item(item_id)
	if item != null:
		text += item.name
	else:
		text += item_id
	actions[0].description = default_description.replace("Item", text)
	return actions


func interact(character : Node, _action_index : int = 0):
	character.character_inventory_system.pick_to_inventory(self)
</file>

<file path="godot-coop/items/definitions/projectiles/projectile_base.gd">
extends RigidBody3D


class_name ProjectileBase

var data: PotionData
var thrower_id: int = 0

@onready var visuals: Node3D = $Visuals
@onready var area_effect: Area3D = %AreaEffect
@onready var impact_sound: AudioStreamPlayer3D = %ImpactSound
@onready var impact_particles: GPUParticles3D = %ImpactParticles


func _ready() -> void:
	contact_monitor = false
	max_contacts_reported = 1
	if multiplayer.is_server():
		body_entered.connect(on_impact)

func setup_projectile(new_data : PotionData, initial_velocity: Vector3) -> void:
	self.data = new_data
	self.linear_velocity = initial_velocity

func on_impact(body: Node) -> void:
	pass
</file>

<file path="godot-coop/systems/multiplayer_spawner.gd">
extends MultiplayerSpawner




func _ready() -> void:
	multiplayer.peer_connected.connect(spawn_player)
	
	


func spawn_player(client_id : int) -> void:
	
	if not multiplayer.is_server(): return
	
	var player = preload("res://characters/player/player.tscn").instantiate()
	player.name = str(client_id)
	
	get_node(spawn_path).call_deferred("add_child", player)
</file>

<file path="godot-coop/addons/inventory-system-demos/mp/networked_character_inventory_system.gd">
@tool
class_name NetworkedCharacterInventorySystem
extends "../character/character_inventory_system.gd"
@onready var equipment_manager: EquipmentManager = $EquipmentManager


func _ready():
	if Engine.is_editor_hint():
		return
	if is_multiplayer_authority():
		# Setup for enabled/disabled mouse ðŸ–±ï¸ðŸ˜€
		opened_inventory.connect(_update_opened_inventories)
		closed_inventory.connect(_update_opened_inventories)
		opened_station.connect(_update_opened_stations)
		closed_station.connect(_update_opened_stations)
		_update_opened_inventories(main_inventory)
	else:
		picked.connect(_on_picked)
	#hotbar.active_slot(0)
	#hotbar.active_slot(1)


func _on_picked(obj : Node):
	picked_rpc.rpc(obj.get_path())


func _input(event : InputEvent):
	if Engine.is_editor_hint():
		return
	if check_inputs and is_multiplayer_authority():
		#hot_bar_inputs(event)
		inventory_inputs()


func open_main_inventory():
	if multiplayer.is_server():
		super.open_main_inventory()
		for inventory in equipment_manager.get_children():
			if inventory is GridInventory:
				open_inventory(inventory)
	else:
		open_main_inventory_rpc.rpc_id(1)


func open_inventory(inventory : Inventory):
	if multiplayer.is_server():
		super.open_inventory(inventory)
	else:
		open_inventory_rpc.rpc_id(1, inventory.get_path())


func add_open_inventory(inventory : Inventory):
	if multiplayer.is_server():
		add_open_inventory_rpc.rpc(inventory.get_path())
	super.add_open_inventory(inventory)


func remove_open_inventory(inventory : Inventory):
	if multiplayer.is_server():
		remove_open_inventory_rpc.rpc(inventory.get_path())
	super.remove_open_inventory(inventory)


func close_inventories():
	if multiplayer.is_server():
		super.close_inventories()
		
	else:
		close_inventories_rpc.rpc_id(1)


func pick_to_inventory(node : Node):
	if multiplayer.is_server():
		super.pick_to_inventory(node)
	else:
		pick_to_inventory_rpc.rpc_id(1, node.get_path())


func transfer_to(inventory: GridInventory, origin_pos: Vector2i, destination: GridInventory, destination_pos: Vector2i, amount: int, is_rotated: bool):
	if multiplayer.is_server():
		super.transfer_to(inventory, origin_pos, destination, destination_pos, amount, is_rotated)
	else:
		transfer_to_rpc.rpc_id(1, inventory.get_path(), origin_pos, destination.get_path(), destination_pos, amount, is_rotated)


func rotate(stack: ItemStack, inventory: Inventory):
	if multiplayer.is_server():
		super.rotate(stack, inventory)
	else:
		var stack_index = inventory.stacks.find(stack)
		if stack_index != -1:
			rotate_rpc.rpc_id(1, stack_index, inventory.get_path())


func split(inventory : Inventory, stack_index : int, amount : int):
	if multiplayer.is_server():
		super.split(inventory, stack_index, amount)
	else:
		split_rpc.rpc_id(1, inventory.get_path(), stack_index, amount)


func sort(inventory : Inventory):
	if multiplayer.is_server():
		super.sort(inventory)
	else:
		sort_rpc.rpc_id(1, inventory.get_path())


func drop(stack: ItemStack, inventory: Inventory):
	if multiplayer.is_server():
		super.drop(stack, inventory)
	else:
		var stack_index = inventory.stacks.find(stack)
		if stack_index != -1:
			drop_rpc.rpc_id(1, stack_index, inventory.get_path())


#func equip(stack: ItemStack, inventory: Inventory, slot_index: int):
	#if multiplayer.is_server():
		#super.equip(stack, inventory, slot_index)
	#else:
		#var stack_index = inventory.stacks.find(stack)
		#if stack_index != -1:
			#equip_rpc.rpc_id(1, stack_index, inventory.get_path(), slot_index)

#
#func hotbar_change_selection(index : int):
	#if multiplayer.is_server():
		#super.hotbar_change_selection(index)
	#else:
		#hotbar_change_selection_rpc.rpc_id(1, index)

#
#func hotbar_previous_item():
	#if multiplayer.is_server():
		#super.hotbar_previous_item()
	#else:
		#hotbar_previous_item_rpc.rpc_id(1)
#
#
#func hotbar_next_item():
	#if multiplayer.is_server():
		#super.hotbar_next_item()
	#else:
		#hotbar_next_item_rpc.rpc_id(1)


func open_main_craft_station():
	if multiplayer.is_server():
		super.open_main_craft_station()
	else:
		open_main_craft_station_rpc.rpc_id(1)


func close_craft_stations():
	if multiplayer.is_server():
		super.close_craft_stations()
	else:
		close_stations_rpc.rpc_id(1)


func craft(craft_station : CraftStation, recipe_index : int):
	if multiplayer.is_server():
		craft_rpc(craft_station.get_path(), recipe_index)
	else:
		craft_rpc.rpc(craft_station.get_path(), recipe_index)


func open_station(craft_station : CraftStation):
	if multiplayer.is_server():
		open_station_rpc(get_path_to(craft_station))
	else:
		open_station_rpc.rpc(get_path_to(craft_station))


func add_open_station(craft_station : CraftStation):
	if multiplayer.is_server():
		add_open_station_rpc.rpc(craft_station.get_path())
	super.add_open_station(craft_station)


func remove_open_station(craft_station : CraftStation):
	if multiplayer.is_server():
		remove_open_station_rpc.rpc(craft_station.get_path())
	super.remove_open_station(craft_station)


@rpc("any_peer")
func picked_rpc(obj_path : NodePath):
	var obj = get_node(obj_path)
	picked.emit(obj)


@rpc("any_peer")
func open_main_inventory_rpc():
	super.open_main_inventory()


@rpc
func open_inventory_rpc(inventory_path : NodePath):
	var inventory = get_node(inventory_path)
	super.open_inventory(inventory)


@rpc("any_peer")
func add_open_inventory_rpc(inventory_path : NodePath):
	var inventory = get_node(inventory_path)
	super.add_open_inventory(inventory)


@rpc("any_peer")
func remove_open_inventory_rpc(inventory_path : NodePath):
	var inventory = get_node(inventory_path)
	super.remove_open_inventory(inventory)


@rpc("any_peer")
func add_open_station_rpc(station_path : NodePath):
	var station = get_node(station_path)
	super.add_open_station(station)


@rpc("any_peer")
func remove_open_station_rpc(station_path : NodePath):
	var station = get_node(station_path)
	super.remove_open_station(station)


@rpc
func close_inventories_rpc():
	if multiplayer.is_server():
		super.close_inventories()


@rpc
func pick_to_inventory_rpc(node_path: NodePath):
	super.pick_to_inventory(get_node(node_path))


@rpc
func transfer_to_rpc(inventory_path: NodePath, origin_pos: Vector2i, destination_path: NodePath, destination_pos: Vector2i, amount: int, is_rotated: bool):
	var inv = get_node(inventory_path)
	var dest_inv = get_node(destination_path)
	if inv == null or dest_inv == null:
		return
	super.transfer_to(inv, origin_pos, dest_inv, destination_pos, amount, is_rotated)


@rpc
func split_rpc(inventory_path: NodePath, stack_index: int, amount: int):
	var inv = get_node(inventory_path)
	if inv == null:
		return
	super.split(inv, stack_index, amount)


@rpc
func rotate_rpc(stack_index: int, inventory_path: NodePath):
	var inv = get_node(inventory_path)
	if inv == null:
		return
	var stack = inv.stacks[stack_index]
	super.rotate(stack, inv)


@rpc
func sort_rpc(inventory_path: NodePath):
	var inv = get_node(inventory_path)
	if inv == null:
		return
	super.sort(inv)


@rpc
func drop_rpc(stack_index: int, inventory_path: NodePath):
	var inv = get_node(inventory_path)
	if inv == null:
		return
	var stack = inv.stacks[stack_index]
	super.drop(stack, inv)


#@rpc
#func equip_rpc(stack_index: int, inventory_path: NodePath, slot_index: int):
	#var inv = get_node(inventory_path)
	#if inv == null:
		#return
	#var stack = inv.stacks[stack_index]
	#super.equip(stack, inv, slot_index)


#@rpc
#func hotbar_change_selection_rpc(selection_index: int):
	#if not multiplayer.is_server():
		#return
	#super.hotbar_change_selection(selection_index)
#
#
#@rpc
#func hotbar_previous_item_rpc():
	#if not multiplayer.is_server():
		#return
	#super.hotbar_previous_item()
#
#
#@rpc
#func hotbar_next_item_rpc():
	#if not multiplayer.is_server():
		#return
	#super.hotbar_next_item()

@rpc
func open_main_craft_station_rpc():
	super.open_main_craft_station()


@rpc
func open_station_rpc(craft_station_path : NodePath):
	var station = get_node(craft_station_path)
	super.open_station(station)


@rpc
func close_stations_rpc():
	if multiplayer.is_server():
		super.close_craft_stations()


@rpc
func craft_rpc(craft_station_path : NodePath, recipe_index : int):
	var station = get_node(craft_station_path)
	station.craft(recipe_index)


func _physics_process(_delta : float):
	if Engine.is_editor_hint():
		return
	if not can_interact:
		return
	if multiplayer.multiplayer_peer != null and is_multiplayer_authority():
		interactor.try_interact()
</file>

<file path="godot-coop/interactables/harvest_nodes/harvestable.gd">
class_name Harvestable
extends InteractableBase

@onready var loot_generator: LootGenerator = $LootGenerator

# --- DATA ---
@export var data: HarvestableData # Drag your .tres here!

# --- STATE (Server Side) ---
var current_harvester: Node = null # Who is harvesting me
var harvest_timer: float = 0.0
var is_harvesting: bool = false
var is_looted: bool = false

# Max distance configuration to cancel if they move away
const MAX_HARVEST_DISTANCE_SQR = 3.0 * 3.0 

func _ready():
	# Initial configuration from Data
	if data and data.loot_table_id != "":
		loot_generator.loot_id = data.loot_table_id
	
	interaction_text = "Harvest"
	set_process(false) # Disable process to save CPU

func _on_interacted(character: Node):
	# Initial validations
	if is_looted or is_harvesting: return
	if not data: 
		printerr("Missing HarvestableData in ", name)
		return

	# START HARVESTING (Server)
	current_harvester = character
	is_harvesting = true
	harvest_timer = 0.0
	
	# Connect to player's damage signal to cancel if they get hit
	if current_harvester.has_signal("damaged"):
		current_harvester.damaged.connect(_on_harvester_damaged)
	
	# Activate the check loop
	set_process(true)
	
	# RPC: Notify client to show progress bar UI
	_start_harvest_visuals_rpc.rpc(data.harvest_duration)

func _process(delta: float):
	if not multiplayer.is_server(): return
	_process_logic(delta)


## Testable process logic - call directly in tests
func _process_logic(delta: float) -> void:
	# 1. CANCELLATION CHECK
	if not is_instance_valid(current_harvester):
		_cancel_harvest()
		return
		
	# A. Have they moved? (Check velocity)
	# We assume character has 'velocity' property (CharacterBase has it)
	if current_harvester.velocity.length_squared() > 0.1:
		_cancel_harvest()
		return
		
	# B. Have they moved too far away? (In case they get pushed or teleport)
	if global_position.distance_squared_to(current_harvester.global_position) > MAX_HARVEST_DISTANCE_SQR:
		_cancel_harvest()
		return

	# 2. PROGRESS
	harvest_timer += delta
	
	if harvest_timer >= data.harvest_duration:
		_finish_harvest()

# Callback if player receives damage
func _on_harvester_damaged():
	_cancel_harvest()

func _cancel_harvest():
	if not is_harvesting: return
	
	is_harvesting = false
	set_process(false)
	
	# Disconnect damage signal
	if is_instance_valid(current_harvester) and current_harvester.has_signal("damaged"):
		current_harvester.damaged.disconnect(_on_harvester_damaged)
	
	current_harvester = null
	
	# RPC: Notify client to hide bar/cancel animation
	_cancel_harvest_visuals_rpc.rpc()

func _finish_harvest():
	# Detener proceso
	is_harvesting = false
	is_looted = true # Marcar como looteado
	set_process(false)
	
	if is_instance_valid(current_harvester) and current_harvester.has_signal("damaged"):
		current_harvester.damaged.disconnect(_on_harvester_damaged)
	
	# --- GENERAR LOOT (Igual que antes) ---
	var char_inv = current_harvester.get_node("CharacterInventorySystem")
	if char_inv:
		loot_generator.target_inventory_path = char_inv.main_inventory.get_path()
		loot_generator.add_loot_to_inventory()
	
	# RPCs Finales
	_success_harvest_visuals_rpc.rpc()
	
	current_harvester = null
	
	# Destruir/Respawn
	if data.respawn_time > 0:
		get_tree().create_timer(data.respawn_time).timeout.connect(_respawn)
	elif data.destroy_on_harvest:
		get_tree().create_timer(0.5).timeout.connect(queue_free)

func _respawn():
	is_looted = false
	_respawn_visuals_rpc.rpc()

# --- RPCs VISUALES (CLIENTE) ---

@rpc("call_local")
func _start_harvest_visuals_rpc(duration: float):
	# THIS IS WHERE YOU WOULD CONNECT TO YOUR UI
	# Example: GlobalUI.show_progress_bar(duration, "Harvesting...")
	print("Client: Starting to harvest... (", duration, "s)")

@rpc("call_local")
func _cancel_harvest_visuals_rpc():
	# GlobalUI.hide_progress_bar()
	print("Client: Harvest cancelled.")

@rpc("call_local")
func _success_harvest_visuals_rpc():
	# GlobalUI.hide_progress_bar()
	# FX success sound
	visible = false
	$CollisionShape3D.disabled = true
	print("Client: Harvest completed!")

@rpc("call_local")
func _respawn_visuals_rpc():
	visible = true
	$CollisionShape3D.disabled = false
</file>

<file path="godot-coop/interactables/loot_container/search_constraint.gd">
extends InventoryConstraint
class_name SearchConstraint


func _can_remove_stack(inventory: Inventory, stack_index: int, amount: int) -> bool:
	var stack = inventory.stacks[stack_index]
	if stack == null: return true
	
	# Si el item no tiene la lista de revelados, asumimos que es pÃºblico (o viejo sistema)
	if not stack.properties.has("revealed_to"):
		# Fallback para compatibilidad: si tiene 'revealed' antiguo y es false, bloquea
		if stack.properties.has("revealed") and stack.properties["revealed"] == false:
			return false
		return true
		
	var revealed_list = stack.properties["revealed_to"]
	
	# Accedemos al multiplayer a travÃ©s del nodo Inventario
	var mp = inventory.multiplayer 
	var request_id = 0
	
	if mp.is_server():
		# ValidaciÃ³n Autoritaria: Â¿QuiÃ©n llamÃ³ a la funciÃ³n/RPC?
		request_id = mp.get_remote_sender_id()
		
		# Si request_id es 0, significa que la llamada fue local (el Host jugando)
		if request_id == 0:
			request_id = 1
	else:
		# ValidaciÃ³n Visual (Cliente): Soy yo quien mira el inventario
		request_id = mp.get_unique_id()
	
	# La lÃ³gica: Â¿EstÃ¡ la ID en la lista de "Gente que ha buscado este item"?
	if request_id in revealed_list:
		return true 
		
	return false
</file>

<file path="godot-coop/items/abilities/ga_aim.gd">
extends GameplayAbility
class_name GA_Aim

func activate(actor: Node, _handle: AbilitySpecHandle, _args: Dictionary = {}) -> void:
	var asc: AbilitySystemComponent = actor.get_node_or_null("AbilitySystemComponent")
	if asc:
		asc.is_strafing = true
		print("[GA_Aim] Strafing Active")

func input_released(actor: Node, handle: AbilitySpecHandle) -> void:
	var asc: AbilitySystemComponent = actor.get_node_or_null("AbilitySystemComponent")
	if asc:
		asc.is_strafing = false
		print("[GA_Aim] Strafing Ended")
	
	end_ability(actor, handle)
</file>

<file path="godot-coop/addons/inventory-system-demos/ui/grid/grid_item_stack_ui.gd">
@tool
extends GridDraggableElementUI
class_name GridItemStackUI

signal activated
signal clicked
signal middle_clicked
signal context_activated(event: InputEvent)

@export var stack_style: StyleBox
@export var hover_stack_style: StyleBox
@export var selected_stack_style: StyleBox
@export var unknown_icon: Texture2D

@onready var texture_bg: Panel = $TextureBG
@onready var item_icon: TextureRect = %ItemIcon
@onready var stack_size_label: Label = $StackSizeLabel
@onready var audio_stream_player: AudioStreamPlayer = $AudioStreamPlayer
@onready var audio_stream_player_2: AudioStreamPlayer = $AudioStreamPlayer2

var inventory : GridInventory
var stack: ItemStack


func setup(inv: Inventory, new_stack: ItemStack):
	self.inventory = inv
	self.stack = new_stack
	if stack and inventory != null:
		var definition: ItemDefinition = inventory.database.get_item(stack.item_id)
		tooltip_text = definition.description
		var is_rotated = inventory.is_stack_rotated(stack)
		var texture = definition.icon
		if is_rotated:
			var image = texture.get_image()
			image.rotate_90(CLOCKWISE)
			texture = ImageTexture.create_from_image(image)
		%ItemIcon.texture = texture

		activate()
		_disconnect_item_signals()
		_connect_item_signals(stack)
	else:
		%ItemIcon.texture = null
		deactivate()
	_update_stack_size()


func _connect_item_signals(new_item: ItemStack) -> void:
	if new_item == null:
		return

	if !new_item.updated.is_connected(_refresh):
		new_item.updated.connect(_refresh)

	if inventory != null and !inventory.updated_stack.is_connected(_update_stack_index):
		inventory.updated_stack.connect(_update_stack_index)


func _disconnect_item_signals() -> void:
	if !is_instance_valid(stack):
		return

	if stack.updated.is_connected(_refresh):
		stack.updated.disconnect(_refresh)

	if inventory != null and inventory.updated_stack.is_connected(_update_stack_index):
		inventory.updated_stack.disconnect(_update_stack_index)


func _ready() -> void:
	_set_panel_style(stack_style)
	mouse_entered.connect(func():
		# Only visual feedback if active (revealed)
		if is_active(): 
			_set_panel_style(hover_stack_style)
			audio_stream_player_2.play()
	)
	mouse_exited.connect(func():
		_set_panel_style(stack_style)
	)
	grabbed.connect(func(_offset):
		visible = false
		audio_stream_player.play()
	)
	if stack == null:
		deactivate()
	else:
		# Execute visual logic at start
		_update_visuals()

func _update_visuals():
	if not stack or not inventory:
		return

	# CAMBIO: LÃ³gica basada en array de IDs
	var is_revealed = true
	
	if stack.properties.has("revealed_to"):
		var revealed_list = stack.properties["revealed_to"]
		var my_id = multiplayer.get_unique_id()
		
		# Si mi ID no estÃ¡, no estÃ¡ revelado para mÃ­
		if my_id not in revealed_list:
			is_revealed = false
	else:
		# Retrocompatibilidad o items normales sin esta mecÃ¡nica
		# Si existe la vieja propiedad 'revealed', la usamos, si no, true.
		is_revealed = stack.properties.get("revealed", true)
	
	if is_revealed:
		# --- REVEALED STATE (LÃ³gica original) ---
		var definition: ItemDefinition = inventory.database.get_item(stack.item_id)
		tooltip_text = definition.description
		
		var is_rotated = inventory.is_stack_rotated(stack)
		var texture = definition.icon
		if is_rotated:
			var image = texture.get_image()
			image.rotate_90(CLOCKWISE)
			texture = ImageTexture.create_from_image(image)
		
		%ItemIcon.texture = texture
		%ItemIcon.modulate = Color(1, 1, 1, 1)
		
		activate() 
		
	else:
		# --- HIDDEN STATE ---
		tooltip_text = "Searching..."
		
		if unknown_icon:
			%ItemIcon.texture = unknown_icon
			%ItemIcon.modulate = Color(1, 1, 1, 1)
		else:
			var definition = inventory.database.get_item(stack.item_id)
			%ItemIcon.texture = definition.icon
			%ItemIcon.modulate = Color(0.0, 0.0, 0.0, 1) # Negro total
		
		deactivate()

	_update_stack_size(is_revealed)


func _update_stack_index(_stack_index: int) -> void:
	_refresh()


func select():
	if is_instance_valid(selected_stack_style):
		_set_panel_style(selected_stack_style)


func unselect():
	_set_panel_style(stack_style)


func _notification(what) -> void:
	if what == NOTIFICATION_DRAG_END:
		visible = true


func _update_stack_size(is_revealed: bool = true) -> void:
	if !is_instance_valid(stack_size_label):
		return
		
	# If not revealed, hide quantity (optional, Tarkov hardcore style)
	if not is_revealed:
		stack_size_label.text = "?"
		return

	if !is_instance_valid(stack):
		stack_size_label.text = ""
		return
	var stack_size: int = stack.amount
	if stack_size <= 1:
		if stack.properties.has("durability"):
			var definition: ItemDefinition = inventory.database.get_item(stack.item_id)
			if definition != null:
				var actual : float = stack.properties["durability"]
				var total : float = definition.properties["durability"]
				stack_size_label.text = str(int(actual/total * 100.0)) + "%"
				return
	else:
		stack_size_label.text = "%d" % stack_size
		return
	stack_size_label.text = ""


func _refresh() -> void:
	# When the server updates the 'revealed' property to true,
	# this function is triggered. Re-execute visual logic.
	_update_visuals()


func create_preview() -> Control:
	var preview = self.duplicate()
	preview.setup(inventory, stack)
	preview.visible = true
	return preview


func _gui_input(event: InputEvent) -> void:
	if !(event is InputEventMouseButton):
		return
		
	# BLOCK INPUT IF NOT REVEALED
	if not is_active():
		return 

	var mb_event: InputEventMouseButton = event
	if !mb_event.pressed:
		return
	if mb_event.button_index == MOUSE_BUTTON_LEFT:
		if mb_event.double_click:
			activated.emit()
		else:
			clicked.emit()
	if mb_event.button_index == MOUSE_BUTTON_MIDDLE:
		middle_clicked.emit()
	elif mb_event.button_index == MOUSE_BUTTON_MASK_RIGHT:
		context_activated.emit(mb_event)


func _set_panel_style(style: StyleBox) -> void:
	remove_theme_stylebox_override("panel")
	if style != null:
		add_theme_stylebox_override("panel", style)
</file>

<file path="godot-coop/addons/inventory-system-demos/ui/inventory_system_ui.gd">
class_name InventorySystemUI
extends Control

const Interactor = preload("../interaction_system/inventory_interactor.gd")

## This script manages inventory system UI information
## Contains drag slot information, UI inventories and item drop area

@export var console_mode : bool = false:
	set(value):
		player_inventory_ui.console_mode = console_mode
		loot_inventory_ui.console_mode = console_mode
		console_mode = value
		
@export var character : CharacterInventorySystem

## Stores [Crafter] information to connect all signals and callbacks
@export var interactor : Interactor

## Player [InventoryUI], Typically the main usage inventory
@onready var player_inventory_ui : GridInventoryPanel = %PlayerGridInventoryUI

## Loot [InventoryUI], Typically an inventory that has been opened
@onready var loot_inventory_ui : GridInventoryPanel = %LootGridInventoryUI
@onready var head_slot_ui: GridInventoryUI = $MarginContainer/HBoxContainer/EquipmentContainer/HeadSlot
@onready var chest_slot_ui: GridInventoryUI = $MarginContainer/HBoxContainer/EquipmentContainer/ChestSlot
@onready var hand_slot_ui: GridInventoryUI = $MarginContainer/HBoxContainer/EquipmentContainer/HandSlot
@onready var belt_slot_1_ui: GridInventoryUI = $MarginContainer/HBoxContainer/EquipmentContainer/BeltSlot1
@onready var belt_slot_2_ui: GridInventoryUI = $MarginContainer/HBoxContainer/EquipmentContainer/BeltSlot2
@onready var belt_slot_3_ui: GridInventoryUI = $MarginContainer/HBoxContainer/EquipmentContainer/BeltSlot3





@onready var equipment_container: VBoxContainer = $MarginContainer/HBoxContainer/EquipmentContainer


## Hotbar [HotbarUI]
#@onready var hotbar_ui : HotbarUI = get_node(NodePath("HotbarUI"))

## Control that identifies area where a transaction slot can call the handler to drop items
@onready var drop_area: DropArea = get_node(NodePath("DropArea"))


@onready var player_craft_station_ui : CraftStationUI = %PlayerCraftStationUI

@onready var other_craft_station_ui : CraftStationUI = %OtherCraftStationUI

@onready var interactor_ui : InteractorUI = get_node(NodePath("InteractorUI"))

@onready var stack_popup_menu: PopupMenu = $StackPopupMenu


var alternative_inventory : Inventory

func _ready():
	stack_popup_menu.id_pressed.connect(_on_stack_popup_menu_id_pressed)
	# TODO connect
	# _setup_inventory_system_connection()
	player_inventory_ui.visible = false
	loot_inventory_ui.visible = false
	drop_area.visible = false
	#hotbar_ui.visible = true
	player_craft_station_ui.close()
	other_craft_station_ui.close()
	drop_area.request_drop.connect(_request_drop)
	
	player_inventory_ui.request_transfer_to.connect(_request_transfer_to)
	loot_inventory_ui.request_transfer_to.connect(_request_transfer_to)
	
	player_inventory_ui.request_fast_transfer.connect(_request_fast_transfer)
	loot_inventory_ui.request_fast_transfer.connect(_request_fast_transfer)
	
	player_inventory_ui.request_split.connect(_request_split)
	loot_inventory_ui.request_split.connect(_request_split)
	#player_inventory_ui.request_sort.connect(_request_sort)
	#loot_inventory_ui.request_sort.connect(_request_sort)
	
	player_inventory_ui.inventory_stack_context_activated.connect(_inventory_stack_context)
	loot_inventory_ui.inventory_stack_context_activated.connect(_inventory_stack_context)
	
	other_craft_station_ui.input_inventory_ui.inventory_stack_context_activated.connect(_inventory_stack_context)
	
	#player_craft_station_ui.input_inventory_ui.request_transfer_to.connect(_request_transfer_to)
	other_craft_station_ui.input_inventory_ui.request_transfer_to.connect(_request_transfer_to)
	other_craft_station_ui.input_inventory_ui.request_fast_transfer.connect(_request_fast_transfer)
	other_craft_station_ui.input_inventory_ui.request_split.connect(_request_split)
	
	player_craft_station_ui.on_craft.connect(_on_craft)
	other_craft_station_ui.on_craft.connect(_on_craft)


## Setup inventory handler and connect all signals
func setup(_character : CharacterInventorySystem):
	self.character = _character
	
	var inventories : Array[Inventory]
	inventories.append(character.main_inventory)
	#inventories.append(character.equipment_inventory)
	set_player_inventory(character.main_inventory)
	character.opened_inventory.connect(_on_open_inventory)
	character.closed_inventory.connect(_on_close_inventory)
	
	# Stations
	character.opened_station.connect(_on_open_craft_station)
	character.closed_station.connect(_on_close_craft_station)
	# Interactor
	self.interactor = interactor
	interactor_ui.setup(character.interactor)
	# Hotbar
	#hotbar_ui.set_hotbar(character.hotbar)
	


## Setup player inventories
func set_player_inventory(player_inventory : GridInventory):
	player_inventory_ui.inventory = player_inventory


func _drop_area_input(event : InputEvent):
	if event is InputEventMouseButton:
		if event.pressed:
			pass
			#character.drop_holder()


func _open_player_inventory():
	player_inventory_ui.visible = true
		
	#hotbar_ui.visible = false
	drop_area.visible = true
#	TODO console mode?
	#if console_mode and not player_inventories_ui.is_empty():
		#if player_inventories_ui[0].items.is_empty():
			#player_inventories_ui[0].items[0].grab_focus()


# Open Inventory of player	
func _on_open_inventory(inventory : Inventory):
	if character.main_inventory == inventory:
		_open_player_inventory()
	elif inventory.is_in_group("EquipmentInventory"):
		if equipment_container: equipment_container.visible = true
		_setup_equipment_slot(inventory)
	else:
		print("Opening Loot: ", inventory.name)
		loot_inventory_ui.inventory = inventory
		loot_inventory_ui.visible = true
		alternative_inventory = loot_inventory_ui.inventory
		

# Open Craft Station	
func _on_open_craft_station(craft_station : CraftStation):
	# TODO #42 Different skins for different types of craft stations
	if craft_station == character.main_station:
		player_craft_station_ui.open(craft_station)
	else:
		other_craft_station_ui.open(craft_station)
		alternative_inventory = craft_station.get_input_inventory()
	#hotbar_ui.visible = false
	_open_player_inventory()


func _on_close_craft_station(craft_station : CraftStation):
	if craft_station == character.main_station:
		player_craft_station_ui.close()
	else:
		other_craft_station_ui.close()
		alternative_inventory = null
	#hotbar_ui.visible = true
	_close_player_inventory()


func _on_close_inventory(inventory : Inventory):
	if character.main_inventory != inventory:
		alternative_inventory = null
	_close_player_inventory()


func _close_player_inventory():
	player_inventory_ui.visible = false
	loot_inventory_ui.visible = false
	equipment_container.visible = false
	#if loot_inventory_ui.inventory != null:
		#loot_inventory_ui.disconnect_old_inventory()
	drop_area.visible = false
	#hotbar_ui.visible = true


func _on_craft(craft_station : CraftStation, recipe_index : int):
	character.craft(craft_station, recipe_index)


func _request_transfer_to(inventory: GridInventory, origin_pos: Vector2i, destination: GridInventory, destination_pos: Vector2i, amount: int, is_rotated: bool):
	character.transfer_to(inventory, origin_pos, destination, destination_pos, amount, is_rotated)


func _request_fast_transfer(inventory: GridInventory, origin_pos: Vector2i, amount: int):
	var destination: Inventory
	if inventory == player_inventory_ui.inventory:
		if alternative_inventory == null:
			return
		destination = alternative_inventory
	else:
		destination = player_inventory_ui.inventory
	character.transfer(inventory, origin_pos, destination, amount)


func _request_split(inventory : Inventory, stack_index : int, amount : int):
	character.split(inventory, stack_index, amount)


func _request_drop(stack: ItemStack, inventory: Inventory):
	character.drop(stack, inventory)


func _request_rotate(stack: ItemStack, inventory: Inventory):
	character.rotate(stack, inventory)


func _request_equip(stack: ItemStack, inventory: Inventory, slot_index: int):
	character.equip(stack, inventory, slot_index)


func _request_sort(inventory : Inventory):
	character.sort(inventory)


var current_stack: ItemStack
var current_inventory: GridInventory
const STACK_MENU_ID_SPLIT = 0
const STACK_MENU_ID_DROP = 1
const STACK_MENU_ID_EQUIP = 2
const STACK_MENU_ID_ROTATE = 3
const STACK_MENU_ID_MOVE_TO = 4
const STACK_MENU_ID_SORT = 9

func _inventory_stack_context(event: InputEvent, inventory: GridInventory, stack: ItemStack):
	current_stack = stack
	current_inventory = inventory
	if !(event is InputEventMouseButton):
		return

	var mb_event: InputEventMouseButton = event
	
	#var def = inventory.database.get_item(stack.item_id)
	#var stack_name = str(stack.amount) + " x "
	#if def == null:
		#stack_name += stack.item_id
	#else:
		#stack_name += def.name
	
	stack_popup_menu.clear()
	stack_popup_menu.add_item("Split", STACK_MENU_ID_SPLIT)
	stack_popup_menu.add_item("Rotate", STACK_MENU_ID_ROTATE)
	stack_popup_menu.add_item("Drop", STACK_MENU_ID_DROP)
	
	
	
	var equip_menu : PopupMenu = PopupMenu.new()
	#for i in 4:
		#if hotbar_ui.hotbar.is_active_slot(i):
			#equip_menu.add_item(str("Equip on ",(i+1)), i)
	equip_menu.id_pressed.connect(_on_equip_menu_id_pressed)
	
	
	stack_popup_menu.add_submenu_node_item("Equip", equip_menu)
	#stack_popup_menu.add_item("Move to ", STACK_MENU_ID_MOVE_TO)
	stack_popup_menu.add_separator()
	stack_popup_menu.add_item("Sort Inventory", STACK_MENU_ID_SORT)
	
	stack_popup_menu.set_item_disabled(0, stack.amount == 1)
	
	stack_popup_menu.position = mb_event.global_position
	stack_popup_menu.popup()

func _on_stack_popup_menu_id_pressed(id: int):
	if current_stack == null:
		return
	if current_inventory == null:
		return
	match id:
		STACK_MENU_ID_SPLIT:
			var stack_index = current_inventory.stacks.find(current_stack)
			if stack_index == -1:
				return
			_request_split(current_inventory, stack_index, (int)(current_stack.amount/2.0))
		STACK_MENU_ID_DROP:
			_request_drop(current_stack, current_inventory)
		STACK_MENU_ID_ROTATE:
			_request_rotate(current_stack, current_inventory)
		STACK_MENU_ID_SORT:
			_request_sort(current_inventory)
		STACK_MENU_ID_MOVE_TO:
			_request_sort(current_inventory)


func _on_equip_menu_id_pressed(id: int):
	if current_stack == null:
		return
	if current_inventory == null:
		return
	_request_equip(current_stack, current_inventory, id)

func _connect_slot_ui_signals(slot_ui: GridInventoryUI):
	if not slot_ui.request_transfer_to.is_connected(_request_transfer_to):
		slot_ui.request_transfer_to.connect(_request_transfer_to)
	if not slot_ui.request_split.is_connected(_request_split):
		slot_ui.request_split.connect(_request_split)
	if not slot_ui.inventory_stack_context_activated.is_connected(_inventory_stack_context):
		slot_ui.inventory_stack_context_activated.connect(_inventory_stack_context)
	# Fast transfer (Shift+Click)
	if not slot_ui.request_fast_transfer.is_connected(_request_fast_transfer):
		slot_ui.request_fast_transfer.connect(_request_fast_transfer)


func _setup_equipment_slot(inventory: Inventory):
	var target_ui: GridInventoryUI = null
	
	# Mapping based on Inventory node name (defined in Player.tscn)
	# Make sure names in Player.tscn match these strings
	match inventory.name:
		"HeadSlot": target_ui = head_slot_ui
		"ChestSlot": target_ui = chest_slot_ui
		"HandSlot": target_ui = hand_slot_ui
		"BeltSlot1": target_ui = belt_slot_1_ui
		"BeltSlot2": target_ui = belt_slot_2_ui
		"BeltSlot3": target_ui = belt_slot_3_ui
	
	if target_ui != null:
		target_ui.inventory = inventory
		target_ui.visible = true
		_connect_slot_ui_signals(target_ui)
	else:
		printerr("InventorySystemUI: No UI found for equipment inventory: ", inventory.name)
</file>

<file path="godot-coop/items/definitions/equipment_data.gd">
class_name EquipmentData
extends Resource

## SlotType define el TIPO de equipamiento, no la instancia fÃ­sica.
## Un item con SlotType.BELT puede ir en cualquier BeltSlot (1, 2 o 3).
## Un item puede tener mÃºltiples allowed_slots (ej: pociÃ³n puede ir en BELT o HAND).
enum SlotType { HEAD, CHEST, HAND, BELT }

@export_group("Slot Configuration")
## Lista de slots donde este item puede equiparse.
## Ejemplo: una pociÃ³n puede tener [BELT, HAND] para equiparse en cualquiera.
@export var allowed_slots: Array[SlotType]

@export_group("Visuals")
@export var visual_scene: PackedScene 
@export var bone_name: String = "" # e.g. "Head", "RightHand"

@export_group("Gameplay Specs")
# Effects applied passively while equipped (e.g. +10 Strength)
@export var passive_effects: Array[GameplayEffect] 

# Abilities granted while equipped (e.g. Sword Slash)
@export var granted_abilities: Array[AbilityGrant]
</file>

<file path="godot-coop/items/definitions/gameplay_ability.gd">
class_name GameplayAbility
extends Resource

@export var ability_name: String = "Base Ability"

@export_group("Activation Requirements")
@export var activation_required_tags: PackedStringArray
@export var activation_blocked_tags: PackedStringArray

@export_group("Ongoing Effects")
@export var ongoing_effects: Array[GameplayEffect]


func can_activate(actor: Node) -> bool:
	var asc: AbilitySystemComponent = actor.get_node_or_null("AbilitySystemComponent")
	if not asc: 
		return false
		
	for tag in activation_required_tags:
		if not asc.has_tag(tag):
			return false 
			
	for tag in activation_blocked_tags:
		if asc.has_tag(tag):
			return false 
			
	return true


func activate(_actor: Node, _handle: AbilitySpecHandle, _args: Dictionary = {}) -> void:
	print("Base activate")


func input_released(_actor: Node, _handle: AbilitySpecHandle) -> void:
	pass


func end_ability(_actor: Node, _handle: AbilitySpecHandle) -> void:
	pass
</file>

<file path="godot-coop/items/definitions/potion_data.gd">
class_name PotionData
extends Resource

@export_group("Physics & Visuals")
@export var projectile_scene : PackedScene 
@export var throw_force : float = 15.0

@export_group("Explosion Settings")
@export var blast_radius : float = 3.0       # We keep this here (it's a physical explosion property)
@export var area_effect_duration : float = 0.5 # How long the area effect stays active (fire on the ground)

@export_group("Gameplay Effects")
# HERE'S THE KEY: An array of resources
@export var effects: Array[GameplayEffect] = []

@export_group("Inventory Item Settings")
@export var consume_on_use : bool = true


@export_group("Drink Properties")
# Optional: A specific animation or sound to play when drinking
@export var drink_animation_name: String = "drink_potion"
# Effects applied to the player who drinks it
@export var consumed_effects: Array[GameplayEffect]
@export var drink_duration: float = 1.5
</file>

<file path="godot-coop/levels/maps/main.gd">
extends Node
class_name MainCoopScene

@export var player_scene : PackedScene
@export var database : InventoryDatabase

var connected_peer_ids : Array
var players : Array
var peer : ENetMultiplayerPeer



func _ready():
	multiplayer.peer_connected.connect(_player_connected)
	multiplayer.peer_disconnected.connect(_player_disconnected)
	if OS.has_feature("server"):
		host_game()
	elif OS.has_feature("client"):
		connect_to_ip("localhost")




func host_game() -> void:
	peer = ENetMultiplayerPeer.new()
	peer.create_server(4242)
	multiplayer.set_multiplayer_peer(peer)
	create_player(multiplayer.get_unique_id())
	$"UI/Connect Panel".visible = false
	await get_tree().create_timer(1).timeout
	make_scene_objects_to_network()

func connect_to_ip(ip):
	peer = ENetMultiplayerPeer.new()
	peer.create_client(ip, 4242)
	multiplayer.set_multiplayer_peer(peer)
	$"UI/Connect Panel".visible = false
	var items = $Level/Items
	for i in items.get_child_count():
		var item = items.get_child(i)
		item.queue_free()

func create_player(client_id) -> void:
	connected_peer_ids.append(client_id)
	var player = player_scene.instantiate()
	player.name = str(client_id)
	players.append(player)
	player.position = Vector3(0,2,0)
	add_child(player)
	if multiplayer.get_unique_id() == client_id:
		$"UI/InventorySystemUI".setup(player.get_node("CharacterInventorySystem"))



func make_scene_objects_to_network() -> void:
	var items = $Level/Items
	var spawner = get_node("DroppedItemSpawner")
	for i in items.get_child_count():
		var item_dropped = items.get_child(i)
		var item_id : String = item_dropped.item_id
		var definition = database.get_item(item_id)
		var position = item_dropped.position
		var rotation = item_dropped.rotation
		var amount = item_dropped.amount
		item_dropped.queue_free()
		var dropped_item_path = definition.properties["dropped_item"]
		var _obj = spawner.spawn([position, rotation, dropped_item_path, amount])

func _player_connected(new_peer_id : int):
	if multiplayer.is_server():
		add_newly_connected_player_character.rpc(new_peer_id)
		add_previously_connected_player_characters.rpc_id(new_peer_id, connected_peer_ids)
		create_player(new_peer_id)


func _player_disconnected(peer_id : int):
	var pos = connected_peer_ids.find(peer_id)
	if pos > 0 and pos < connected_peer_ids.size():
		connected_peer_ids.remove_at(pos)
		var player = players[pos]
		players.remove_at(pos)
		player.queue_free()

@rpc
func add_newly_connected_player_character(new_peer_id):
	create_player(new_peer_id)


@rpc
func add_previously_connected_player_characters(peer_ids):
	for peer_id in peer_ids:
		create_player(peer_id)



func _on_host_button_button_up() -> void:
	host_game()
	pass # Replace with function body.


func _on_connect_button_button_up() -> void:
	connect_to_ip("localhost")
	pass # Replace with function body.
</file>

<file path="godot-coop/addons/inventory-system-demos/character/hand_item_holder_3d.gd">
class_name HandItemHolder3D
extends Node3D

#const Interactor = preload("../interaction_system/inventory_interactor.gd")
#
#
#@export var hotbar: Hotbar
#@export var interactor: NodeInventories
#@export var default_hand_item_object: MeshInstance3D 
#
#var last_item : ItemDefinition = null
#var objects_per_id : Dictionary
#
#
#func _ready():
	#hotbar.on_change_selection.connect(_on_change_selection)
	#hotbar.equipped_stack_changed.connect(_on_update_selection_stack)
	#hotbar.equipped.connect(_on_equipped)
	#hotbar.unequipped.connect(_on_unequipped)
	#_on_change_selection(hotbar.selection_index)
#
#
#func _on_equipped(_slot_index: int):
	#_on_change_selection(hotbar.selection_index)
#
#
#func _on_update_selection_stack(_slot_index: int):
	#_on_change_selection(hotbar.selection_index)
#
#
#func _on_unequipped(_slot_index: int):
	#_on_change_selection(hotbar.selection_index)
#
#
#func _on_change_selection(_new_index: int):
	#_clear_last_selection()
	#if not hotbar.has_valid_stack_on_selection():
		#interactor.set_actual_hand_object(null)
		#return
	#var stack = hotbar.get_stack_on_selection()
	#var item_id = ""
	#if stack != null:
		#item_id = stack.item_id
	#var item_definition = hotbar.database.get_item(item_id)
	#var hand_item_scene = null
	#if item_definition.properties.has("hand_item"):
		#var path = item_definition.properties["hand_item"]
		#hand_item_scene = load(path)
	#last_item = item_definition
	#if hand_item_scene == null:
		#default_hand_item_object.visible = true
		#interactor.set_actual_hand_object(null)
		#return
	#if objects_per_id.has(item_definition):
		#objects_per_id[item_definition].visible = true
	#else:
		#var hand_item_obj = hand_item_scene.instantiate()
		#add_child(hand_item_obj)
		#objects_per_id[item_definition] = hand_item_obj
	#interactor.set_actual_hand_object(objects_per_id[item_definition])
#
#
#func _clear_last_selection():
	#default_hand_item_object.visible = false
	#if last_item == null:
		#return
	#if objects_per_id.has(last_item):
		#objects_per_id[last_item].visible = false
</file>

<file path="godot-coop/characters/common_components/gas/effect_manager.gd">
class_name EffectManager
extends Node

class ActiveEffect:
	var handle: EffectSpecHandle
	var source_effect: GameplayEffect
	var time_left: float
	var tick_timer: float
	
	func _init(p_handle: EffectSpecHandle, effect: GameplayEffect):
		handle = p_handle
		source_effect = effect
		time_left = effect.duration
		tick_timer = 0.0

var _attribute_set: GASAttributeSet
var _tag_container: TagContainer

var active_effect_registry: Dictionary = {}
var active_modifiers: Dictionary = {}
var active_periodic_effects: Array[ActiveEffect] = []
## Duration effects that only apply tags (no attribute modification)
var active_duration_tag_effects: Array[ActiveEffect] = []


func _ready() -> void:
	for attr in GASAttributeSet.VALID_ATTRIBUTES:
		active_modifiers[attr] = []


func setup(attribute_set: GASAttributeSet, tag_container: TagContainer) -> void:
	_attribute_set = attribute_set
	_tag_container = tag_container
	_attribute_set.set_effect_manager(self)


func _process(delta: float) -> void:
	if not multiplayer.is_server(): return
	_process_logic(delta)


## Testable process logic - call directly in tests
func _process_logic(delta: float) -> void:
	_process_periodic_effects(delta)
	_process_duration_modifiers(delta)
	_process_duration_tag_effects(delta)


## Returns true if the effect has a valid target attribute (not "none" or empty)
func _has_valid_attribute(effect: GameplayEffect) -> bool:
	return effect.target_attribute != "" and effect.target_attribute != "none"


func apply_effects(effects: Array[GameplayEffect]) -> Array[EffectSpecHandle]:
	if not multiplayer.is_server(): return []
	return _apply_effects_logic(effects)


## Testable apply effects logic - call directly in tests
func _apply_effects_logic(effects: Array[GameplayEffect]) -> Array[EffectSpecHandle]:
	var created_handles: Array[EffectSpecHandle] = []
	
	for effect in effects:
		var has_attribute = _has_valid_attribute(effect)
		
		match effect.mode:
			GameplayEffect.ApplicationMode.INSTANT:
				GlobalLogger.log("[EffectManager] Applying INSTANT effect: '", effect.effect_name, "'")
				if has_attribute:
					_apply_instant_effect(effect)
				# For INSTANT tag-only effects, just apply tags (they stay until manually removed)
				for tag in effect.granted_tags:
					_tag_container._add_tag_logic(tag)
				
			GameplayEffect.ApplicationMode.PERIODIC:
				var handle = _create_active_effect(effect)
				GlobalLogger.log("[EffectManager] Added PERIODIC effect: '", effect.effect_name, "' Handle: ", handle)
				if has_attribute:
					active_periodic_effects.append(active_effect_registry[handle])
				created_handles.append(handle)
				
			GameplayEffect.ApplicationMode.DURATION, GameplayEffect.ApplicationMode.INFINITE:
				var handle = _create_active_effect(effect)
				GlobalLogger.log("[EffectManager] Added DURATION effect: '", effect.effect_name, "' Handle: ", handle)
				if has_attribute:
					active_modifiers[effect.target_attribute].append(active_effect_registry[handle])
					_on_modifier_changed(effect.target_attribute)
				else:
					# Tag-only duration effect - track separately for expiration
					active_duration_tag_effects.append(active_effect_registry[handle])
				created_handles.append(handle)
	
	return created_handles


func remove_effect(handle: EffectSpecHandle) -> void:
	if not multiplayer.is_server(): return
	_remove_effect_logic(handle)


## Testable remove effect logic - call directly in tests
func _remove_effect_logic(handle: EffectSpecHandle) -> void:
	if not active_effect_registry.has(handle):
		GlobalLogger.log("[EffectManager] Warning: Effect not found: ", handle)
		return
	
	var active_effect = active_effect_registry[handle]
	var source_data = active_effect.source_effect
	
	for tag in source_data.granted_tags:
		_tag_container._remove_tag_logic(tag)
	
	GlobalLogger.log("[EffectManager] Removing effect: ", handle)
	
	var has_attribute = _has_valid_attribute(source_data)
	
	match source_data.mode:
		GameplayEffect.ApplicationMode.PERIODIC:
			active_periodic_effects.erase(active_effect)
			
		GameplayEffect.ApplicationMode.DURATION, GameplayEffect.ApplicationMode.INFINITE:
			if has_attribute:
				var attr_name = source_data.target_attribute
				if active_modifiers.has(attr_name):
					active_modifiers[attr_name].erase(active_effect)
					_on_modifier_changed(attr_name)
			else:
				# Tag-only duration effect
				active_duration_tag_effects.erase(active_effect)
	
	active_effect_registry.erase(handle)


func compute_stat_with_modifiers(stat_name: String, base_value: float) -> float:
	var final_value = base_value
	var multiplier = 1.0
	
	if not active_modifiers.has(stat_name):
		return base_value
	
	for active in active_modifiers[stat_name]:
		var eff = active.source_effect
		match eff.operation:
			GameplayEffect.ModifierOp.ADD: 
				final_value += eff.value
			GameplayEffect.ModifierOp.SUBTRACT: 
				final_value -= eff.value
			GameplayEffect.ModifierOp.MULTIPLY: 
				multiplier *= eff.value
			GameplayEffect.ModifierOp.DIVIDE: 
				if eff.value != 0: 
					multiplier /= eff.value
			
	return final_value * multiplier


func _create_active_effect(effect: GameplayEffect) -> EffectSpecHandle:
	var handle = EffectSpecHandle.new(effect.effect_name)
	var active = ActiveEffect.new(handle, effect)
	active_effect_registry[handle] = active
	
	for tag in effect.granted_tags:
		_tag_container._add_tag_logic(tag)

	return handle


func _apply_instant_effect(effect: GameplayEffect) -> void:
	_attribute_set.apply_instant_change(effect.target_attribute, effect.value, effect.operation)


func _on_modifier_changed(stat_name: String) -> void:
	GlobalLogger.log("[EffectManager] Recalculating stat: ", stat_name, " | New Total: ", _attribute_set.get_computed_stat(stat_name))
	if stat_name == "max_health":
		_attribute_set.on_max_health_changed()


func _process_periodic_effects(delta: float) -> void:
	for i in range(active_periodic_effects.size() - 1, -1, -1):
		var active = active_periodic_effects[i]
		active.time_left -= delta
		active.tick_timer += delta
		
		if active.tick_timer >= active.source_effect.tick_rate:
			active.tick_timer = 0.0
			# Only apply attribute change if target_attribute is valid
			if _has_valid_attribute(active.source_effect):
				_apply_instant_effect(active.source_effect)
			
		if active.time_left <= 0:
			active_effect_registry.erase(active.handle)
			active_periodic_effects.remove_at(i)
			for tag in active.source_effect.granted_tags:
				_tag_container._remove_tag_logic(tag)


func _process_duration_modifiers(delta: float) -> void:
	for attr in active_modifiers.keys():
		var modifiers_list = active_modifiers[attr]
		var changed = false
		
		for i in range(modifiers_list.size() - 1, -1, -1):
			var active = modifiers_list[i]
			if active.source_effect.mode == GameplayEffect.ApplicationMode.INFINITE:
				continue
			
			active.time_left -= delta
			if active.time_left <= 0:
				for tag in active.source_effect.granted_tags:
					_tag_container._remove_tag_logic(tag)
				active_effect_registry.erase(active.handle)
				modifiers_list.remove_at(i)
				changed = true
		
		if changed:
			_on_modifier_changed(attr)


## Process duration effects that only have tags (no attribute modification)
func _process_duration_tag_effects(delta: float) -> void:
	for i in range(active_duration_tag_effects.size() - 1, -1, -1):
		var active = active_duration_tag_effects[i]
		if active.source_effect.mode == GameplayEffect.ApplicationMode.INFINITE:
			continue
		
		active.time_left -= delta
		if active.time_left <= 0:
			GlobalLogger.log("[EffectManager] Duration tag effect expired: '", active.source_effect.effect_name, "'")
			for tag in active.source_effect.granted_tags:
				_tag_container._remove_tag_logic(tag)
			active_effect_registry.erase(active.handle)
			active_duration_tag_effects.remove_at(i)
</file>

<file path="godot-coop/interactables/interactable_base.gd">
class_name InteractableBase
extends StaticBody3D

# --- CONFIGURATION ---
@export_group("Interaction Settings")
@export var object_name: String = "Interactable"
@export var interaction_text: String = "Interact"


@export var default_action: InteractAction
var current_interactor: Node = null


var is_being_used: bool = false 

# --- INTERFAZ OBLIGATORIA (Contrato con InventoryInteractor) ---


func get_interaction_position(interaction_point: Vector3) -> Vector3:
	return global_position


func get_interact_actions(interactor: Node) -> Array:
	if not _can_interact(interactor):
		return []
	
	if default_action:
		default_action.description = interaction_text + " " + object_name
		return [default_action]
	
	return []


func interact(character: Node, action_index: int = 0) -> void:
	if not _can_interact(character):
		return
	
	if multiplayer.is_server():
		_server_interact(character)
	else:
		_request_interact_rpc.rpc_id(1, character.get_path())


## Testable interact logic - call directly in tests (bypasses network check)
func _interact_logic(character: Node, _action_index: int = 0) -> void:
	if not _can_interact(character):
		return
	_server_interact(character)



func _can_interact(_character: Node) -> bool:
	return true # By default always allowed

# This is the function that Chests and Bushes will override
func _on_interacted(character: Node) -> void:
	print("Interacted with ", object_name)

# --- RED ---

@rpc("any_peer", "call_local", "reliable")
func _request_interact_rpc(character_path: NodePath) -> void:
	# Solo el servidor ejecuta esto
	if not multiplayer.is_server(): return
	
	var character = get_node(character_path)
	if character:
		_server_interact(character)

func _server_interact(character: Node):
	if current_interactor != null and current_interactor != character:
		print("Objeto ocupado por otro jugador")
		return

	current_interactor = character
	_on_interacted(character)


func cancel_interaction():
	if current_interactor == null: return
	
	print("InteracciÃ³n cancelada con ", current_interactor.name)
	_on_interaction_canceled() # Hook virtual para los hijos
	current_interactor = null

func _on_interaction_canceled():
	pass
</file>

<file path="godot-coop/interactables/loot_container/loot_container.gd">
class_name LootContainer
extends InteractableBase

# --- REFERENCIAS ---
@onready var inventory: Inventory = $GridInventory
@onready var loot_generator: LootGenerator = $LootGenerator
@onready var reveal_timer: Timer = $RevealTimer
@onready var openable: NetworkedOpenable = $NetworkedOpenable


# --- DATA ---
@export var data: LootContainerData

# --- ESTADO ---
var is_opened: bool = false
var searching_process_active: bool = false
const MAX_INTERACT_DISTANCE_SQR = 3.0 * 3.0

func _ready():
	$GridInventory.set_multiplayer_authority(1)
	$GridInventory/SyncGridInventory.set_multiplayer_authority(1)
	$NetworkedOpenable.set_multiplayer_authority(1)
	$LootGenerator.set_multiplayer_authority(1)
	interaction_text = "Search"
	
	# Configurar generador
	if data:
		loot_generator.loot_id = data.loot_table_id
		# Apuntamos el generador a NUESTRO PROPIO inventario
		loot_generator.target_inventory_path = inventory.get_path()
func _process(_delta):
	if not multiplayer.is_server(): return
	
	if current_interactor == null:
		set_process(false)
		return
		
	# If too far away -> Force cancel
	if global_position.distance_squared_to(current_interactor.global_position) > MAX_INTERACT_DISTANCE_SQR:
		# Force close UI on client (optional, but recommended)
		var char_sys = current_interactor.get_node_or_null("CharacterInventorySystem")
		if char_sys:
			char_sys.close_inventories() # This will trigger the closed_inventory signal
		
		cancel_interaction()
# Override base interaction
func _on_interacted(character: Node):
	# Previous inventory opening logic...
	if not is_opened:
		_first_time_generation()
		is_opened = true
	
	var char_sys = character.get_node_or_null("CharacterInventorySystem")
	if char_sys:
		char_sys.open_inventory(inventory)
		
		# CONNECTION: Listen if player closes inventory voluntarily
		# Connect with CONNECT_ONE_SHOT flag so it disconnects automatically when triggered
		if not char_sys.closed_inventory.is_connected(_on_player_closed_inventory):
			char_sys.closed_inventory.connect(_on_player_closed_inventory)
	
	# Activate distance check
	set_process(true)
	
	# Start search
	if data.auto_search_on_open:
		_start_revealing_sequence()

func _on_player_closed_inventory(closed_inv: Inventory):
	# Verify they closed THIS inventory (in case they have multiple open)
	if closed_inv == inventory:
		cancel_interaction()

func _on_interaction_canceled():
	# STOP THE REVEAL PROCESS
	searching_process_active = false
	reveal_timer.stop()
	set_process(false) # Stop checking distance
	
	# Disconnect signal for safety (if it wasn't one_shot or if we cancel due to distance)
	if current_interactor:
		var char_sys = current_interactor.get_node_or_null("CharacterInventorySystem")
		if char_sys and char_sys.closed_inventory.is_connected(_on_player_closed_inventory):
			char_sys.closed_inventory.disconnect(_on_player_closed_inventory)
	
	print("Search stopped. Remaining items stay hidden.")

func _first_time_generation():
	if not multiplayer.is_server(): return
	
	loot_generator.add_loot_to_inventory()
	
	for i in range(inventory.stacks.size()):
		var stack = inventory.stacks[i]
		if stack != null and stack.item_id != "":
			var unique_properties = stack.properties.duplicate(true)
			
			# CAMBIO: En lugar de 'revealed' = false, usamos un array vacÃ­o
			# Este array contendrÃ¡ los Peer IDs de quienes ya lo descubrieron.
			unique_properties["revealed_to"] = [] 
			
			stack.properties = unique_properties
			inventory.update_stack(i)
	
	print("Loot generated with per-player reveal system.")

func _start_revealing_sequence():
	if not multiplayer.is_server(): return
	if searching_process_active: return
	
	# Buscamos si queda algo por revelar
	if _has_hidden_items():
		searching_process_active = true
		_schedule_next_reveal()

func _schedule_next_reveal():
	# Conectamos el timer para el siguiente "tick"
	if not reveal_timer.is_connected("timeout", _reveal_next_item):
		reveal_timer.timeout.connect(_reveal_next_item)
	
	reveal_timer.start(data.seconds_to_reveal_per_item)

func _reveal_next_item():
	if not multiplayer.is_server(): return
	if not is_instance_valid(current_interactor): return
	
	# Obtenemos la ID del jugador actual (asumiendo que el nombre es la ID, segÃºn tu setup)
	var player_id = current_interactor.name.to_int()
	
	for i in inventory.stacks.size():
		var stack = inventory.stacks[i]
		if stack != null and stack.item_id != "":
			# Recuperamos la lista (o creamos una si no existe por seguridad)
			var revealed_list: Array = stack.properties.get("revealed_to", [])
			
			# Si ESTE jugador NO estÃ¡ en la lista...
			if player_id not in revealed_list:
				# 2. REVEAL IT FOR THIS PLAYER
				revealed_list.append(player_id)
				stack.properties["revealed_to"] = revealed_list
				
				# Sincronizamos
				inventory.update_stack(i) 
				
				print("Item revealed in slot ", i, " for player ", player_id)
				
				_schedule_next_reveal()
				return 

	searching_process_active = false
	print("Search completed for player ", player_id)

func _has_hidden_items() -> bool:
	if not is_instance_valid(current_interactor): return false
	var player_id = current_interactor.name.to_int()
	
	for stack in inventory.stacks:
		if stack != null and stack.item_id != "":
			var revealed_list: Array = stack.properties.get("revealed_to", [])
			# Si el jugador NO estÃ¡ en la lista, significa que para Ã©l estÃ¡ oculto
			if player_id not in revealed_list:
				return true
	return false

func open(character : Node):
	openable.open(character)


func close(character : Node):
	openable.close(character)
</file>

<file path="godot-coop/items/abilities/ga_drink_potion.gd">
class_name GA_Drink_Potion
extends GameplayAbility


func activate(actor: Node, handle: AbilitySpecHandle, _args: Dictionary = {}) -> void:
	var asc: AbilitySystemComponent = actor.get_node_or_null("AbilitySystemComponent")
	if not asc: return
	
	var potion_data = _get_potion_data_from_source(asc, handle)
	if not potion_data: 
		GlobalLogger.log("[GA_Drink_Potion] No potion_data found in item properties")
		return
	
	GlobalLogger.log("[GA_Drink_Potion] Starting to drink potion... Hold for ", potion_data.drink_duration, "s")
	
	var on_complete = func(): _on_drink_complete(actor, handle, potion_data)
	var on_cancel = func(): _on_drink_cancelled(actor, handle)
	
	asc.start_cast(handle, potion_data.drink_duration, on_complete, on_cancel)


func _on_drink_complete(actor: Node, handle: AbilitySpecHandle, potion_data: PotionData) -> void:
	GlobalLogger.log("[GA_Drink_Potion] Drink complete! Applying effects...")
	
	var asc: AbilitySystemComponent = actor.get_node_or_null("AbilitySystemComponent")
	if not asc: return
	
	if potion_data.consumed_effects.size() > 0:
		asc.apply_gameplay_effects(potion_data.consumed_effects)
	
	if potion_data.consume_on_use:
		_consume_source_item(asc, handle)


func _on_drink_cancelled(_actor: Node, _handle: AbilitySpecHandle) -> void:
	GlobalLogger.log("[GA_Drink_Potion] Drink cancelled! Potion not consumed.")


func _get_potion_data_from_source(asc: AbilitySystemComponent, handle: AbilitySpecHandle) -> PotionData:
	var source = asc.get_ability_source(handle)
	var inventory: Inventory = source.get("inventory")
	var slot_index: int = source.get("slot", -1)
	
	if not inventory or slot_index == -1: return null
	
	var stack = inventory.stacks[slot_index]
	if not stack: return null
	
	var item_def = inventory.database.get_item(stack.item_id)
	if not item_def: return null
	
	if not item_def.properties.has("potion_data"): return null
	return load(item_def.properties["potion_data"]) as PotionData


func _consume_source_item(asc: AbilitySystemComponent, handle: AbilitySpecHandle) -> void:
	var source = asc.get_ability_source(handle)
	var inventory: Inventory = source.get("inventory")
	var slot_index: int = source.get("slot", -1)
	
	if inventory and slot_index != -1:
		inventory.remove_at(slot_index, inventory.stacks[slot_index].item_id, 1)
</file>

<file path="godot-coop/systems/inventory/equipment_slot_constraint.gd">
class_name EquipmentSlotConstraint
extends GridInventoryConstraint

# The slot this inventory accepts
@export var allowed_slot: Array[EquipmentData.SlotType]

# 1. Entry point for Grid Drag & Drop
func _can_add_on_position(inventory: Node, position: Vector2i, item_id: String, amount: int, properties: Dictionary, is_rotated: bool) -> bool:
	return _validate_item(inventory, item_id)

# 2. Entry point for Auto-Add / Quick Transfer (for safety)
func _can_add_on_inventory(inventory: Node, item_id: String, amount: int, properties: Dictionary) -> bool:
	return _validate_item(inventory, item_id)

# --- Common Logic ---
func _validate_item(inventory: Node, item_id: String) -> bool:
	# 1. Get database
	if not "database" in inventory: 
		return false
	
	var def = inventory.database.get_item(item_id)
	if def == null: 
		return false
	
	# 2. Check if it has equipment data
	# NOTE: Make sure the property name in the DB is EXACTLY "equipment_data"
	if not def.properties.has("equipment_data"):
		return false 
	
	var data_path = def.properties["equipment_data"] 
	var data = load(data_path) as EquipmentData
	if data == null: 
		return false
	
	# 3. Validate the Slot
	# Check if ANY of the item's allowed_slots matches ANY slot this constraint accepts
	for item_slot in data.allowed_slots:
		if allowed_slot.has(item_slot):
			return true
		
	# Optional feedback (debug only)
	# print("Rejected: Item allows ", data.allowed_slots, " but slot requires ", allowed_slot)
	return false
</file>

<file path="godot-coop/items/definitions/gameplay_effect.gd">
@tool
class_name GameplayEffect
extends Resource

# 1. New application modes
enum ApplicationMode { INSTANT, PERIODIC, DURATION, INFINITE }
enum ModifierOp { ADD, SUBTRACT, MULTIPLY, DIVIDE } 

## Leave empty ("") to apply only tags without modifying any attribute.
var target_attribute: String = ""

@export_group("Effect Definition")
## Only used if target_attribute is set.
@export var operation: ModifierOp = ModifierOp.SUBTRACT
## Only used if target_attribute is set.
@export var value: float = 10.0

@export_group("Timing")
@export var mode: ApplicationMode = ApplicationMode.INSTANT
@export var duration: float = 0.0     
@export var tick_rate: float = 1.0    

@export_group("Visuals")
@export var effect_name: String = "Generic Effect" 
@export var vfx_tag: String = "" 

@export_group("GameplayTags")
@export var granted_tags: PackedStringArray

func _get_property_list() -> Array:
	var properties = []
	# Add "none" option at the beginning for tag-only effects
	var options = ["none"]
	options.append_array(GASAttributeSet.VALID_ATTRIBUTES)
	var hint_string = ",".join(options)
	
	properties.append({
		"name": "target_attribute",
		"type": TYPE_STRING,
		"usage": PROPERTY_USAGE_DEFAULT,
		"hint": PROPERTY_HINT_ENUM,
		"hint_string": hint_string
	})
	
	return properties
</file>

<file path="godot-coop/systems/projectile_spawner.gd">
extends MultiplayerSpawner

class_name ProjectileSpawner


func _init() -> void:
	spawn_function = _spawn_projectile

func _spawn_projectile(data: Array):
	var pos = data[0]
	var rot_data = data[1] # Le cambio el nombre a rot_data
	var vel = data[2]
	var path_to_tres = data[3]
	var thrower_id = 0
	if data.size() > 4:
		thrower_id = data[4]
	
	var stats_resource = load(path_to_tres) as PotionData
	if not stats_resource: return null
	var scene_inside_resource = stats_resource.projectile_scene

	if not scene_inside_resource: return null
	var obj = scene_inside_resource.instantiate()
	
	# POSITION ASSIGNMENT
	obj.position = pos
	
	# --- FIX HERE ---
	# Check the data type to assign it correctly
	if rot_data is Basis:
		# If it's a Basis (Matrix), assign it to the transform's basis
		obj.transform.basis = rot_data
	elif rot_data is Vector3:
		# If it's a Vector3 (Euler), assign it to rotation
		obj.rotation = rot_data
	# -----------------------

	if obj is RigidBody3D:
		obj.linear_velocity = vel
		
	if obj.has_method("setup_projectile"):
		# Note: make sure setup_projectile expects the Resource, not the path
		obj.setup_projectile(stats_resource, vel)
	
	return obj
</file>

<file path="godot-coop/characters/character_base.gd">
class_name CharacterBase
extends CharacterBody3D

@onready var ability_system: AbilitySystemComponent = $AbilitySystemComponent


func _enter_tree() -> void:
	pass


func receive_gameplay_effects(effects: Array[GameplayEffect]) -> void:
	if ability_system:
		ability_system.apply_gameplay_effects(effects)
</file>

<file path="godot-coop/systems/inventory/inventory_system_manager.gd">
@tool
@icon("res://addons/inventory-system-demos/icons/character_inventory_system.svg")
class_name InventorySystemManager
extends NetworkedCharacterInventorySystem
@export_node_path var equipment_manager_path := NodePath("EquipmentManager")


func _ready():
	if Engine.is_editor_hint():
		return
	if is_multiplayer_authority():
		# Setup for enabled/disabled mouse ðŸ–±ï¸ðŸ˜€
		if change_mouse_state:
			opened_inventory.connect(_update_opened_inventories)
			closed_inventory.connect(_update_opened_inventories)
			opened_station.connect(_update_opened_stations)
			closed_station.connect(_update_opened_stations)
			_update_opened_inventories(main_inventory)
	else:
		picked.connect(_on_picked)
	#hotbar.active_slot(0)
	#hotbar.active_slot(1)
	#hotbar.active_slot(2)
	#hotbar.active_slot(3)
	#hotbar.active_slot(4)
	#hotbar.active_slot(5)
	#hotbar.active_slot(6)
	#hotbar.active_slot(7)


func _on_picked(obj : Node):
	if not is_instance_valid(obj): 
		return
	picked_rpc.rpc(obj.get_path())


func _input(event : InputEvent) -> void:
	if Engine.is_editor_hint():
		return
	if check_inputs and is_multiplayer_authority():
		#hot_bar_inputs(event)
		inventory_inputs()


func _physics_process(_delta : float):
	if Engine.is_editor_hint():
		return
	if not can_interact:
		return
	if multiplayer.multiplayer_peer != null and is_multiplayer_authority():
		interactor.try_interact()


func is_any_station_or_inventory_opened() -> bool:
	return is_open_any_station() or is_open_main_inventory()


func _update_opened_inventories(_inventory : Inventory):
	_check_inputs()


func _update_opened_stations(_craft_station : CraftStation):
	_craft_station.load_valid_recipes()
	_check_inputs()


func _check_inputs():
	if is_any_station_or_inventory_opened():
		Input.mouse_mode = Input.MOUSE_MODE_VISIBLE
	else:
		Input.mouse_mode = Input.MOUSE_MODE_CAPTURED


func inventory_inputs():
	if Input.is_action_just_released(toggle_inventory_input):
		if not is_any_station_or_inventory_opened():
			open_main_inventory()

	if Input.is_action_just_released(exit_inventory_and_craft_panel_input):
		close_inventories()
		close_craft_stations()

	if Input.is_action_just_released(toggle_craft_panel_input):
		if not is_any_station_or_inventory_opened():
			open_main_craft_station()


#region Pick
func pick_to_inventory(node : Node):
	if multiplayer.is_server():
		_pick_to_inventory_logic(node)
	else:
		pick_to_inventory_rpc.rpc_id(1, node.get_path())


func _pick_to_inventory_logic(node : Node):
	if main_inventory == null:
		return

	if node == null:
		return

	if !node.get("is_pickable"):
		return

	var item_id = node.item_id
	var item_properties = node.item_properties
	var amount = node.amount

	if main_inventory.add(item_id, amount, item_properties, true) == 0:
		picked.emit(node)
		node.queue_free();
		return

	printerr("pick_to_inventory return false");
#endregion


#region Transfer
func transfer(inventory: GridInventory, origin_pos: Vector2i, destination: GridInventory, amount: int):
	if multiplayer.is_server():
		# Si soy el servidor, lo hago normal
		super.transfer(inventory, origin_pos, destination, amount)
	else:
		# Si soy cliente, NO lo hago local. Se lo pido al server.
		transfer_rpc.rpc_id(1, inventory.get_path(), origin_pos, destination.get_path(), amount)


func transfer_to(inventory: GridInventory, origin_pos: Vector2i, destination: GridInventory, destination_pos: Vector2i, amount: int, is_rotated: bool):
	if multiplayer.is_server():
		_transfer_to_logic(inventory, origin_pos, destination, destination_pos, amount, is_rotated)
	else:
		transfer_to_rpc.rpc_id(1, inventory.get_path(), origin_pos, destination.get_path(), destination_pos, amount, is_rotated)


func _transfer_to_logic(inventory: GridInventory, origin_pos: Vector2i, destination: GridInventory, destination_pos: Vector2i, amount: int, is_rotated: bool):
	inventory.transfer_to(origin_pos, destination, destination_pos, amount, is_rotated)
#endregion


#region Split
func split(inventory : Inventory, stack_index : int, amount : int):
	if multiplayer.is_server():
		_split_logic(inventory, stack_index, amount)
	else:
		split_rpc.rpc_id(1, inventory.get_path(), stack_index, amount)


func _split_logic(inventory : Inventory, stack_index : int, amount : int):
	inventory.split(stack_index, amount)
#endregion


#region Equip
#func equip(stack: ItemStack, inventory: Inventory, slot_index: int):
	#if multiplayer.is_server():
		#_equip_logic(stack, inventory, slot_index)
	#else:
		#var stack_index = inventory.stacks.find(stack)
		#if stack_index != -1:
			#equip_rpc.rpc_id(1, stack_index, inventory.get_path(), slot_index)


#func _equip_logic(stack: ItemStack, _inventory : Inventory, slot_index: int):
	#hotbar.equip(stack, slot_index)
#endregion


#region Rotate
func rotate(stack: ItemStack, inventory : Inventory):
	if multiplayer.is_server():
		_rotate_logic(stack, inventory)
	else:
		var stack_index = inventory.stacks.find(stack)
		if stack_index != -1:
			rotate_rpc.rpc_id(1, stack_index, inventory.get_path())


func _rotate_logic(stack: ItemStack, inventory : Inventory):
	inventory.rotate(stack)
#endregion


#region Sort
func sort(inventory : Inventory):
	if multiplayer.is_server():
		_sort_logic(inventory)
	else:
		sort_rpc.rpc_id(1, inventory.get_path())


func _sort_logic(inventory : Inventory):
	inventory.sort()
#endregion


#region Drop
func drop(stack: ItemStack, inventory: Inventory):
	if multiplayer.is_server():
		_drop_logic(stack, inventory)
	else:
		var stack_index = inventory.stacks.find(stack)
		if stack_index != -1:
			drop_rpc.rpc_id(1, stack_index, inventory.get_path())


func _drop_logic(stack: ItemStack, inventory: Inventory):
	var stack_index = inventory.stacks.find(stack)
	if stack_index == -1:
		return
	inventory.drop_from_inventory(stack_index, stack.amount, stack.properties)


func drop_all_items():
	main_inventory.drop_all_stacks()
	#equipment_inventory.drop_all_stacks()
#endregion


#region Crafter
func craft(craft_station : CraftStation, recipe_index : int):
	if multiplayer.is_server():
		_craft_logic(craft_station, recipe_index)
	else:
		craft_rpc.rpc(craft_station.get_path(), recipe_index)


func _craft_logic(craft_station : CraftStation, recipe_index : int):
	craft_station.craft(recipe_index)
#endregion


#region Hotbar
#func hot_bar_inputs(event : InputEvent):
	#if event is InputEventMouseButton:
		#if event.is_pressed():
			#if event.button_index == MOUSE_BUTTON_WHEEL_UP:
				#hotbar_previous_item()
			#if event.button_index == MOUSE_BUTTON_WHEEL_DOWN:
				#hotbar_next_item()
	#if event is InputEventKey:
		#var input_key_event = event as InputEventKey
		#if event.is_pressed() and not event.is_echo():
			#if input_key_event.keycode > KEY_0 and input_key_event.keycode < KEY_9:
				#hotbar_change_selection(input_key_event.keycode - KEY_1)


#func hotbar_change_selection(index : int):
	#if multiplayer.is_server():
		#_hotbar_change_selection_logic(index)
	#else:
		#hotbar_change_selection_rpc.rpc_id(1, index)


#func _hotbar_change_selection_logic(index : int):
	#if hotbar.selection_index == index:
		#index = -1
	#hotbar.selection_index = index


#func hotbar_previous_item():
	#if multiplayer.is_server():
		#_hotbar_previous_item_logic()
	#else:
		#hotbar_previous_item_rpc.rpc_id(1)


#func _hotbar_previous_item_logic():
	#hotbar.previous_item()


#func hotbar_next_item():
	#if multiplayer.is_server():
		#_hotbar_next_item_logic()
	#else:
		#hotbar_next_item_rpc.rpc_id(1)


#func _hotbar_next_item_logic():
	#hotbar.next_item()
#endregion


#region Open Inventories
#region Open Inventories
func is_open_inventory(inventory : Inventory):
	return opened_inventories.find(inventory) != -1


func open_inventory(inventory : Inventory):
	if multiplayer.is_server():
		_open_inventory_logic(inventory)
		# Si abrimos un inventario externo suelto, intentamos activar su Openable
		_set_openable_state(inventory, true) 
	else:
		open_inventory_rpc.rpc_id(1, inventory.get_path())


func _open_inventory_logic(inventory : Inventory):
	if is_open_inventory(inventory):
		return
	add_open_inventory(inventory)


func add_open_inventory(inventory : Inventory):
	if multiplayer.is_server():
		add_open_inventory_rpc.rpc(inventory.get_path())
	_add_open_inventory_logic(inventory)


func _add_open_inventory_logic(inventory : Inventory):
	opened_inventories.append(inventory)
	opened_inventory.emit(inventory)
	if not is_open_main_inventory():
		open_main_inventory()


func open_main_inventory():
	if multiplayer.is_server():
		_open_main_inventory_logic()
	else:
		open_main_inventory_rpc.rpc_id(1)


func _open_main_inventory_logic():
	# 1. Abrir inventario principal
	_open_inventory_logic(main_inventory)
	_set_openable_state(main_inventory, true)
	
	# 2. Abrir inventarios de equipamiento (Usando el EquipmentManager)
	if equipment_manager:
		for slot in equipment_manager.get_children():
			if slot and slot is Inventory:
				_open_inventory_logic(slot)
				_set_openable_state(slot, true)


func close_inventory(inventory : Inventory):
	# Manejo de contenedores externos (Chest, Box)
	if main_inventory != inventory:
		# Si el padre tiene metodo close (ej. BoxInventory), lo llamamos
		if inventory.get_parent().has_method("close"):
			inventory.get_parent().close(get_parent())
	
	# Manejo del nodo Openable interno del inventario
	_set_openable_state(inventory, false)
	
	remove_open_inventory(inventory)


func remove_open_inventory(inventory : Inventory):
	if multiplayer.is_server():
		remove_open_inventory_rpc.rpc(inventory.get_path())
	_remove_open_inventory_logic(inventory)


func _remove_open_inventory_logic(inventory : Inventory):
	var index = opened_inventories.find(inventory)
	opened_inventories.remove_at(index)
	closed_inventory.emit(inventory)


func close_inventories():
	if multiplayer.is_server():
		_close_inventories_logic()
	else:
		close_inventories_rpc.rpc_id(1)


func _close_inventories_logic():
	for index in range(opened_inventories.size() - 1, -1, -1):
		close_inventory(opened_inventories[index])


func is_open_any_inventory():
	return !opened_inventories.is_empty()


func is_open_main_inventory():
	return is_open_inventory(main_inventory)
#endregion


#region Open Craft Stations
func is_open_station(station : CraftStation):
	return opened_stations.find(station) != -1


func open_station(craft_station : CraftStation):
	if multiplayer.is_server():
		_open_station_logic(craft_station)
	else:
		open_station_rpc.rpc(get_path_to(craft_station))


func _open_station_logic(station : CraftStation):
	if is_open_station(station):
		return
	add_open_station(station)


func add_open_station(craft_station : CraftStation):
	if multiplayer.is_server():
		add_open_station_rpc.rpc(craft_station.get_path())
	_add_open_station_logic(craft_station)


func _add_open_station_logic(station : CraftStation):
	opened_stations.append(station)
	opened_station.emit(station)


func close_station(station : CraftStation):
	if not is_open_station(station):
		return
	remove_open_station(station)


func remove_open_station(craft_station : CraftStation):
	if multiplayer.is_server():
		remove_open_station_rpc.rpc(craft_station.get_path())
	_remove_open_station_logic(craft_station)


func _remove_open_station_logic(station : CraftStation):
	var index = opened_stations.find(station)
	opened_stations.remove_at(index)
	closed_station.emit(station)
	if main_station != station:
		station.get_parent().close(get_parent())


func open_main_craft_station():
	if multiplayer.is_server():
		_open_main_craft_station_logic()
	else:
		open_main_craft_station_rpc.rpc_id(1)


func _open_main_craft_station_logic():
	_open_station_logic(main_station)


func close_craft_stations():
	if multiplayer.is_server():
		_close_craft_stations_logic()
	else:
		close_stations_rpc.rpc_id(1)


func _close_craft_stations_logic():
	for index in range(opened_stations.size() - 1, -1, -1):
		close_station(opened_stations[index])


func is_open_any_station():
	return !opened_stations.is_empty()
#endregion


#region RPCs
@rpc("any_peer")
func picked_rpc(obj_path : NodePath):
	var obj = get_node_or_null(obj_path)
	if is_instance_valid(obj):
		picked.emit(obj)


@rpc("any_peer")
func open_main_inventory_rpc():
	_open_main_inventory_logic()


@rpc
func open_inventory_rpc(inventory_path : NodePath):
	var inventory = get_node(inventory_path)
	_open_inventory_logic(inventory)


@rpc("any_peer")
func add_open_inventory_rpc(inventory_path : NodePath):
	var inventory = get_node(inventory_path)
	_add_open_inventory_logic(inventory)


@rpc("any_peer")
func remove_open_inventory_rpc(inventory_path : NodePath):
	var inventory = get_node(inventory_path)
	_remove_open_inventory_logic(inventory)


@rpc("any_peer")
func add_open_station_rpc(station_path : NodePath):
	var station = get_node(station_path)
	_add_open_station_logic(station)


@rpc("any_peer")
func remove_open_station_rpc(station_path : NodePath):
	var station = get_node(station_path)
	_remove_open_station_logic(station)


@rpc
func close_inventories_rpc():
	if multiplayer.is_server():
		_close_inventories_logic()


@rpc
func pick_to_inventory_rpc(node_path: NodePath):
	_pick_to_inventory_logic(get_node(node_path))


@rpc
func transfer_to_rpc(inventory_path: NodePath, origin_pos: Vector2i, destination_path: NodePath, destination_pos: Vector2i, amount: int, is_rotated: bool):
	var inv = get_node(inventory_path)
	var dest_inv = get_node(destination_path)
	if inv == null or dest_inv == null:
		return
	_transfer_to_logic(inv, origin_pos, dest_inv, destination_pos, amount, is_rotated)

@rpc("any_peer", "call_local")
func transfer_rpc(inventory_path: NodePath, origin_pos: Vector2i, destination_path: NodePath, amount: int):
	var inv = get_node(inventory_path)
	var dest = get_node(destination_path)
	
	# ValidaciÃ³n bÃ¡sica de seguridad
	if inv == null or dest == null:
		return
		
	# Ejecutamos la lÃ³gica real en el servidor
	super.transfer(inv, origin_pos, dest, amount)


@rpc
func split_rpc(inventory_path: NodePath, stack_index: int, amount: int):
	var inv = get_node(inventory_path)
	if inv == null:
		return
	_split_logic(inv, stack_index, amount)


@rpc
func rotate_rpc(stack_index: int, inventory_path: NodePath):
	var inv = get_node(inventory_path)
	if inv == null:
		return
	var stack = inv.stacks[stack_index]
	_rotate_logic(stack, inv)


@rpc
func sort_rpc(inventory_path: NodePath):
	var inv = get_node(inventory_path)
	if inv == null:
		return
	_sort_logic(inv)


@rpc
func drop_rpc(stack_index: int, inventory_path: NodePath):
	var inv = get_node(inventory_path)
	if inv == null:
		return
	var stack = inv.stacks[stack_index]
	_drop_logic(stack, inv)


#@rpc
#func equip_rpc(stack_index: int, inventory_path: NodePath, slot_index: int):
	#var inv = get_node(inventory_path)
	#if inv == null:
		#return
	#var stack = inv.stacks[stack_index]
	#_equip_logic(stack, inv, slot_index)
#
#
#@rpc
#func hotbar_change_selection_rpc(selection_index: int):
	#if not multiplayer.is_server():
		#return
	#_hotbar_change_selection_logic(selection_index)
#
#
#@rpc
#func hotbar_previous_item_rpc():
	#if not multiplayer.is_server():
		#return
	#_hotbar_previous_item_logic()

#
#@rpc
#func hotbar_next_item_rpc():
	#if not multiplayer.is_server():
		#return
	#_hotbar_next_item_logic()


@rpc
func open_main_craft_station_rpc():
	_open_main_craft_station_logic()


@rpc
func open_station_rpc(craft_station_path : NodePath):
	var station = get_node(craft_station_path)
	_open_station_logic(station)


@rpc
func close_stations_rpc():
	if multiplayer.is_server():
		_close_craft_stations_logic()


@rpc
func craft_rpc(craft_station_path : NodePath, recipe_index : int):
	var station = get_node(craft_station_path)
	_craft_logic(station, recipe_index)
#endregion

#region Helpers
func _set_openable_state(inventory: Inventory, is_open: bool):
	# 1. Check if it has Openable node as direct child
	var openable = inventory.get_node_or_null("Openable")
	
	# 2. (Optional) If not a child, check if it's a sibling (BoxInventory pattern)
	if not openable:
		var parent = inventory.get_parent()
		if parent:
			openable = parent.get_node_or_null("Openable")
	
	# 3. Execute the action
	if openable:
		# Asumimos que drop_parent es el CharacterBody3D (el 'character')
		if is_open:
			if openable.has_method("open"):
				openable.open(drop_parent)
		else:
			if openable.has_method("close"):
				openable.close(drop_parent)
#endregion
</file>

<file path="godot-coop/items/abilities/ga_throw_projectile.gd">
extends GameplayAbility
class_name GA_ThrowProjectile


func activate(actor: Node, handle: AbilitySpecHandle, args: Dictionary = {}) -> void:
	if Input.get_mouse_mode() != Input.MOUSE_MODE_CAPTURED: return
	
	var asc: AbilitySystemComponent = actor.get_node_or_null("AbilitySystemComponent")
	if not asc: return
	
	var potion_data = _get_potion_data_from_source(asc, handle)
	if not potion_data:
		GlobalLogger.log("[GA_ThrowProjectile] No potion_data found in item properties")
		return
	
	var direction = Vector3.FORWARD
	var spawn_pos = actor.global_position + Vector3(0, 1.5, 0)
	
	if args.has("aim_direction"):
		direction = args["aim_direction"]
	else:
		direction = -actor.global_transform.basis.z

	var velocity = direction * potion_data.throw_force
	
	var spawner = actor.get_tree().get_first_node_in_group("ProjectileSpawner")
	if spawner:
		var hand_node = actor.get_node_or_null("MeshInstance3D/FakeSkeleton/RightHand")
		var real_spawn_pos = hand_node.global_position if hand_node else spawn_pos
		
		spawner.spawn([real_spawn_pos, Basis.looking_at(direction), velocity, potion_data.resource_path, actor.name.to_int()])
		if potion_data.consume_on_use:
			_consume_source_item(asc, handle)


func _get_potion_data_from_source(asc: AbilitySystemComponent, handle: AbilitySpecHandle) -> PotionData:
	var source = asc.get_ability_source(handle)
	var inventory: Inventory = source.get("inventory")
	var slot_index: int = source.get("slot", -1)
	
	if not inventory or slot_index == -1: return null
	
	var stack = inventory.stacks[slot_index]
	if not stack: return null
	
	var item_def = inventory.database.get_item(stack.item_id)
	if not item_def: return null
	print(item_def.properties)
	if item_def.properties.has("potion_data"):
		return load(item_def.properties["potion_data"]) as PotionData
	
	return null


func _consume_source_item(asc: AbilitySystemComponent, handle: AbilitySpecHandle) -> void:
	var source = asc.get_ability_source(handle)
	var inventory: Inventory = source.get("inventory")
	var slot_index: int = source.get("slot", -1)
	
	if inventory and slot_index != -1:
		inventory.remove_at(slot_index, inventory.stacks[slot_index].item_id, 1)
</file>

<file path="godot-coop/characters/player/equipment_manager.gd">
@tool
@icon("res://addons/inventory-system/icons/interactor.svg")
class_name EquipmentManager
extends Node
@export var ability_system_node: NodePath = "../../AbilitySystemComponent"
@onready var ability_system: AbilitySystemComponent = get_node(ability_system_node)
@onready var openable: Openable = $HeadSlot/Openable
@onready var fake_skeleton: Node3D = $"../../MeshInstance3D/FakeSkeleton"

@export var character_mesh_root: Node3D 

## Maps slot_id (String) -> NodePath. The slot_id is the node name.
## This separates the physical slot instance from the logical SlotType.
@export var equipment_slots: Dictionary = {
	"HeadSlot": NodePath("HeadSlot"),
	"ChestSlot": NodePath("ChestSlot"),
	"HandSlot": NodePath("HandSlot"),
	"BeltSlot1": NodePath("BeltSlot1"),
	"BeltSlot2": NodePath("BeltSlot2"),
	"BeltSlot3": NodePath("BeltSlot3"),
}

## Tracks active equipment by slot_id (String) -> context Dictionary
var active_equipment: Dictionary = {}

## Storage-only slots: items here get visuals but NO abilities/effects.
## These are for carrying items, not for "using" them.
const STORAGE_SLOTS: Array[String] = ["BeltSlot1", "BeltSlot2", "BeltSlot3"]


func open(character: Node):
	openable.open(character)


func close(character: Node):
	openable.close(character)


func _ready() -> void:
	await get_tree().process_frame
	_connect_slots()


func _connect_slots() -> void:
	for slot_id in equipment_slots:
		var node_path = equipment_slots[slot_id]
		var inventory = get_node_or_null(node_path)
		
		if inventory:
			# Pass slot_id (String) to identify which physical slot triggered the event
			inventory.stack_added.connect(_on_item_equipped.bind(inventory, slot_id))
			inventory.stack_removed.connect(_on_item_unequipped.bind(inventory, slot_id))
		else:
			printerr("[EquipmentManager] Invalid inventory path for slot: ", slot_id)


func _on_item_equipped(stack_index: int, inventory: Node, slot_id: String) -> void:
	var stack = inventory.stacks[stack_index]
	if stack == null: return
	
	var def = inventory.database.get_item(stack.item_id)
	if not def.properties.has("equipment_data"): return
	
	var data_path = def.properties["equipment_data"]
	var data = load(data_path) as EquipmentData
	_apply_equipment_logic(data, slot_id)


func _on_item_unequipped(_stack_index: int, _inventory: Node, slot_id: String) -> void:
	_remove_equipment_logic(slot_id)


func _apply_equipment_logic(data: EquipmentData, slot_id: String) -> void:
	if active_equipment.has(slot_id):
		_remove_equipment_logic(slot_id)
	
	var context = {
		"effect_handles": [],
		"ability_handles": [],
		"visual_node": null
	}
	
	var is_storage_slot = STORAGE_SLOTS.has(slot_id)
	
	# Only apply abilities and effects for NON-storage slots (active equipment)
	if not is_storage_slot and multiplayer.is_server():
		_apply_equipment_effects_logic(data, slot_id, context)
	
	# Visuals are applied for ALL slots (including storage)
	if data.visual_scene and fake_skeleton:
		context["visual_node"] = _spawn_visual_attachment(data, slot_id)
	
	active_equipment[slot_id] = context


## Testable equipment effects logic - call directly in tests
func _apply_equipment_effects_logic(data: EquipmentData, slot_id: String, context: Dictionary) -> void:
	if data.passive_effects.size() > 0:
		var handles = ability_system.effect_manager._apply_effects_logic(data.passive_effects)
		context["effect_handles"].append_array(handles)
	
	if data.granted_abilities.size() > 0:
		var inventory_node = get_node(equipment_slots[slot_id])
		for grant in data.granted_abilities:
			var handle = ability_system.ability_manager._grant_ability_logic(
				grant.ability,
				grant.input_tag,
				inventory_node,
				0
			)
			if handle:
				context["ability_handles"].append(handle)


func _remove_equipment_logic(slot_id: String) -> void:
	if not active_equipment.has(slot_id): return
	
	var context = active_equipment[slot_id]
	
	if multiplayer.is_server():
		_remove_equipment_effects_logic(context)
	
	if is_instance_valid(context["visual_node"]):
		context["visual_node"].queue_free()
	
	active_equipment.erase(slot_id)


## Testable remove equipment effects logic - call directly in tests
func _remove_equipment_effects_logic(context: Dictionary) -> void:
	for handle in context["effect_handles"]:
		ability_system.effect_manager._remove_effect_logic(handle)
		
	for handle in context["ability_handles"]:
		ability_system.ability_manager._clear_ability_logic(handle)


## Maps slot_id to the corresponding visual marker name in the skeleton.
## This allows items with SlotType.BELT to be placed in the correct marker
## based on which physical slot they were equipped to.
const SLOT_TO_MARKER: Dictionary = {
	"HeadSlot": "Head",
	"ChestSlot": "Chest", 
	"HandSlot": "RightHand",
	"BeltSlot1": "BeltSlotMarker1",
	"BeltSlot2": "BeltSlotMarker2",
	"BeltSlot3": "BeltSlotMarker3",
}

## Belt slot names for quick access by index (1, 2, 3)
const BELT_SLOTS: Array[String] = ["BeltSlot1", "BeltSlot2", "BeltSlot3"]

## Tracks if a swap is currently in progress (prevents spam)
var _swap_in_progress: bool = false


# ============================================
# BELT SLOT SWAP SYSTEM
# ============================================

## Called by client to request a swap between HandSlot and a BeltSlot
## belt_index: 0, 1, or 2 (corresponding to BeltSlot1, BeltSlot2, BeltSlot3)
func request_swap_belt_slot(belt_index: int) -> void:
	if belt_index < 0 or belt_index >= BELT_SLOTS.size():
		return
	
	if multiplayer.is_server():
		_start_swap(belt_index)
	else:
		_swap_belt_slot_rpc.rpc_id(1, belt_index)


## Testable swap request logic - call directly in tests (bypasses network check)
func _request_swap_belt_slot_logic(belt_index: int) -> void:
	if belt_index < 0 or belt_index >= BELT_SLOTS.size():
		return
	_start_swap(belt_index)


@rpc("any_peer", "reliable")
func _swap_belt_slot_rpc(belt_index: int) -> void:
	if not multiplayer.is_server():
		return
	_start_swap(belt_index)


## Validates and starts the swap process with delay
func _start_swap(belt_index: int) -> void:
	# Prevent multiple swaps at once
	if _swap_in_progress:
		return
	
	var hand_slot: GridInventory = get_node_or_null(equipment_slots["HandSlot"])
	var belt_slot: GridInventory = get_node_or_null(equipment_slots[BELT_SLOTS[belt_index]])
	
	if hand_slot == null or belt_slot == null:
		return
	
	# Check if there's anything to swap
	var hand_has_item = _slot_has_item(hand_slot)
	var belt_has_item = _slot_has_item(belt_slot)
	
	# Only proceed if at least one slot has an item
	if not hand_has_item and not belt_has_item:
		return
	
	# Get swap time from ability system's attribute set
	var swap_duration = 0.5  # Default fallback
	if ability_system and ability_system.attribute_set:
		swap_duration = ability_system.attribute_set.swap_time
	
	_swap_in_progress = true
	print("[EquipmentManager] Starting swap... (%.2fs)" % swap_duration)
	
	# Wait for the swap duration, then perform the swap
	await get_tree().create_timer(swap_duration).timeout
	
	# Re-validate after delay (items might have changed)
	if _slot_has_item(hand_slot) or _slot_has_item(belt_slot):
		_perform_atomic_swap(belt_index)
	
	_swap_in_progress = false


## Checks if a slot contains any item
func _slot_has_item(slot: GridInventory) -> bool:
	if slot.stacks.size() == 0:
		return false
	return slot.stacks[0] != null


## Performs an atomic swap between HandSlot and the specified BeltSlot
## This runs ONLY on the server to prevent race conditions
func _perform_atomic_swap(belt_index: int) -> void:
	var hand_slot: GridInventory = get_node_or_null(equipment_slots["HandSlot"])
	var belt_slot: GridInventory = get_node_or_null(equipment_slots[BELT_SLOTS[belt_index]])
	
	if hand_slot == null or belt_slot == null:
		return
	
	# Extract data from both slots BEFORE modifying anything
	var hand_data = _extract_slot_data(hand_slot)
	var belt_data = _extract_slot_data(belt_slot)
	
	# Clear both slots (this triggers stack_removed signals)
	_clear_slot(hand_slot)
	_clear_slot(belt_slot)
	
	# Add items to swapped positions (this triggers stack_added signals)
	# Belt item -> Hand
	if not belt_data.is_empty():
		_add_to_slot(hand_slot, belt_data)
	
	# Hand item -> Belt
	if not hand_data.is_empty():
		_add_to_slot(belt_slot, hand_data)
	
	print("[EquipmentManager] Swapped HandSlot <-> ", BELT_SLOTS[belt_index])


## Extracts item data from a slot (returns null if empty)
func _extract_slot_data(slot: GridInventory) -> Dictionary:
	if slot.stacks.size() == 0:
		return {}
	
	var stack = slot.stacks[0]
	if stack == null:
		return {}
	
	return {
		"item_id": stack.item_id,
		"amount": stack.amount,
		"properties": stack.properties.duplicate(),
		"position": slot.stack_positions[0] if slot.stack_positions.size() > 0 else Vector2i.ZERO,
		"rotation": slot.stack_rotations[0] if slot.stack_rotations.size() > 0 else false
	}


## Clears all items from a slot
func _clear_slot(slot: GridInventory) -> void:
	# Remove from end to start to avoid index shifting issues
	for i in range(slot.stacks.size() - 1, -1, -1):
		var stack = slot.stacks[i]
		if stack != null:
			slot.remove_at(i, stack.item_id, stack.amount)


## Adds an item to a slot using extracted data
func _add_to_slot(slot: GridInventory, data: Dictionary) -> void:
	if data.is_empty():
		return
	slot.add_at_position(
		data.get("position", Vector2i.ZERO),
		data["item_id"],
		data["amount"],
		data.get("properties", {}),
		data.get("rotation", false)
	)


func _spawn_visual_attachment(data: EquipmentData, slot_id: String) -> Node3D:
	if not data.visual_scene: return null
	
	var visual_instance = data.visual_scene.instantiate()
	
	# Determine marker: use slot-specific marker, or fallback to data.bone_name
	var marker_name = SLOT_TO_MARKER.get(slot_id, data.bone_name)
	
	if marker_name != "":
		var marker = fake_skeleton.get_node_or_null(marker_name)
		if marker:
			marker.add_child(visual_instance)
			return visual_instance
		else:
			printerr("[EquipmentManager] Marker not found: ", marker_name)
	
	fake_skeleton.add_child(visual_instance)
	return visual_instance
</file>

<file path="godot-coop/characters/player/player.gd">
extends CharacterBase


const JUMP_VELOCITY = 4.5
const ROTATION_SPEED = 10.0

@onready var camera: Camera3D = $SpringArmPivot/Camera3D
@onready var mesh_instance_3d: MeshInstance3D = $MeshInstance3D
@onready var character_inventory_system: NetworkedCharacterInventorySystem = $CharacterInventorySystem
@onready var label_3d: Label3D = $Label3D


func _enter_tree() -> void:
	super._enter_tree()
	set_multiplayer_authority(name.to_int())
	$CharacterInventorySystem/Inventory/SyncInventory.set_multiplayer_authority(1)
	#$CharacterInventorySystem/EquipmentInventory/SyncInventory.set_multiplayer_authority(1)
	#%SyncHotbar.set_multiplayer_authority(1)
	$CharacterInventorySystem/CraftStation/SyncCraftStation.set_multiplayer_authority(1)
	$AbilitySystemComponent.set_multiplayer_authority(1)
	for system in $AbilitySystemComponent.get_children():
		system.set_multiplayer_authority(1)

	for inventory in $CharacterInventorySystem/EquipmentManager.get_children():
		if inventory is GridInventory:
			inventory.set_multiplayer_authority(1)
			for sincronizer in inventory.get_children():
				sincronizer.set_multiplayer_authority(1)


func _ready() -> void:
	label_3d.text = str(name)
	pass


func _physics_process(delta: float) -> void:
	if !is_multiplayer_authority(): return
	
	if not is_on_floor():
		velocity += get_gravity() * delta

	if Input.is_action_just_pressed("ui_accept") and is_on_floor():
		velocity.y = JUMP_VELOCITY

	var input_dir := Input.get_vector("move_left", "move_right", "move_forward", "move_backward")
	var direction := Vector3(input_dir.x, 0, input_dir.y).normalized()
	
	direction = direction.rotated(Vector3.UP, camera.global_rotation.y)
	if ability_system.is_strafing:
		mesh_instance_3d.global_rotation.y = camera.global_rotation.y
	
	if direction:
		velocity.x = direction.x * ability_system.speed
		velocity.z = direction.z * ability_system.speed
		
		var target_rotation = atan2(direction.x, direction.z) + PI
		if not ability_system.is_strafing:
			mesh_instance_3d.rotation.y = lerp_angle(mesh_instance_3d.rotation.y, target_rotation, delta * ROTATION_SPEED)
	else:
		velocity.x = move_toward(velocity.x, 0, ability_system.speed)
		velocity.z = move_toward(velocity.z, 0, ability_system.speed)

	move_and_slide()


func _input(event: InputEvent) -> void:
	if not is_multiplayer_authority(): return
	if Input.get_mouse_mode() != Input.MOUSE_MODE_CAPTURED: return
	
	if event.is_action_pressed("attack_primary"):
		var data = _collect_activation_data()
		ability_system.server_ability_input_pressed(AbilityManager.INPUT_PRIMARY, data)
		
	if event.is_action_released("attack_primary"):
		ability_system.server_ability_input_released(AbilityManager.INPUT_PRIMARY)

	if event.is_action_pressed("attack_secondary"):
		ability_system.server_ability_input_pressed(AbilityManager.INPUT_SECONDARY, {})
		
	if event.is_action_released("attack_secondary"):
		ability_system.server_ability_input_released(AbilityManager.INPUT_SECONDARY)
	
	# Belt slot swap inputs (1, 2, 3 keys)
	_handle_belt_slot_inputs(event)


func _handle_belt_slot_inputs(event: InputEvent) -> void:
	var equipment_manager = character_inventory_system.equipment_manager
	if equipment_manager == null:
		return
	
	if event.is_action_pressed("belt_slot_1"):
		equipment_manager.request_swap_belt_slot(0)
	elif event.is_action_pressed("belt_slot_2"):
		equipment_manager.request_swap_belt_slot(1)
	elif event.is_action_pressed("belt_slot_3"):
		equipment_manager.request_swap_belt_slot(2)


func _collect_activation_data() -> Dictionary:
	return {
		"aim_direction": -camera.global_transform.basis.z,
		"aim_position": camera.global_position
	}


func set_strafing(state: bool) -> void:
	ability_system.is_strafing = state
</file>

</files>
